<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>ssdm</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="0b272745-0c9a-4baa-acbf-666a5f8fa0f2" class="page sans"><header><h1 class="page-title">ssdm</h1></header><div class="page-body"><hr id="35c58218-af7d-441e-bb10-2eecb9e443fb"/><p id="4f0c67d9-1119-4378-b128-e0ac1cd468bb" class="">
</p><nav id="cfc8cbf3-2311-48ae-acc9-87e748606229" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#320e4769-b3fc-4f97-962d-288d23cd87f6">LRU</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6f853e80-98ad-4b63-ae97-a3ee15bcec4b">LFU</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3e9c6eb9-da5e-4a41-bb2a-d7df91b4558d">哈希表+二叉平衡树</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2c898115-2579-4a40-a360-ea5d5127f450">两个哈希表</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#cd55a3fb-cc85-4098-8ad3-e0d88c21b193">最长上升子序列LIS</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d3d44cd4-dff7-4a30-b755-2e46c817fcd0">回溯</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a6645be1-3cb6-4873-8bc1-9e6e25424486">动态规划（经典）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a7e863a6-b7b2-4669-9950-2156b82534fb">贪心+二分</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5da51f26-8fbe-42a3-a3da-f7efff648130">最长重复子数组</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#11d5f9a4-1761-4dbb-9ec6-94cf078bb0de">优化一：动态规划</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#30a58263-fee8-4e62-bf56-96449b1c4672">优化二：滑动窗口</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#097d72b5-1099-4d31-9f8f-8e6c20111c5d">接雨水</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b67a1680-f33f-4a94-ab62-6f1ae5f9adbf">动态规划</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#33c4e281-811b-4ea2-a5cd-58adc4feabfd">单调栈</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fbeb0753-de54-4ef2-85ef-96729862b0c7">双指针</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3c19020a-bcda-497e-b883-48597d18fc50">合并k个有序链表</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#96b35693-4154-4b7b-a9d3-6729839f381a">分治</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3482fec4-8979-4124-9a50-0096f5eaf321">优先队列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#49efca91-eb5c-4f44-804d-6bbb1769caa4">寻找两个有序数组中的中位数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e4e53c21-f0dc-45d3-887f-c0c1a05e8610">最小覆盖子串</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6e022ce0-9012-40f0-af03-6ada08a20487">如何判断一个子串是否包含了另一个字符串的全部字符呢？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#24392d08-957c-49ba-9648-28ac978483bc">滑动窗口</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#475f7abb-1299-49e3-9e01-4ef47c1ddfda">拓展：如果T中字符的位置在S中出现的顺序不能改变怎么办呢？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e12cd8c2-d410-4174-baf4-08bf5c739c97">最长有效括号</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e14840b3-14eb-4c54-83b3-2541843d7ac9">栈</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ca01f463-201e-4935-8550-52c9ba1eba95">动态规划</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#787d7ed1-8a58-4a38-b670-c8b3ad2d7781">正向逆向结合</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#68734c26-d98a-4396-b21a-011847ed404f">最长连续序列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#50ceee93-9ac1-40e7-80ae-4c076026342f">长度最小的子数组</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#05fb8dd2-97aa-45b0-9db4-27ae630a07b6">暴力</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#748cedd4-ffd5-4561-8331-18e6017a3617">前缀和+二分</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a36464b5-ed97-4424-a539-ed98071e985c">滑动窗口</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bd7fecb6-278e-47f3-9d4d-e562c6560804">数组中的逆序对</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#29e77ed8-e37c-4629-a3e9-9f9a199656ed">暴力——超时</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1c6cc0cb-e86e-4a8a-84ba-d0bb205191e8">分治（类似于归并排序）</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#466912e5-f69a-4a88-a90a-96ef2b23ef52">计算器1（+-*/无括号）</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ab9f18f4-f1e9-4667-8dbc-51f220f929a5">计算器2（+-括号）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#09e20f04-14fe-4ab7-8d15-9a065ebc7736">括号击穿</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#12dc75df-1b53-4345-821a-00d7db9d3e83">双栈</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5cdf72c6-e541-4646-8a55-1dcb78c650d0">寻找重复数</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1dbc3bda-7222-4067-a736-dbd101e6e2df">二分查找</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#07c60f7e-5080-493f-91d3-71c26ee07180">快慢指针（Floyd判圈）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8f1e909f-4c37-40f0-a0c9-0a82b649669d">二进制展开</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7fc4c474-4165-40e0-886f-016931fd03b0">鸡蛋掉落</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#33a44642-45a1-48ee-8602-a166bdb1a8b4">动态规划+二分</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#124a2030-1690-43b3-8650-c543328558a5">另一种动态规划</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3abdb547-3888-410c-bfd1-d177173de897">字符串转整数问题、越界问题</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7a507f7b-f82e-48a8-9834-b30acafd4ca7">下一个排列和上一个排列</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#48921b95-e0f3-4312-ae3d-86edeb6d5405">下一个排列的算法步骤：</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c141c47a-c301-49c0-bac1-2f496232b657">上一个排列的算法步骤：——其实是上面的逆过程</a></div></nav><h2 id="320e4769-b3fc-4f97-962d-288d23cd87f6" class="">LRU</h2><p id="9647ce49-c32e-4275-a0bb-97000c70cf31" class="">见leetcode146题</p><figure id="03c80165-b2b2-4183-a9c7-74e62ed10a22"><a href="https://leetcode-cn.com/problems/lru-cache/" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">力扣</div></div><div class="bookmark-href"><img src="https://leetcode-cn.com/favicon.ico" class="icon bookmark-icon"/>https://leetcode-cn.com/problems/lru-cache/</div></div></a></figure><p id="1486f104-519c-430e-8f69-1c45412c4173" class="">代码如下：</p><figure id="2bd04098-de3c-4219-8540-4cf737fdb100"><div class="source"><a href="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/main.cpp">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a04b66b0-392d-4275-a5de-c7690ac94fe9/main.cpp</a></div></figure><p id="903f0ee8-ad4e-4ed2-a4d7-a6c9df784c8f" class="">记录了用<strong>STL的lis</strong>t和<strong>自己定义双向链表</strong>两种实现方式。</p><p id="72e11303-4f52-40b2-bfab-d7222188ffb7" class="">
</p><h2 id="6f853e80-98ad-4b63-ae97-a3ee15bcec4b" class="">LFU</h2><p id="560ca494-3c00-4db0-9b3b-a26dfddb8069" class="">见leetcode460题</p><figure id="5e5a885f-e210-4347-8ff6-5d2408ec4c91"><a href="https://leetcode-cn.com/problems/lfu-cache/submissions/" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">力扣</div></div><div class="bookmark-href"><img src="https://leetcode-cn.com/favicon.ico" class="icon bookmark-icon"/>https://leetcode-cn.com/problems/lfu-cache/submissions/</div></div></a></figure><p id="66afdfb7-a059-4c17-a198-35db35e06ab4" class="">要注意哈，应该保持良好的编程习惯，应该和LRU的定义吻合起来，把最不应该删除的节点放在头部，把下次要删的放在尾部。leetcode上提交的代码正好相反。</p><p id="57bcd346-a05d-48a1-ba85-1aebfcc35c48" class="">我太愚蠢了😭 这可以不像LRU那样单纯的用链表，因为它的update和insert不是常数时间级的，可以有两种方法获得更好的时间复杂度</p><p id="6f3e43ec-d8db-4a57-8d96-51d971640f05" class="">
</p><h3 id="3e9c6eb9-da5e-4a41-bb2a-d7df91b4558d" class="">哈希表+二叉平衡树</h3><p id="225d1526-7912-49b9-a98c-c523ff772dc6" class="">二叉平衡树可以用set来实现，在其中重载一下()或&lt;。</p><p id="c3e96564-076a-4ce9-a68b-641635a22058" class="">哈希表中存放(key,node)对。</p><p id="7430334b-8328-4584-b88e-b3db5091bab6" class="">这里节点node中除了维护使用次数还要维护上一次使用时间。</p><p id="55a33c46-1750-4ac7-a6ee-3c3ff75c3e70" class="">时间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><p id="67b85fa5-d033-48c3-9a2b-3b25ca3589c0" class="">空间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(capacity)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><p id="a1c8a5ab-aa9b-4db9-9ea4-3d11d0bf9679" class="">
</p><h3 id="2c898115-2579-4a40-a360-ea5d5127f450" class="">两个哈希表</h3><p id="e1c915e9-9fcb-410f-923b-a883cc6ae6f0" class="">一个哈希表中存放(key,node)对</p><p id="9da63c87-58c1-4204-add6-f35640006469" class="">另一个哈希表中存放(freq,lianbiao)，这里freq是使用的频次，后面对应一条链表是这个使用频次下的节点，越靠近头的是越近使用过的（因为插入时插在头部）</p><p id="c4299d37-6bcc-4fdf-9a08-8fc151841bed" class="">另外再实时维护一个minFreq，记录第二个哈希表中最小的频率。</p><p id="f73cde87-c5b6-4975-9206-f1b72226761f" class="">时间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><p id="cb1a1256-2f4f-40f4-a68c-80f730011bf9" class="">空间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(capacity)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><p id="49c85e3d-9f58-4c77-a84a-9f2bd0d1895c" class="">
</p><p id="6bc694de-0fc8-40fb-bb41-56f257845d58" class="">
</p><h2 id="cd55a3fb-cc85-4098-8ad3-e0d88c21b193" class="">最长上升子序列LIS</h2><p id="27897209-3aed-40bd-9940-4197b3a96a4e" class="">三种解法：回溯、动态规划、贪心+二分</p><p id="f916eb8b-33fe-4643-a633-cfeb1d964763" class="">注意子序列和子串的区别：</p><ul id="15d86f98-f705-4a39-a2a4-794d3e09050e" class="bulleted-list"><li>子序列不一定是连续的</li></ul><ul id="0626731e-ea44-4fd4-b5f6-86c2e9c09c68" class="bulleted-list"><li>子串是连续的，详见下一题：最长公共子数组</li></ul><h3 id="d3d44cd4-dff7-4a30-b755-2e46c817fcd0" class="">回溯</h3><p id="63530275-fb3b-4ac2-bce3-5211ba1d0411" class="">emmmm</p><p id="55a71f2b-f38f-4a32-959f-fe48be13baf6" class="">先找出所有子序列，然后判断是否为上升，<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><p id="ed415304-d266-4d57-901a-f0b7678b525d" class="">
</p><h3 id="a6645be1-3cb6-4873-8bc1-9e6e25424486" class="">动态规划（经典）</h3><p id="9e305019-254b-45dc-b713-918ef14d0cea" class="">dp[i]表示以第i元素结尾的最长上升子序列的长度。每次搜索的时候，找nums[0~i-1]中小于nums[i]的那些dp，取其中最大的加一。</p><p id="1c99f033-021e-469b-8a90-cf61e87b5afe" class=""><strong>复杂度分析</strong></p><p id="47a8af5b-ab86-4c23-8079-eff1378a75a1" class="">时间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><p id="448439c9-7715-4df8-aa50-4273bcf5663c" class="">空间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><pre id="d6cb65fc-1c98-435a-b69c-dab6b2bb8493" class="code"><code>class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; dp(n,1);
        for (int i=1; i&lt;n; ++i){
            for (int k=0; k&lt;i; ++k){
                if (nums[k]&lt;nums[i]){
                    dp[i] = max(dp[i],dp[k]+1);
                }
            }
        }
        int maxlen = 1;
        for (int i=0; i&lt;n; ++i){
            maxlen = dp[i]&gt;maxlen ? dp[i] : maxlen;
        }
        return maxlen;
    }
};</code></pre><p id="224d4623-6470-47d4-b1f2-934ceaa7d63e" class="">
</p><h3 id="a7e863a6-b7b2-4669-9950-2156b82534fb" class="">贪心+二分</h3><p id="6124aad6-4475-4ea1-8593-8bbbdf764584" class="">用tail数组来表示和记录每个长度上升子序列的最小末尾元素。</p><p id="80ab44e7-569a-456f-a459-e75529faeeb1" class="">如tail[0]表示长度为1的上升子序列的最小末尾元素，tail[1]表示长度为2的上升子序列的最小末尾元素。对于序列 <code>2 4 0 7 1 8</code> ， <code>tail[0]=0,tail[1]=1</code> ，这样就只需要遍历一边nums数组，但是每新读一个数都要更新tail数组</p><ul id="fdffb30d-18f0-4f77-9877-8d909f6a5e90" class="bulleted-list"><li>如果nums[i]比tail的末尾数字大，则加到末尾，长度加一</li></ul><ul id="66fc8575-0e7e-459d-adc1-8974b352bd84" class="bulleted-list"><li>如果nums[i]比tail的末尾数字小，则把tail中之前第一个比nums[i]大的元素改成nums[i]</li></ul><p id="b0c04ebc-fe7d-4c93-afe8-f0def78869e1" class="">因为是从前往后遍历的，现在读取的数字肯定出现在已经在tail中的数字后面。</p><p id="b987d810-c62d-43ef-90af-d808bee75b3a" class=""><strong>复杂度分析</strong></p><p id="3e693005-7cdc-4379-bf7b-8c0dbd8a0fd5" class="">时间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span>，因为tail数组中是单调增的，所以可以用二分查找，再乘上外循环的N次</p><p id="7340f5c1-5737-4fea-b12b-84c91f2a3c8b" class="">空间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><pre id="b37f30f0-cc4a-4d96-9b57-4cc3f025da2c" class="code"><code>class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; tail;
        tail.push_back(nums[0]);
        for (int i=1; i&lt;n; ++i){
            if (nums[i] &gt; tail.back()){
                tail.push_back(nums[i]);
            }
            else if (nums[i] &lt; tail.back()){
                int l=0, r=tail.size()-1;
                while (l&lt;=r){
                    int mid = l + (r-l)/2;
                    if (tail[mid] == nums[i]){
                        break;
                    }
                    else if (tail[mid] &lt; nums[i]){
                        l = mid + 1;
                    }
                    else{
                        r = mid - 1;
                    }
                }
                if (l&gt;r){
                    tail[l] = nums[i];
                }
            }
        }
        return tail.size();
    }
};</code></pre><p id="c5e75484-0d14-4e94-b6c5-962f10bfb3a0" class="">
</p><p id="04e068bd-f60a-48af-9bd9-2747e20c64ff" class="">如果要输出某个最长子序列的话，可以用动态规划的方法</p><pre id="43e9be5a-d9a9-4e6c-8698-14a8700f9f5d" class="code"><code>//从最长的那个末尾元素坐标ind开始，往前遍历dp数组，从maxlen开始寻找第一个maxlen-1，
//然后寻找第一个maxlen-2，以此类推
vector&lt;int&gt; record(maxlen);
int k = maxlen-1;
int lastlen = maxlen+1;
for (; ind&gt;=0; --ind){
    if (dp[ind] == lastlen-1){
        record[k] = nums[ind];
        k--;
        lastlen--;
    }
}</code></pre><p id="e356ee7c-b035-420b-aad9-d021ccd945c6" class="">
</p><h2 id="5da51f26-8fbe-42a3-a3da-f7efff648130" class="">最长重复子数组</h2><p id="0ecc7e0f-6b39-4c37-a20f-daca66796b38" class="">万事先从暴力开始🐶</p><p id="cec1be9b-01a7-48bc-b864-2834161d530d" class="">然后考虑优化</p><h3 id="11d5f9a4-1761-4dbb-9ec6-94cf078bb0de" class="">优化一：动态规划</h3><p id="2df02b3d-c6b0-4101-b5e2-25a880d048c1" class="">从后往前即可用O(1)计算出当前坐标及以后的最长前缀。</p><pre id="2bdb5f50-a6f2-482e-b486-6261c71470a4" class="code"><code>class Solution {
public:
    int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        int len1 = A.size();
        int len2 = B.size();
        int maxlen = 0;
        vector&lt;vector&lt;int&gt;&gt; dp(len1+1,vector&lt;int&gt;(len2+1,0));
        for (int i=len1-1; i&gt;=0; --i){
            for (int j=len2-1; j&gt;=0; --j){
                dp[i][j] = A[i]==B[j] ? dp[i+1][j+1]+1 : 0;
                maxlen = max(maxlen,dp[i][j]);
            }
        }
        return maxlen;
    }
};</code></pre><p id="137ac02b-5d74-421e-98fa-3285505093a4" class="">emmm，好像从前面开始遍历也可以：</p><pre id="66c08a6b-a79f-46fa-8fd4-fa53d151c4bb" class="code"><code>if (A[i]==B[j]){
		dp[i][j] = dp[i-1][j-1]+1;
} else{
		dp[i][j] = 0;
}</code></pre><p id="5a829934-f5dd-4b3a-b2de-f3875ac112c2" class="">
</p><h3 id="30a58263-fee8-4e62-bf56-96449b1c4672" class="">优化二：滑动窗口</h3><p id="9ca87fe5-ca96-4d57-b29b-032d2f605a36" class="">滑动两个数组，使其有M+N-1种对齐方式</p><p id="5b117359-f365-4714-94e3-027d348aa7c3" class="">要注意每种对齐方式下，不要用while找，因为不是找最长前缀了，要对整个进行遍历</p><pre id="54dc9e56-1a0e-43e1-bfa4-c42bc5083652" class="code"><code>class Solution {
public:
    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();
        int maxlen = 0;
        for (int i=0; i&lt;len1; ++i){
            int len = 0;
            for (int pos1=i,pos2=0; pos1&lt;len1 &amp;&amp; pos2&lt;len2; ++pos1,++pos2){
                if (nums1[pos1]==nums2[pos2]){
                    ++len;
                    maxlen = max(maxlen,len);
                }
                else{
                    len = 0;
                }
            }
        }
        for (int j=0; j&lt;len2; ++j){
            int len = 0;
            for (int pos1=0,pos2=j; pos1&lt;len1 &amp;&amp; pos2&lt;len2; ++pos1,++pos2){
                if (nums1[pos1]==nums2[pos2]){
                    ++len;
                    maxlen = max(maxlen,len);
                }
                else{
                    len = 0;
                }
            }
        }
        return maxlen;
    }
};</code></pre><p id="8f803c26-55d7-4c93-a537-3a98e9c98a51" class="">
</p><h2 id="097d72b5-1099-4d31-9f8f-8e6c20111c5d" class="">接雨水</h2><p id="2855f730-3474-406d-9691-0bea828f0b9e" class="">三种方法：动态规划、单调栈、双指针</p><h3 id="b67a1680-f33f-4a94-ab62-6f1ae5f9adbf" class="">动态规划</h3><p id="09103b5f-a29b-4531-89f0-9c59ea0d068e" class="">用两个数组leftmax和rightmax，分别记录当前位置及左边的最高高度，和当前位置及右边的最高高度。因此每一个位置可接雨水量的min(leftmax[i],rightmax[i])-height[i]。</p><p id="d2a7f66d-c42f-421f-9044-d0a48b8f67fe" class="">注：不需要处理上面减法是否为负，因为包含了自己，至少为0。</p><pre id="9967d42c-cc8e-45fe-86c8-8a99ac7e5683" class="code"><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        if (n==0){
            return 0;
        }
        vector&lt;int&gt; leftmax(n,0);
        vector&lt;int&gt; rightmax(n,0);
        leftmax[0] = height[0];
        rightmax[n-1] = height[n-1];
        for (int i=1; i&lt;n; ++i){
            leftmax[i] = max(height[i],leftmax[i-1]);
        }
        for (int i=n-2; i&gt;=0; --i){
            rightmax[i] = max(height[i],rightmax[i+1]);
        }
        int count = 0;
        for (int i=1; i&lt;n-1; ++i){
            count += min(leftmax[i],rightmax[i]) - height[i];
        }
        return count;
    }
};</code></pre><p id="fa16921c-3f6b-4781-b07a-b2be0d863457" class="">
</p><h3 id="33c4e281-811b-4ea2-a5cd-58adc4feabfd" class="">单调栈</h3><p id="880eccd9-8041-4019-93c5-d67479d2b498" class="">有时候啊，不要总想着把高度记录下来，把下标记下来，不就高度也有了吗～</p><pre id="5076dfd7-a724-4934-b4af-62028a9cec08" class="code"><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        stack&lt;int&gt; stk;
        int count = 0;
        for (int i=0; i&lt;height.size(); ++i){
            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]){
                int toph = height[stk.top()];
                stk.pop();
                if (!stk.empty()){
                    int left = stk.top();
                    count += (min(height[left],height[i])-toph) * (i-left-1);
                }
            }
            stk.push(i);
        }
        return count;
    }
};</code></pre><p id="b7a03830-268e-46a6-ae75-a12eb56c554c" class="">注意这里的stk存的是下标，从底到顶的下标对应的高度是单调递减的</p><p id="ba6b33cf-d938-4387-80b9-cc5453ed1656" class="">
</p><h3 id="fbeb0753-de54-4ef2-85ef-96729862b0c7" class="">双指针</h3><p id="15fb9175-55d7-4fc5-90be-52fc8d64f671" class="">可以将动态规划的空间复杂度降到<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><pre id="88b76eb9-2879-4a94-821c-e600df7ed14b" class="code"><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int l = 0, r = height.size()-1;
        int leftmax = 0, rightmax = 0;
        int count = 0;
        while (l &lt;= r){
            if (leftmax &lt; rightmax){
                if (height[l] &gt; leftmax){
                    leftmax = height[l];
                }
                else{
                    count += leftmax - height[l];
                }
                ++l;
            }
            else{
                if (height[r] &gt; rightmax){
                    rightmax = height[r];
                }
                else{
                    count += rightmax - height[r];
                }
                --r;
            }
        }
        return count;
    }
};</code></pre><p id="839c5136-3003-46f5-b8dc-1d5e51c60636" class="">下面这个理解简直是醍醐灌顶</p><figure id="85a3b2a1-df6b-4b61-a344-77a2d66e36ad" class="image"><a href="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/Untitled.png"><img style="width:1554px" src="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/Untitled.png"/></a></figure><p id="ef77e32c-baf1-40e9-bc4f-7c12200f10d7" class="">
</p><p id="6ea4a142-2fcf-48d9-85d0-1442bf7c5cf4" class="">
</p><h2 id="3c19020a-bcda-497e-b883-48597d18fc50" class="">合并k个有序链表</h2><p id="70b6d2dd-4a10-4599-bf97-dd6279ceec98" class="">有两种想法，</p><ul id="071c3e53-e357-4f32-bfd3-10c6ebc941ec" class="bulleted-list"><li>以某一个链表为基准，每次从剩余未合并的链表中拿一个跟他合并 —— 优化成分治</li></ul><ul id="8ff288db-8c2e-4f41-9c1a-ad801063dd7c" class="bulleted-list"><li>k个一起合并，每次找最小的数 —— 优化成优先队列</li></ul><p id="8146d053-db35-426d-9ef4-b2b2b32ebded" class="">
</p><h3 id="96b35693-4154-4b7b-a9d3-6729839f381a" class="">分治</h3><p id="80847e6e-4587-4110-8bdc-07bdbc9e836d" class="">两个两个合并，合并之后的几个再两个两个合并。</p><p id="2d3826a8-5393-4c9b-b190-d4f4921548ee" class="">复杂度分析：</p><ul id="d18065b6-d9e3-4382-8e8c-3347b3dcafb5" class="bulleted-list"><li>时间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>∗</mo><mn>2</mn><mi>n</mi><mo>+</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>∗</mo><mn>4</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>∗</mo><mi>k</mi><mi>n</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k/2*2n+k/4*4n+1*kn=O(kn*logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">kn</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">kn</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ul><ul id="f9b42111-b17b-491f-80b6-ce84080d5824" class="bulleted-list"><li>空间复杂度：栈空间<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ul><pre id="52f0ba36-21d2-4e43-99db-0e9c6cc47b11" class="code"><code>class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        return merge(lists,0,lists.size()-1);
    }
    ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int l, int r){
        if (l&gt;r) return nullptr;
        if (l==r) return lists[l];
        int m = l + (r-l)/2;
        ListNode* l1 = merge(lists,l,m);
        ListNode* l2 = merge(lists,m+1,r);
        return mergeTwoLists(l1,l2);
    }
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2){
        ListNode* dummy = new ListNode(-1);
        ListNode* node = dummy;
        while (l1!=nullptr &amp;&amp; l2!=nullptr){
            if (l1-&gt;val &lt;= l2-&gt;val){
                node-&gt;next = l1;
                l1 = l1-&gt;next;
            }
            else{
                node-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            node = node-&gt;next;
        }
        node-&gt;next = l1!=nullptr ? l1 : l2;
        return dummy-&gt;next;
    }
};</code></pre><p id="1a2308ea-d44b-493e-8b20-2b8977bde397" class="">
</p><h3 id="3482fec4-8979-4124-9a50-0096f5eaf321" class="">优先队列</h3><p id="aebbbc73-46bb-4805-9a42-fa91bb4e14c2" class="">用优先队列priority_queue来维护一个小顶堆，从而可以以O(1)的时间找到下一个要合并的节点。</p><p id="a6613c20-1f7a-4de8-b1ec-17ed3e5da03f" class="">复杂度分析：</p><ul id="ea9152e1-e914-4196-8bc7-ef428c1e7785" class="bulleted-list"><li>时间复杂度：最多kn个节点，每个节点push进和pop出队列需要logk，所以<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn*logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">kn</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ul><ul id="b9920fe3-9dcf-4285-b750-b39a0d595030" class="bulleted-list"><li>空间复杂度：优先队列<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">kn</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ul><pre id="c1f86a8b-a066-4e55-97ef-8449c6fc9276" class="code"><code>class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        struct cmp{
            bool operator() (ListNode* l1, ListNode* l2){ return l1-&gt;val &gt; l2-&gt;val; }
        };
        ListNode* dummy = new ListNode(-1);
        ListNode* node = dummy;
        int k = lists.size();
        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt; q;
        for (ListNode* l : lists){
            if (l!=nullptr){
                q.push(l);
            } 
        }
        while (!q.empty()){
            ListNode* top = q.top();
            node-&gt;next = top;
            q.pop();
            if (top-&gt;next!=nullptr){
                q.push(top-&gt;next);
            }
            node = node-&gt;next;
        }

        return dummy-&gt;next;
    }
};</code></pre><p id="b6f753e1-d5a8-46f5-ba93-3ad489ab3e96" class="">
</p><p id="d374943b-c9c6-4b0c-9caa-ada83579a8a7" class="">
</p><h2 id="49efca91-eb5c-4f44-804d-6bbb1769caa4" class="">寻找两个有序数组中的中位数</h2><p id="456b3900-7e80-4e87-8162-60cf793977ea" class="">可以用数组长度算出中位数是第几个，然后遍历寻找。</p><p id="d1aab626-3785-4009-a98f-f40b3c8cfe8e" class="">优化：因为数组是有序的，所以可以用二分查找来优化。相当于用二分查找，找到两个数组中第k小的数。</p><p id="5e9ac66c-d838-4cec-8203-22f5547337d1" class="">注意：对于奇偶的判断可能会使复杂很多，所以不用太过吝啬，可以对于偶数情况分别找第k小和第k+1小的数，找两遍。</p><p id="71a2a6d1-4bfa-49ef-9f99-3124a921e8fa" class="">
</p><p id="016178a0-2bb5-4378-b693-474e3f79855b" class="">
</p><p id="b7f31cd2-9e56-4c46-838c-1e88ee3a3591" class="">
</p><p id="061e9bbf-0871-4ffa-bf48-44d3a067636d" class="">
</p><h2 id="e4e53c21-f0dc-45d3-887f-c0c1a05e8610" class="">最小覆盖子串</h2><h3 id="6e022ce0-9012-40f0-af03-6ada08a20487" class="">如何判断一个子串是否包含了另一个字符串的全部字符呢？</h3><p id="92cdf337-ae81-46b6-bb07-4c5ce55558c8" class="">用字符频数数组来记录</p><figure id="9b3b9e52-9210-4821-bbef-07ddf58311a7" class="image"><a href="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/Untitled%201.png"><img style="width:480px" src="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/Untitled%201.png"/></a></figure><p id="8a4c7bee-4cbd-4a63-8650-8422ab8c9086" class="">
</p><h3 id="24392d08-957c-49ba-9648-28ac978483bc" class="">滑动窗口</h3><p id="078931a1-51e0-48c7-98df-8603dec011ed" class="">算法描述：</p><ol id="7d47e349-9771-4fe4-b137-ffc42da0f602" class="numbered-list" start="1"><li>先向右移动右边界，使包含所有字符</li></ol><ol id="f8b4e396-8986-4486-9463-4c83ba00531f" class="numbered-list" start="2"><li>再向右移动左边界，使恰好包含所有字符，再右移一个时就不行了。记录此时的长度</li></ol><ol id="f7336104-8b48-4e24-80df-5edfbbeae462" class="numbered-list" start="3"><li>右移左边界一位，重复1</li></ol><p id="40279e67-8ae4-4e34-8c14-f77697a35ad7" class="">用distance来表示滑动窗口内包含T中字符的个数，从而实现O(1)时间判断是否包含。</p><pre id="9791857f-8599-4659-8f52-e707b346a784" class="code"><code>class Solution {
public:
    string minWindow(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        unordered_map&lt;char,int&gt; counts;
        unordered_map&lt;char,int&gt; countt;
        for (char c : t){
            countt[c]++;
        }

        int left = 0;
        int right = 0;
        int distance = 0;
        int recordleft = 0;
        int minlen = INT_MAX;
        while (right &lt; len1){
						// 下面循环结束之后，指向理想right的下一个
            while (distance &lt; len2 &amp;&amp; right &lt; len1){
                counts[s[right]]++;
                if (countt.find(s[right])!=countt.end() &amp;&amp; counts[s[right]]&lt;=countt[s[right]]){
                    distance++;
                }
                right++;
            }
            if (minlen==INT_MAX &amp;&amp; distance&lt;len2){
                return &quot;&quot;;
            }
						// 下面循环结束之后，指向理想left的下一个
            while (distance == len2 &amp;&amp; left &lt;= right &amp;&amp; left &lt; len1){
                if (countt.find(s[left])!=countt.end() &amp;&amp; counts[s[left]]==countt[s[left]]){
                    distance--;
                }
                counts[s[left]]--;
                left++;
            }
            // cout &lt;&lt; &quot;left-1: &quot; &lt;&lt; s[left-1] &lt;&lt; endl;
            // cout &lt;&lt; &quot;right-1: &quot; &lt;&lt; s[right-1] &lt;&lt; endl;
            if (right-left+1 &lt; minlen){
                recordleft = left-1;
                minlen = right-left+1;
            }
        }
        return s.substr(recordleft,minlen);
    }
};</code></pre><p id="96bb9149-5d69-41ca-9109-5fa5ea53ae12" class="">我写的是坨屎 😭</p><p id="61b202f5-e1bd-44b7-a7c7-d6cdaab7320d" class="">
</p><h3 id="475f7abb-1299-49e3-9e01-4ef47c1ddfda" class="">拓展：如果T中字符的位置在S中出现的顺序不能改变怎么办呢？</h3><p id="cb8ad28e-b2ae-408c-8e15-bed6eabe639f" class="">leetcode727题</p><figure id="df960265-ddb2-412f-9913-376c80695f6b"><a href="https://blog.csdn.net/qq_32523711/article/details/107610463?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">leetcode 第 727 题：最小窗口子序列(C++)</div><div class="bookmark-description">727. 最小窗口子序列 - 力扣（LeetCode）严格说这题并不是通俗的滑动窗口思路，因为这题对顺序有要求，所以单纯用哈希表统计字符个数的方法是行不通的，不过依然还是使用双指针的思路：</div></div><div class="bookmark-href"><img src="https://g.csdnimg.cn/static/logo/favicon32.ico" class="icon bookmark-icon"/>https://blog.csdn.net/qq_32523711/article/details/107610463?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</div></div><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png" class="bookmark-image"/></a></figure><ol id="b9b3ba72-9f5d-409f-9cf9-6fe1d2956a3d" class="numbered-list" start="1"><li>向右移动右边界，直到正好包含</li></ol><ol id="ca449b7f-a320-4736-ae02-9244fe20d81d" class="numbered-list" start="2"><li>从该右边界向左找到左边界，因为顺序是一致的所以可以这么做</li></ol><ol id="673c9b1f-7d98-4629-94ae-c17145657141" class="numbered-list" start="3"><li>右移左边界一位，回到1</li></ol><p id="9506ba03-fbec-4701-9fbc-6415704147bb" class="">
</p><p id="7a36a77a-318e-4db3-80b2-c0f96a27e762" class="">
</p><h2 id="e12cd8c2-d410-4174-baf4-08bf5c739c97" class="">最长有效括号</h2><h3 id="e14840b3-14eb-4c54-83b3-2541843d7ac9" class="">栈</h3><p id="1ef29f94-6667-426f-91b5-d8b1d02137ff" class="">栈底存储的是上一个未匹配的右括号的「下标」。若当前括号是(，则入栈下标；若当前括号是)，则弹出栈顶。</p><p id="19d886be-383d-4e96-84e5-7381fd5f2a44" class="">如果弹出后栈空了，则表明当前)未被匹配，将其下标入栈；如果弹出后没空，则表明当前)被匹配了，记录一下长度：当前)下标减去弹出后栈顶的下标。</p><pre id="91e5bfe0-9719-4a23-8875-cbe26706758b" class="code"><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0;
        stack&lt;int&gt; stk;
        stk.push(-1);
        for (int i = 0; i &lt; s.length(); i++) {
            if (s[i] == &#x27;(&#x27;) {
                stk.push(i);
            } else {
                stk.pop();
                if (stk.empty()) {
                    stk.push(i);
                } else {
                    maxans = max(maxans, i - stk.top());
                }
            }
        }
        return maxans;
    }
};
</code></pre><p id="e172d6af-845d-4b95-af97-2a7e276adb5a" class="">
</p><h3 id="ca01f463-201e-4935-8550-52c9ba1eba95" class="">动态规划</h3><p id="460f0dba-de69-4e19-894e-8af3357a199a" class="">dp表示，当前下标结束的字符串中连续的有效括号个数，为了记录空串的情况，整体往右移了一位。</p><pre id="570abd39-ee76-4b0d-979a-3dea3d105024" class="code"><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        vector&lt;int&gt; dp(n+1,0);
        int maxlen = 0;
        for (int i=1; i&lt;n; ++i){
            if (s[i]==&#x27;)&#x27;){
                if (s[i-1]==&#x27;(&#x27;){
                    dp[i+1] = dp[i-1] + 2;
                }
                else if (i-1-dp[i]&gt;=0 &amp;&amp; s[i-1-dp[i]]==&#x27;(&#x27;){
                    dp[i+1] = dp[i] + 2 + dp[i-1-dp[i]];
                }
                maxlen = max(maxlen,dp[i+1]);
            }
        }
        return maxlen;
    }
};</code></pre><h3 id="787d7ed1-8a58-4a38-b670-c8b3ad2d7781" class="">正向逆向结合</h3><p id="cfe5335b-85bb-4404-aeaa-6570463e20c1" class="">用两个变量遍历时记录左括号和右括号的个数。当括号数相等，则记录一次长度；当右括号个数大于左，则都清零。但是这无法对应这种情况：(()，所以再从右往左遍历一次，条件相反。</p><pre id="a5fc2066-475b-4df2-8623-aa487b504a6b" class="code"><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0, right = 0;
        int maxlen = 0;
        for (int i=0; i&lt;s.size(); ++i){
            if (s[i] == &#x27;(&#x27;){
                ++left;
            }
            else{
                ++right;
            }
            if (left == right){
                maxlen = max(maxlen,left+right);
            }
            else if (right &gt; left){
                left = 0;
                right = 0;
            }
        }
        left = 0;
        right = 0;
        for (int i=s.size()-1; i&gt;=0; --i){
            if (s[i] == &#x27;(&#x27;){
                ++left;
            }
            else{
                ++right;
            }
            if (left == right){
                maxlen = max(maxlen, left+right);
            }
            else if (left &gt; right){
                left = 0;
                right = 0;
            }
        }
        return maxlen;
    }
};</code></pre><p id="36711f30-fe20-41e4-9f5f-e9188cd7e799" class="">
</p><p id="b70dfe5b-13f8-4925-bdf8-205970be63ff" class="">
</p><h2 id="68734c26-d98a-4396-b21a-011847ed404f" class="">最长连续序列</h2><figure id="a11216d1-13ea-4287-873a-fef833e4eda1" class="image"><a href="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/Untitled%202.png"><img style="width:480px" src="ssdm%200b2727450c9a4baaacbf666a5f8fa0f2/Untitled%202.png"/></a></figure><p id="8484dc9d-df26-46a7-91c6-cbe5c38d1062" class="">先遍历一遍，把所有数放到set里。然后遍历set，找到每个连续序列的起点（n-1不在set中的数），然后循环找n+1是否在set中，在就长度加一。</p><pre id="69a519f4-03ca-4aa9-a750-79e5d2965e14" class="code"><code>class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; myset;
        for (const int&amp; n : nums){
            myset.insert(n);
        }
        int maxlen = 0;
        for (const int&amp; n : myset){
            if (!myset.count(n-1)){
                int len = 1;
                int x = n;
                while (myset.count(x+1)){
                    len += 1;
                    x += 1;
                }
                maxlen = max(maxlen,len);
            }
        }
        return maxlen;
    }
};</code></pre><p id="b5394e48-66a0-4033-8cef-e63ee9ca1845" class="">
</p><p id="dc05dea4-5105-4ab3-b11a-d1f1f581e283" class="">
</p><p id="81b590af-0044-4616-9ba9-4ecee33d7f34" class="">
</p><h2 id="50ceee93-9ac1-40e7-80ae-4c076026342f" class="">长度最小的子数组</h2><p id="9f85dcb1-4262-4bad-adfc-d358c62304a2" class="">注：涉及到连续子数组，一般有两种想法：滑动窗口、前缀和。</p><h3 id="05fb8dd2-97aa-45b0-9db4-27ae630a07b6" class="">暴力</h3><p id="a68bf47a-092b-4d76-aa07-c8c356fbf4f8" class="">对于每个下标，搜索以其开始的最短满足条件的子数组长度。</p><h3 id="748cedd4-ffd5-4561-8331-18e6017a3617" class="">前缀和+二分</h3><p id="bd6fde4d-1bca-4511-abae-22507847f914" class="">用前缀和数组来记录当前下标之前的所有元素的和。</p><p id="e0d4cfaa-5601-46f7-8762-ace8f8474f46" class="">因为题目规定所有元素大于0，所以前缀和数组是单调增的，可以用二分查找。</p><p id="e8f384ec-c71e-4874-9635-f21c3ade20ce" class="">时间复杂度：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p><pre id="e4185333-2dbd-4f3b-8aa6-0dd3317e060f" class="code"><code>class Solution {
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; prefix(n+1,0);
        int minlen = INT_MAX;
        for (int i=0; i&lt;n; ++i){
            prefix[i+1] = prefix[i] + nums[i];
        }
        for (int i=1; i&lt;=n; ++i){
            int tar = target + prefix[i-1];
            int lower = bisearch(prefix,i,n+1,tar);
            int len = lower==-1 ? minlen : lower-i+1;
            minlen = min(len, minlen);
        }
        return minlen==INT_MAX ? 0 : minlen;
    }
    int bisearch(vector&lt;int&gt;&amp; nums, int l, int r, int target){
        int end = r;
        while (l &lt; r){
            int m = l + (r - l)/2;
            if (nums[m] &gt;= target){
                r = m;
            }
            else{
                l = m + 1;
            }
        }
        return (l&lt;end &amp;&amp; nums[l] &gt;= target) ? l : -1;
    }
};</code></pre><h3 id="a36464b5-ed97-4424-a539-ed98071e985c" class="">滑动窗口</h3><pre id="aed620c4-58b4-4420-bce1-c5b187638f0e" class="code"><code>class Solution {
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int l = 0;
        int r = 0;
        int sums = 0;
        int minlen = INT_MAX;
        while (r &lt; n){
            while (r&lt;n &amp;&amp; sums&lt;target){
                sums += nums[r];
                ++r;
            }
            while (l&lt;r &amp;&amp; sums&gt;=target){
                sums -= nums[l];
                ++l;
            }
            int len = r-l+1&gt;n ? INT_MAX : r-l+1;
            minlen = min(minlen, len);
        }
        return minlen==INT_MAX ? 0 : minlen;
    }
};</code></pre><p id="778d1a6c-851b-4851-b978-f5800fe32d2d" class="">
</p><p id="fe285b0e-1795-4a94-a6e8-297df5baacbd" class="">
</p><h2 id="bd7fecb6-278e-47f3-9d4d-e562c6560804" class="">数组中的逆序对</h2><h3 id="29e77ed8-e37c-4629-a3e9-9f9a199656ed" class="">暴力——超时</h3><h3 id="1c6cc0cb-e86e-4a8a-84ba-d0bb205191e8" class="">分治（类似于归并排序）</h3><p id="f5c449dc-1cb3-4727-9067-e83b1992e507" class="">每次返回时的逆序对个数为「左边的个数+右边的个数+cross的个数」。</p><pre id="050b44d1-88a9-46ed-8149-ae23564f43a1" class="code"><code>class Solution {
public:
    vector&lt;int&gt; tmp;
    int reversePairs(vector&lt;int&gt;&amp; nums) {
        tmp.resize(nums.size(),0);
        return merge(nums,0,nums.size()-1);
    }
    int merge(vector&lt;int&gt;&amp; nums, int l, int r){
        if (l&gt;=r){
            return 0;
        }
        int m = (l+r)/2;
        int leftpairs = merge(nums,l,m);
        int rightpairs = merge(nums,m+1,r);

        int crosspairs = 0;
        int lptr = l, rptr = m+1;
        int pos = l;
        while (lptr&lt;=m &amp;&amp; rptr&lt;=r){
            if (nums[lptr]&gt;nums[rptr]){
                tmp[pos++] = nums[rptr];
                rptr++;
            }
            else{
                tmp[pos++] = nums[lptr];
                crosspairs += rptr-1-m;
                lptr++;
            }
        }
        for (int i=lptr; i&lt;=m; ++i){
            tmp[pos++] = nums[i];
            crosspairs += rptr-1-m;
        }
        for (int j=rptr; j&lt;=r; ++j){
            tmp[pos++] = nums[j];
        }
        for (int i=l; i&lt;=r; ++i){
            nums[i] = tmp[i];
        }
        return leftpairs+rightpairs+crosspairs;
    }
};</code></pre><p id="c09e50cb-d120-41f5-9ea2-b8d831b7e1ba" class="">
</p><p id="b90e216a-95f5-49cd-9228-7024fe5a22b2" class="">
</p><p id="85f46229-5498-417a-af63-82f4373c2296" class="">
</p><h2 id="466912e5-f69a-4a88-a90a-96ef2b23ef52" class="">计算器1（+-*/无括号）</h2><p id="41947a50-915c-47f0-9766-904b56695483" class="">
</p><h2 id="ab9f18f4-f1e9-4667-8dbc-51f220f929a5" class="">计算器2（+-括号）</h2><h3 id="09e20f04-14fe-4ab7-8d15-9a065ebc7736" class="">括号击穿</h3><p id="2919b905-ba18-4a9d-9028-2e7758aec8da" class="">因为是有+-号，所以可以用这种方法边遍历边算。</p><p id="7decdd46-868a-4ef1-ba4f-9bb5268e3647" class="">用一个栈保存「当前括号范围，之前」，的符号正负。如果当前符号是+，则 <code>sign=ops.top()</code> ；如果当前符号是-，则 <code>sign=-ops.top()</code> 。</p><h3 id="12dc75df-1b53-4345-821a-00d7db9d3e83" class="">双栈</h3><p id="19a5d63f-291a-4fd2-b814-de6b4e7e72a8" class="">还没实现</p><p id="784da446-d7b2-47ff-9744-bcc17d157a55" class="">
</p><p id="e7428a80-6b19-41cd-9912-681b9b2c0c6f" class="">注意点：</p><ol id="a1613cfa-6e04-4fee-875e-589057c95654" class="numbered-list" start="1"><li>根据字符串算数字的时候， <code>num = 10*num+(s[i]-&#x27;0&#x27;)</code> ，一定要加上括号，防止溢出。</li></ol><ol id="d1d1fdff-2ff3-4d67-99bf-8fd986fe821a" class="numbered-list" start="2"><li>计算器的问题，读完一个数字就push，不要等读到别的符号再push</li></ol><ol id="e159679f-bceb-44d6-961c-261088e9e315" class="numbered-list" start="3"><li>计算器2的难点在于 <code>- (3 + (4 + 5))</code> 的情况，所以不能像1一样，preSign==&#x27;-&#x27;就把相反数入栈</li></ol><p id="0a4fad17-abb3-4f47-b1ed-811151d7dc63" class="">
</p><p id="8b81aaa5-e16d-4bf5-8b06-d30da4dadc23" class="">
</p><p id="518df121-258b-4004-9ec4-f65d9f613e1e" class="">
</p><h2 id="5cdf72c6-e541-4646-8a55-1dcb78c650d0" class="">寻找重复数</h2><p id="3fa6ac2e-6f09-4cba-8a42-0555c5875677" class="">n+1长度的数组中有的数在1～n之间，其中有一个数出现次数大于1次，找出这个数。</p><h3 id="1dbc3bda-7222-4067-a736-dbd101e6e2df" class="">二分查找</h3><p id="db77fc95-2839-4879-8642-c2c5e36f66df" class="">不是在数组中查找（因为无序），而是在1～n之间查找</p><pre id="9572c455-29f0-4012-aa22-89906ae43dc2" class="code"><code>class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int n = nums.size()-1;
        int l = 1;
        int r = n;
        while (l&lt;r){
            int m = (l+r)&gt;&gt;1;
            int count = 0;
            for (int i=0; i&lt;n+1; ++i){
                if (nums[i]&lt;=m){
                    count++;
                }
            }
            if (count&lt;=m){
                l = m+1;
            }
            else{
                r = m;
            }
        }
        return l;
    }
};</code></pre><h3 id="07c60f7e-5080-493f-91d3-71c26ee07180" class="">快慢指针（Floyd判圈）</h3><pre id="07759eb9-ac7e-4472-83dd-c68dd2009161" class="code"><code>class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int slow = 0;
        int fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow!=fast);
        
        slow = 0;
        while (slow!=fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};</code></pre><h3 id="8f1e909f-4c37-40f0-a0c9-0a82b649669d" class="">二进制展开</h3><p id="e9261924-969e-46e1-919f-3a0a184b0f32" class="">跟方法一有点像，但是是判断每一位bit，为1的有多少个元素，如果&gt;1～n该位为1的数量，说明该位是多次出现的数中的某一个1位。</p><p id="2a349c92-a387-4d79-bb89-7ef53ef509f6" class="">
</p><p id="1ca1ac6e-65e1-4c14-a798-ecd772486803" class="">
</p><h2 id="7fc4c474-4165-40e0-886f-016931fd03b0" class="">鸡蛋掉落</h2><h3 id="33a44642-45a1-48ee-8602-a166bdb1a8b4" class="">动态规划+二分</h3><p id="19ae8027-d122-43a9-8ba9-ff8ecfc8ddef" class="">纯动态规划会超时，可以利用函数的单调性，不用遍历地寻找min(1≤x≤n){max{dp1,dp2}}，可以二分地寻找。</p><pre id="6b1260a8-8ed0-4d30-926b-2b95664dcef7" class="code"><code>class Solution {
public:
    int superEggDrop(int k, int n) {
        vector&lt;vector&lt;int&gt;&gt; dp(k+1,vector&lt;int&gt;(n+1,0));
        for (int i=1; i&lt;=k; ++i){
            dp[i][1] = 1;
        }
        for (int i=1; i&lt;=n; ++i){
            dp[1][i] = i;
        }
        for (int negg=2; negg&lt;=k; ++negg){
            for (int nfl=2; nfl&lt;=n; ++nfl){
                int minop = 0;
                int l = 1, r = nfl;
                while (l&lt;r){
                    int mid = (l+r)/2;
                    if (dp[negg-1][mid-1] &lt; dp[negg][nfl-mid]){
                        // minop = dp[negg][nfl-mid];
                        l = mid+1;
                    }
                    else{
                        // minop = dp[negg-1][mid-1];
                        r = mid;
                    }
                }
                dp[negg][nfl] = 1+max(dp[negg-1][l-1], dp[negg][nfl-l]); //l不一定是答案，因为两条线可能交点不是整数
            }
        }
        return dp[k][n];
    }
};
</code></pre><h3 id="124a2030-1690-43b3-8650-c543328558a5" class="">另一种动态规划</h3><p id="1e5a0fd2-f607-40ea-a2ed-c261e3f4dd5f" class="">dp[k][t]表示有k个鸡蛋，进行t次操作，最多能测出多高的楼层。</p><p id="bb27f01f-6e96-4f46-9eb5-2f13b7e368ac" class="">我们可以把这个鸡蛋扔在dp[k-1][t-1]+1层上，如果碎了，可以测出无限层，如果没碎，可以测出1+dp[k-1][t-1]+dp[k][t-1]层。</p><pre id="c6541fe7-6ea4-4581-b1ce-32c76817e022" class="code"><code>class Solution {
public:
    int superEggDrop(int k, int n) {
        vector&lt;vector&lt;int&gt;&gt; dp(k+1,vector&lt;int&gt;(n+1,0));
        for (int j=1; j&lt;=n; ++j){
            for (int i=1; i&lt;=k; ++i){
                dp[i][j] = 1+dp[i-1][j-1]+dp[i][j-1];
                if (dp[i][j]&gt;=n){
                    return j;
                }
            }
        }
        return n;
    }
};</code></pre><p id="043105e0-0ab0-4367-a140-6b7dbd2a50ed" class="">
</p><p id="5f29cf2c-3948-4986-bebf-beed221032d5" class="">
</p><p id="3c74f9b3-9c3b-4a62-9fa1-4d49cb101dfd" class="">
</p><h2 id="3abdb547-3888-410c-bfd1-d177173de897" class="">字符串转整数问题、越界问题</h2><p id="890b50d7-7566-48fa-a3ad-795a1d146fad" class="">要注意判断是否越界</p><p id="02e060b2-ebed-42e4-bd3f-74129155d3df" class="">判断方法：</p><pre id="8697b8c8-1441-47a9-a29c-a1e442a8dc45" class="code code-wrap"><code>if (positive &amp;&amp; (result&gt;INT_MAX/10 || (result==INT_MAX/10 &amp;&amp; num&gt;=INT_MAX%10))){
		return INT_MAX;
}
if (!positive &amp;&amp; (result&gt;INT_MAX/10 || (result==INT_MAX/10 &amp;&amp; num&gt;=INT_MAX%10+1))){
		return INT_MIN;
}
</code></pre><p id="7db7eb69-1788-4a00-9722-1826bec9eee8" class="">注意INT_MIN比INT_MAX的绝对值大一，所以不能用同一个判断，并且&gt;=的等号是必须的，不然如果相等没有返回，就加上去了，那虽然负数没有越界，但是正数越界了。</p><p id="c02b0291-f653-47c2-940c-7e36e165d61f" class="">
</p><p id="f9acd51d-f299-489b-b408-84ebea58e503" class="">有的时候，负数不需要转成正数来判断</p><pre id="ee09c094-72df-4267-a94d-e67b15bb9652" class="code"><code>if (y &gt; INT_MAX / 10 || (y == INT_MAX / 10 &amp;&amp; (*iter) &gt; (INT_MAX % 10)))
		return 0;
if (y &lt; INT_MIN / 10 || (y == INT_MIN / 10 &amp;&amp; (*iter) &lt; (INT_MIN % 10)))
		return 0;</code></pre><p id="35e561e5-cfa4-4f7a-950b-8484dd3157d6" class="">
</p><h2 id="7a507f7b-f82e-48a8-9834-b30acafd4ca7" class="">下一个排列和上一个排列</h2><h3 id="48921b95-e0f3-4312-ae3d-86edeb6d5405" class="">下一个排列的算法步骤：</h3><ol id="386e3381-8ec6-44ad-aa49-b38530abdcee" class="numbered-list" start="1"><li>从后往前找到第一个非降序的转折点，即第一个nums[i]&lt;nums[i+1],
i+1即转折点，我们要把位置i换成后面的某一个数</li></ol><ol id="ff8e1535-79be-40a8-b248-e9ceabbe6bb3" class="numbered-list" start="2"><li>从后往前找到第一个比nums[i]大的数，此数坐标为j</li></ol><ol id="fab32b17-2bc5-45e2-a26d-cd62b2fb44de" class="numbered-list" start="3"><li>交换nums[i]和nums[j]</li></ol><ol id="6ef94be5-01b3-455d-877d-b204fefa64f7" class="numbered-list" start="4"><li>将i+1到尾的数逆转（因为经过上述步骤可以证明后面这段是降序的，
要把它变成升序）</li></ol><h3 id="c141c47a-c301-49c0-bac1-2f496232b657" class="">上一个排列的算法步骤：——其实是上面的逆过程</h3><ol id="f7e462fe-4d4d-48c4-a7c2-934e2b2fb24b" class="numbered-list" start="1"><li>从后往前找到第一个非升序的转折点，即第一个nums[i]&gt;nums[i+1]，
i+1即转折点</li></ol><ol id="bfd159d0-9c31-471a-b0bc-a51947ce1e56" class="numbered-list" start="2"><li>将i+1到尾的数逆转，变成降序</li></ol><ol id="39ea8f77-f699-404f-850e-fb7b7848d681" class="numbered-list" start="3"><li>从i+1往后找到第一个比nums[i]小的数，此数坐标为j</li></ol><ol id="2b4ea9bc-5255-4c9b-a523-7d473eda4540" class="numbered-list" start="4"><li>交换nums[i]和nums[j]</li></ol></div></article></body></html>