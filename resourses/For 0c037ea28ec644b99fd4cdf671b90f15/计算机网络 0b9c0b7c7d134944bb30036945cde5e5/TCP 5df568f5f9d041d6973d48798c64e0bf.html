<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>TCP</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="5df568f5-f9d0-41d6-973d-48798c64e0bf" class="page sans"><header><h1 class="page-title">TCP</h1></header><div class="page-body"><hr id="a3932c83-d872-4ce4-a3da-9c294a981904"/><p id="727cb7a9-b171-44ce-983d-f1f17590cd77" class="">
</p><nav id="7923c6ac-a114-429c-899a-39e5c5b42ffb" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#993660ff-7bd6-44a9-9d66-e6f752213ebe">TCP作用</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#c9bf0d0c-8de2-40ad-8b4a-57a6a49ba033">TCP头部</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#057246a1-9029-42cf-904c-6cef7338a807">TCP三次握手</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#17a75677-f83f-42c5-8cdf-e2dcea6ccdfb">TCP四次挥手</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0e07a04b-a4eb-4c88-ac31-7b7d9a1d12ff">TCP和UDP</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a5af0df5-2613-47be-94c6-1aca0b4d1ad1">重传机制</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e13f69ff-6125-44d5-a15e-f7200d7416a7">滑动窗口</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b5a5afd8-a6ec-413b-934b-f7c50a94cff7">流量控制</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e0c3e5fd-d1ca-4681-af3a-f74fb02b7f66">拥塞控制</a></div></nav><h2 id="993660ff-7bd6-44a9-9d66-e6f752213ebe" class="">TCP作用</h2><p id="848b5d16-e16f-4121-91cc-ac785807712e" class="">IP 层是「不可靠」的，它不保证⽹络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p id="3a9f6cc0-0bf3-4835-b4a2-f33ae8421711" class="block-color-blue">TCP是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输服务，能确保接收端接受的网络包是<strong>无损坏、无间隔、非冗余和按序</strong>的。</p><p id="015e3fa1-aeb2-4e0a-8e26-62c7422b62fc" class="block-color-red">是<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流</strong>的传输层通信协议。</p><p id="ddc8cd45-6460-4ef6-a5cf-082c5ac782aa" class="">一个「四元组」可以确定一个TCP连接，即源IP、源端口、目的IP、目的端口。</p><p id="907290ea-b074-4cde-b485-4fb9079dff98" class="">
</p><h2 id="c9bf0d0c-8de2-40ad-8b4a-57a6a49ba033" class="">TCP头部</h2><figure id="e1059582-7863-4549-b5ba-311992724a9f" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled.png"><img style="width:1236px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled.png"/></a></figure><p id="9be78301-f449-4d04-b344-007e56f90f2a" class="">序列号：解决网络包乱序的问题。</p><p id="926ee9d4-a426-4fc5-b28f-65bf8670500c" class="">确认应答号：解决丢包问题。（放下一次期望收到的数据的序列号，发送端收到确认应答之后认为这个序号之前的数据都已经被正常接收）</p><p id="78f665b2-1031-4034-9a3c-d0a171d167d6" class="">控制位：</p><ul id="1ef91dc5-c061-42a0-86b6-17292c0a5fae" class="bulleted-list"><li>ACK：规定除最初建立连接时的SYN包，之外该位必须为1。</li></ul><ul id="41bdc915-4cf4-4041-8ee8-4e038ab02845" class="bulleted-list"><li>RST：连接中出现异常必须强制断开连接。</li></ul><ul id="14deec0e-d6f9-4685-825b-ae386d2492ce" class="bulleted-list"><li>SYN：希望建立连接。</li></ul><ul id="16ed6e60-3af5-41d9-a0ff-d896804ad883" class="bulleted-list"><li>FIN：希望断开连接。</li></ul><p id="76e8c3a2-cc29-4d7a-bd2e-14815e010bba" class="">
</p><p id="209d3f07-13bc-46e3-9823-852c8ef12007" class="">理论上，一个服务器的某个端口上监听，可以的TCP最大连接数是客户端的IP数*客户端的端口数，对于IPv4，为<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>。但是实际要收到<strong>文件描述符数目限制</strong>，和<strong>内存限制</strong>。</p><p id="14c3599f-500b-4ea8-8831-8d6c7a401c7e" class="">
</p><p id="984001ca-dc3c-4069-870a-e18eb5527d24" class="">
</p><h2 id="057246a1-9029-42cf-904c-6cef7338a807" class="">TCP三次握手</h2><p id="4f2368fb-5c9b-47b8-9a2b-88c141522c39" class="">三次握手</p><figure id="de3d616d-fe52-423c-86c5-2fb0568072f0" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%201.png"><img style="width:1236px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%201.png"/></a></figure><ul id="7e08fc62-c59f-4825-a983-34284b5eb0de" class="bulleted-list"><li>服务端主动监听某个端口。进入<mark class="highlight-purple"><strong>LISTEN</strong></mark>状态。</li></ul><ul id="b8d369bc-f04e-42e0-9f04-29941085bf66" class="bulleted-list"><li>客户端发送SYN报文：随机初始化序号（client_isn），置于首部的「序号」字段中，同时SYN标志位置为1。进入<strong><mark class="highlight-orange">SYS_SENT</mark></strong>状态。</li></ul><ul id="aefc0a53-615b-43d4-bc12-b9a41dbe5fa0" class="bulleted-list"><li>服务端收到SYN报文后，回复SYN+ACK报文：随机初始化自己的序号（srver_isn），置于「序号」字段，「确认应答号」为收到的client_isn+1，SYN和ACK标志位置为1。进入<mark class="highlight-purple"><strong>SYN_RCVD</strong></mark>状态。</li></ul><ul id="a3508f5a-9614-4639-8229-d1d6553682c2" class="bulleted-list"><li>客户端收到SYN+ACK报文后，回复ACK报文：ACK置为1，「确认应答号」为server_isn+1。进入<mark class="highlight-orange">ESTABLISHED</mark>状态。<strong>这次报文可以携带数据。</strong></li></ul><ul id="a705efcc-fb5a-4db7-a1d6-5dc9263eef9d" class="bulleted-list"><li>服务端收到ACK后，进入<mark class="highlight-purple"><strong>ESTABLISHED</strong></mark>状态。</li></ul><p id="9f874651-a5b6-4b84-8cf4-72526217b5e8" class="">
</p><div id="0e3de95f-aa4f-44c6-929a-575f8124d8df" class="column-list"><div id="22f5aff2-5b6e-401e-b4e0-631f7c1d1289" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="66bc415f-3245-4954-a9d1-fe1313229e86"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><mark class="highlight-red"><strong>为什么是三次握手？不是两次、四次？</strong></mark></div></figure><p id="891e7730-7f17-4d18-8ed4-8ebaceaba865" class="">
</p></div><div id="a2c871d7-1463-4224-adaa-f5104f8fca5a" style="width:50%" class="column"><ul id="04ac4c4d-d71a-4ec1-9140-c551bd43c602" class="toggle"><li><details open=""><summary>三次握手才可以保证双方具有接收和发送的能力，具体如下：</summary><ul id="65dc4940-6b5d-4cc8-8a91-0e67bf1a08b5" class="bulleted-list"><li><strong>三次握手才可以防止旧的重复连接初始化造成混乱。</strong>例如客户端先发送了一个SYN没有及时收到回复，就又发送了一个SYN。这时希望收到的是新SYN的应答，然而旧的SYN的应答先到来，那就可以根据序列号判断不是想要的，从而告诉服务端中止连接，发送RST报文。</li></ul><ul id="42f235e9-1ebe-48b0-a191-d57333054bec" class="bulleted-list"><li><strong>避免资源浪费。</strong>也是因为上一点写的原因，如果客户端发出的SYN阻塞了，就又发了多个SYN包，服务端收到一个就回复一个并建立一次连接，因为只有两次握手，服务端不知道客户端是否收到ACK并建立连接，从而建立了多个无效连接，造成资源浪费。</li></ul><ul id="47c452ed-9563-4623-9963-4d11a81da1ca" class="bulleted-list"><li><strong>同步双方的初始序列号。</strong>发出去的序列号要收到+1才表示同步，所以要三次。</li></ul></details></li></ul></div></div><div id="53f25397-4233-4e2d-a0e0-2ed318ebdb54" class="column-list"><div id="80dc351b-ea05-4811-aa3f-0819c76d5cac" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="be269c73-b276-43f7-9331-bead413685c6"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">为什么客户端和服务端的初始序列号ISN不同？</div></figure></div><div id="2dd6a8e8-33d9-491e-bee1-f3cb01bf3527" style="width:50%" class="column"><ul id="6d7a5061-ca42-4afe-a13c-14eb3c96ae20" class="toggle"><li><details open=""><summary>两点原因</summary><ul id="27f6a75a-b5fc-4289-af9a-9dda87090b1f" class="bulleted-list"><li>如果旧连接失效并被重用（新连接的ISN与旧连接相同），而网络中仍然存在旧连接的历史报文，但就无法分辨是历史报文还是新报文，造成数据错乱。</li></ul><ul id="51059469-3149-4db1-8f62-febb3b79efdf" class="bulleted-list"><li>提高安全性，可以防止黑客伪造相同序列被对方接收。如果相同的话，黑客只需要偷听到客户端发出的报文，就可以用相同的序列号把自己伪装成服务端。</li></ul></details></li></ul></div></div><p id="0d34a68d-4ce7-4a9f-9199-b61e3b7b67c9" class="">
</p><div id="d8607e43-4f19-4981-a3ed-8ba02997e561" class="column-list"><div id="4d515492-0c54-4ba6-b38f-79840e01fb1f" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="491f4193-c9b3-47ca-b7cc-802e07159d23"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">ISN是怎么随机产生的？</div></figure></div><div id="a133dfa7-3951-4aba-a46c-335996b08db4" style="width:50%" class="column"><ul id="5ec0bd53-bfb7-49ab-a64c-8dfbed88e4cc" class="toggle"><li><details open=""><summary>基于时钟，ISN=M+F。</summary><p id="ccc93b9c-73cf-4aeb-b697-5d1ec009fa62" class="">M是计时器，每4ms加1；F是一个hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数，例如MD5算法。</p></details></li></ul></div></div><div id="848e9f5b-e20f-4519-89de-d8286a89cc10" class="column-list"><div id="e9400ab6-f5b3-4414-8a2d-408822fea5ac" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="4d1e274c-4c9c-44b0-ae2a-1ef288bc9b62"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">为什么TCP层要MSS分片？</div></figure></div><div id="822f2712-75a4-402a-b5bd-e48d755a906a" style="width:50%" class="column"><p id="cf90f039-aa5d-4d86-aa8d-57e676af1430" class="">如果交给IP层分片，那如果一个 IP 分⽚丢失，整个 IP 报文的所有分片都得重传，效率低。所以建立连接时，双方会在报文中协商MSS值。</p></div></div><div id="74721eb3-0fa7-4701-b2bc-8c5859a88256" class="column-list"><div id="6f934f83-e2bd-4143-b55f-adf09a3ba1ff" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="77265a26-4871-4702-bacc-544ee01aaead"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">什么是SYN攻击？如何避免？</div></figure><p id="37b9aeb6-c9e6-4835-94c0-68b717cfd9b9" class="">
</p></div><div id="0ad8cbdf-ae58-493b-805f-c035c4c8ef8a" style="width:50%" class="column"><p id="280f4695-f6a1-4ced-a184-dce22c7c3d64" class="">攻击者伪造不同IP地址的SYN报文，服务端每收到一个SYN报文，就回复，并将其加入SYN接收队列（未连接队列），是服务器不能正常服务。</p><ul id="093c1494-bfa3-4355-b426-d5ce833da9c8" class="toggle"><li><details open=""><summary>两个避免方式</summary><ol id="980c77df-102b-4b09-af37-5ef3fd82d46b" class="numbered-list" start="1"><li>设置Linux内核参数，控制队列大小和当队列满时应做什么处理。</li></ol><ol id="48158219-2c4f-4793-b461-3a02e2acfb1f" class="numbered-list" start="2"><li>当队列满时，启用cookie，而不把后续收到的SYN包加入SYN队列（未连接队列）。</li></ol></details></li></ul></div></div><p id="71f92049-c5b8-4b21-8cc4-c5445dd67de0" class="">
</p><p id="762d348b-de2c-4565-b9d1-08ced91d51c5" class="">
</p><p id="6b400548-cf24-4bb1-8620-fcee0a13456b" class="">
</p><h2 id="17a75677-f83f-42c5-8cdf-e2dcea6ccdfb" class="">TCP四次挥手</h2><p id="d6f13b3e-9fc0-496f-904b-ff0a1c19be76" class="">双方都可以主动断开连接。主动断开连接就说明自己没有数据要发送了，但是还可以接收。</p><figure id="495c4eae-6ca0-405b-9bce-52f302613698" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%202.png"><img style="width:1234px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%202.png"/></a></figure><p id="0185fcad-c311-47c5-90bc-7641db5be219" class="">
</p><p id="6ec60eb4-f32b-49d2-a921-e84cca16b030" class="">每个⽅向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。⚠️ <em>主动关闭连接的，才有TIME_WAIT状态。</em></p><p id="c36a56d9-9fd0-48fd-b502-adbf71cd26e5" class="">
</p><div id="628d8724-3616-4766-ba46-3a34825a6e26" class="column-list"><div id="46cf5095-ac6e-4bc9-aff3-734bac1f2d35" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1e897276-4855-4592-8a7d-46766cedacb2"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">为什么挥手需要四次？</div></figure></div><div id="f891af3e-02bb-4941-8946-afab9679ed72" style="width:50%" class="column"><p id="388885d4-6e49-406c-b90d-79012ff9e862" class="">因为被动关闭的那方可能还有要处理和发送的数据，所以被动方的ACK和FIN一般会分开发送。</p></div></div><div id="f37b462b-cf17-4870-95ba-cfdf62dc9463" class="column-list"><div id="552d7e9f-04d0-4193-bae3-c5fde2da8101" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="fb107010-3e0c-451d-b192-b9a6a8db348c"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">为什么TIME_WAIT的等待时间时2MSL？</div></figure><p id="2a37c599-4299-4de0-bda2-323a8f3c4f01" class="">
</p></div><div id="4c1de475-e13d-4342-ab19-3485114f1ab6" style="width:50%" class="column"><p id="83eb3000-06b8-4668-b363-230250fa7aef" class="">MSL是报文在网络中存在的最长时间，超过这个时间就认为它自然消亡了。</p><p id="66a6b22c-6714-4a66-a375-5659fb86704c" class="">2MSL从客户端收到FIN后开始计时，如果被动方没有收到最后的ACK，从而超时重发FIN报文（一来一回正好2MSL），那主动方会在2MSL内收到重发的FIN报文，又收到了服务端重发的FIN报文，则2MSL时间重新计算。如果2MSL内没有收到重发的FIN，则认为对方已经收到ACK并关闭了。</p><p id="3081ecbd-4394-4bec-9269-4c1e5314366f" class="">Linux内核中一个MSL是30s，2MSL是60s。</p></div></div><div id="6f39a6a2-225d-44e7-97f6-904b52928a19" class="column-list"><div id="8cec8fd4-5082-460f-acd8-efc8f625c2ef" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="565054d1-9e55-4320-8e83-7a2b558dde9a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">为什么需要TIME_WAIT状态？</div></figure><p id="e7941001-b63d-44b0-92d2-5ca4d30c48b0" class="">
</p></div><div id="fde6819f-8fcc-41e2-86d8-fe052b8a7b5e" style="width:50%" class="column"><ol id="e6a7f742-2270-49e4-a59b-15261cc1aada" class="numbered-list" start="1"><li>防止旧连接的数据包。—— 防止延迟的数据包到达新的具有相同「四元组」的目的地。2MSL足以让两个方向上的旧数据包都被丢弃。</li></ol><ol id="8e328de4-65f9-4090-9353-74ca82844046" class="numbered-list" start="2"><li>保证连接正确关闭。</li></ol></div></div><p id="3652ff87-70c7-44e3-8a48-cc4ad202b855" class="">
</p><p id="8f948faf-8b15-43f6-b131-0de8d9f5b1a3" class="">
</p><h2 id="0e07a04b-a4eb-4c88-ac31-7b7d9a1d12ff" class="">TCP和UDP</h2><p id="e8699149-9a3c-433b-bc8f-558517c2bd72" class="">不同：</p><ul id="9c7f9259-bfeb-4f2c-a47e-fcdfa158ff19" class="bulleted-list"><li>TCP要先建立连接，UDP不需要连接。</li></ul><ul id="0cbdcb21-4311-45f7-b87e-68535dc9f2c0" class="bulleted-list"><li>TCP是一对一，UDP可以一对一或一对多或多对多。</li></ul><ul id="cfc15793-5c3f-42e6-8df5-47053a47164b" class="bulleted-list"><li>TCP可靠，UDP不保证可靠。</li></ul><ul id="56750ec7-88f6-4a88-b5f8-a527c21bd5e5" class="bulleted-list"><li>TCP有拥塞控制，UDP没有。</li></ul><ul id="8dfa7d90-cae4-45e3-a230-14ca1a529dea" class="bulleted-list"><li>TCP首部长，UDP只有8字节，且固定不变。</li></ul><ul id="6c58b869-e971-43e1-8f52-fe954f86c098" class="bulleted-list"><li>TCP流式传输，没有边界，UDP一个包一个包，有边界。</li></ul><ul id="d39b6308-94e4-449a-8d0f-6241b66416ad" class="bulleted-list"><li>TCP根据MSS在传输层分片，UDP根据MTU在IP层分片。</li></ul><p id="aaa488bf-d8a2-40c8-b626-9a118377f8a0" class="">应用场景：</p><ul id="4137aef3-4fd0-45fa-aec7-4a94d5433dda" class="bulleted-list"><li>TCP可靠：FTP文件传输、HTTP/HTTPS</li></ul><ul id="8af2f395-fe0c-4bea-ba9b-445f0facd3a1" class="bulleted-list"><li>UDP简单高效：包总量较少的通信（DNS、SNMP等），视频音频等多媒体通信、广播通信。</li></ul><p id="a97b84d1-aeea-43e2-a4f7-47a064485ccd" class="">
</p><p id="025ba8ec-3cf2-4012-90a5-b374b0a3b532" class="">
</p><p id="881cbf19-3689-4837-a768-1dcc953c90eb" class="">TCP的可靠传输</p><p id="a13ba207-ba5b-4bab-ae84-56f5ccda9ed5" class="">如何实现可靠传输的</p><figure id="268dba75-a0c6-47f9-bec5-28360bc51917" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%203.png"><img style="width:1212px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%203.png"/></a></figure><h3 id="a5af0df5-2613-47be-94c6-1aca0b4d1ad1" class="">重传机制</h3><ul id="e008e25f-bc64-4de5-8bb9-25d4e202098c" class="bulleted-list"><li>超时重传<p id="c55a8dc4-7d5e-45a3-b57e-0872610ca4cd" class="">超时重传时间RTO应略大于报文往返RTT（round-trip time）的值。</p><p id="96c1c27b-ed13-4256-8913-a3ef56ce4c44" class="">如何计算动态变化的RTO、RTT？</p><p id="f8a6204d-f8b5-4ff2-826b-2a4375d5a395" class="">每当遇到⼀一次超时重传的时候，都会将下⼀一次超时时间间隔设为先前值的两倍。两次超时，就说 明⽹网络环境差，不不宜频繁反复发送。</p></li></ul><ul id="5409ee26-5e38-48b5-ae09-1861f131c25b" class="bulleted-list"><li>快速重传<p id="e63001d2-4388-452b-a1d8-747b2fa32011" class="">如果接收端没有收到某个报文，会回复需要那个报文的ACK，发送端收到三次之后，就知道某个报文要重传。</p><p id="a62c3fa8-afde-42a9-9d95-955767fb003d" class="">那么是重传那一个还是那个之后的所有呢？</p><p id="bdfeabce-1989-44a1-8a36-979b396749a6" class="">SACK通过在TCP头部的「选项」字段携带接收端的缓存地图，发送端收到三次同样ACK，就会查看选项字段，知道哪段数据要重发。</p><p id="037ea2af-601e-4a6c-b33a-47cfa615c8a7" class="">D-SACK</p></li></ul><h3 id="e13f69ff-6125-44d5-a15e-f7200d7416a7" class="">滑动窗口</h3><p id="9b0de7e6-0569-4f69-80ac-e2fcb692f081" class="">提出动机：每发送⼀个数据，都要进⾏一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这样效率较低。</p><p id="00d80d90-257c-467f-858f-31db287c9598" class="">窗⼝大小就是指<strong>⽆需等待确认应答，⽽可以继续发送数据的最大值</strong>。</p><p id="65451c2a-07cf-4d16-be1f-874973edd2e7" class="">累计确认机制：如果中间某个ACK丢失了，可以通过下一个确认应答知道，对方收到数据了，就不用重发。</p><div id="77eaad22-1237-42c6-8ebf-8401e3cc7bd3" class="column-list"><div id="081ec140-0ff1-43a9-b5b3-4ceaab3d2114" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6ef28313-a2e1-48c0-aefb-0bebbfa1265b"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">窗口大小由谁决定？</div></figure></div><div id="c9dbb5cc-520e-43dd-a582-e3f877daf052" style="width:50%" class="column"><p id="ea191a6d-9f1a-4daa-9762-983019a5a381" class="">TCP头部有个Window字段，接收端用来告诉发送端自己还有多少缓冲区可以接收数据。</p></div></div><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="385f5569-277c-4b77-8aa0-88a822b33a8b"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">程序是如何表示发送窗口（swnd）和接收窗口（rwnd）的？</div></figure><figure id="b114def9-5bf3-46c7-98f1-22f144a4f453" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%204.png"><img style="width:1678px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%204.png"/></a></figure><figure id="12e993e4-0245-48bf-aaff-c080df77dfd1" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%205.png"><img style="width:1676px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%205.png"/></a></figure><p id="818e4bc0-32e5-490f-8b43-99be138a39c7" class="">
</p><h3 id="b5a5afd8-a6ec-413b-934b-f7c50a94cff7" class="">流量控制</h3><p id="ed61db1b-4f1e-4bfe-9c50-37da17f97ed6" class=""><strong><mark class="highlight-red">TCP 提供一种机制可以让「发送⽅」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</mark></strong></p><p id="3ab729e5-b39a-4e25-840e-5aaa63ba603b" class="">如果窗口固定，那么发送端只需要根据自己发</p><p id="2fd86071-25ca-4f99-85dd-044a07523eb3" class="">了多少，应答了多少等判断还可以发多少，而接收端只需要每次收到并回复ack就行了。但是：</p><p id="31380d2e-ce03-4a02-9abe-ca4c709b1b09" class="">发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的。如果接收端的应用不能及时读取，那就要收缩窗口。如果收缩到0，则窗口关闭</p><p id="6aa80fa0-3faf-434c-8c64-67c1ea56780d" class="">糊涂窗口综合症：发送小数据，得不偿失。可以通过让接收端不反馈小窗口、发送端不发送小数据（Nagle算法）来解决。</p><p id="8bbe1215-c556-44fe-be2e-546c382c89ac" class="">
</p><h3 id="e0c3e5fd-d1ca-4681-af3a-f74fb02b7f66" class="">拥塞控制</h3><ul id="4c446774-4684-4787-92d9-e2d452b7dfe1" class="block-color-purple_background bulleted-list"><li>拥塞控制和流量控制的区别：<ul id="98099bf1-d83d-4ec4-958f-4d3640f68071" class="bulleted-list"><li>流量控制是防止发送端的数据填满了<strong>接收端的缓存</strong></li></ul><ul id="ee8186b8-87e2-49a3-ae4b-945fcf758093" class="bulleted-list"><li>拥塞控制是避免发送端的数据填满<strong>整个网络</strong></li></ul></li></ul><ul id="e002733c-d500-446e-a071-540ca6021ff6" class="bulleted-list"><li>拥塞窗口swnd<ul id="a6758b30-7c8e-476f-9b3b-7bd025d66c00" class="bulleted-list"><li><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">swnd=min(cwnd,rwnd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ul><ul id="3e4284cb-60f9-4fa6-b4cc-babfd4511237" class="bulleted-list"><li>变化规则：网络中没有拥塞swnd就增大，有拥塞就减少</li></ul></li></ul><div id="b5e4e282-58ba-44ce-bbb0-6130a1f042ef" class="column-list"><div id="c56d3072-6134-42cb-8d21-ab2765429417" style="width:50%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c2245dbc-d22d-45dd-a646-e0890ab224b6"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">如何判断是否出现拥塞？</div></figure></div><div id="55266be8-e688-47fb-9e76-033f6cf72b8c" style="width:50%" class="column"><p id="be9e51d3-8af9-43e6-bef4-f13cb7d8ee41" class="">如果发送端没有在规定时间内收到ACK，即发生超时重传，就认为网络拥塞了</p></div></div><ul id="8674e273-754a-4883-b83d-37d57a9edb74" class="bulleted-list"><li>拥塞控制算法<ul id="f15dce44-e39a-4df8-8710-448d386557d6" class="bulleted-list"><li>慢启动<p id="be84468c-018f-4b45-aa8b-67142460bab4" class="">当<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd&lt;ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span></span></span></span></span><span>﻿</span></span>时使用慢启动算法。</p><p id="103bd49a-267a-42ac-94d2-72ef4160cf38" class="">当发送方每收到⼀个 ACK，拥塞窗口 cwnd 的⼤小就会加 1。（指数性的增长）</p></li></ul><ul id="7bb50ce5-9ec7-4f6c-81d4-d2f7df0a7c91" class="bulleted-list"><li>拥塞避免<p id="c64f5f0d-5fbe-4710-a50c-867e41bb4d5c" class="">当<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>≥</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd\geq ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span></span></span></span></span><span>﻿</span></span>时，使用拥塞避免算法。</p><p id="f8b4b7f6-2e71-4bcf-a6e6-981cf8f32492" class="">每当收到⼀个 ACK 时，cwnd 增加 1/cwnd。（线性增长）</p></li></ul><ul id="7b2d5682-7e80-4961-accd-099f2d52f296" class="bulleted-list"><li>拥塞发生<p id="8da11a12-013d-4e08-923a-9038db96a391" class="">当发生了重传，认为拥塞发生了。</p><ul id="693527b7-7145-46e5-b3bf-226d91e12cfe" class="bulleted-list"><li>超时重传：接收方发现有包的ACK超时未到达<figure id="e8d38e38-13df-4eea-9df2-bf6b6a7db74b" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%206.png"><img style="width:1232px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%206.png"/></a></figure></li></ul><ul id="42c9b685-ad10-484c-b50c-ac4e1ec9b6e0" class="bulleted-list"><li>快速重传：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不不必等待超时再重传<figure id="94dc55a1-f0f8-4cf7-9c52-ee42ec62f57a" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%207.png"><img style="width:878px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%207.png"/></a></figure></li></ul></li></ul><ul id="3f77369e-9b5a-48c4-a8a9-426e3a901ab9" class="bulleted-list"><li>快速恢复<p id="c1e0eefe-ec9b-4dd0-9a10-43efc4712d8f" class="">？？？</p><figure id="dcd231b4-0aff-4c4d-8a43-3fa2fb0e445b" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%208.png"><img style="width:1382px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled%208.png"/></a></figure></li></ul></li></ul></div></article></body></html>