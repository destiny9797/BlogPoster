<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>传输层</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="33acd229-18cf-4f64-b35a-616ceef394b0" class="page sans"><header><h1 class="page-title">传输层</h1></header><div class="page-body"><hr id="8f7b3f99-30d9-4ce5-8441-988a1c725002"/><p id="18c9308a-124f-4577-9446-6551f794aef4" class="">
</p><p id="7dd985e3-3e79-4f48-bd69-e0614d8356ee" class="">
</p><nav id="9a4685a5-1437-423c-a458-ac1db9cd7256" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3cb904f0-13e1-4824-937f-92423add802f">TCP握手挥手</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b3c2b4d1-c42b-44da-a2c8-4a90e9a06429">⭐️介绍一下TCP三次握手？作用？为什么三次？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b32648e6-adc4-4bb2-bcbc-12bd09ffdadf">⭐️四次挥手？作用？为什么四次？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#37f7f5ef-8a11-47a8-bd0e-bb64ad881d92">⭐️2MSL等待状态？为什么要等待2MSL？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#80a3abc2-5979-4e45-bea4-b6c2276ca84e">三次握手四次挥手的变迁图</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#87b079b2-5f5c-4804-9c4f-e03dc701336f">什么是半连接队列？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#03e0ce7b-dd6c-443d-b60b-645c6b6b746b">ISN（Initial Sequence Number）是固定的吗？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3f549c8a-b9bd-4ab2-a2af-b581062a601d">为什么前两次握手不能携带数据？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ed3f07ed-fa04-4690-9403-0771966358bf">⭐️SYN攻击是什么？如何防御？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0affe715-9066-482f-83d2-80b0c370918d">time_wait发生在什么时候？持续多久？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2dbcc291-4c4e-4149-be26-40201c44e11b">⭐️大量TIME_WAIT什么原因，怎么避免？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e04ba9c3-6689-4f05-a558-c5e5a3aa7678">⭐️大量CLOSE_WAIT什么原因，如何避免？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bd33540a-22d8-4900-9759-bbf37d8184e3">延迟确认是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0c239ebb-9d67-4004-84ff-f763fc635e3c">⭐️tcp粘包、拆包？出现原因？如何避免粘包？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b6f6c8a2-6d3c-42b8-96ec-7673af46bc9b">UDP存在粘包吗？为什么？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#536f2799-4deb-4d97-bade-2e6161075e48">TCP的可靠传输</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7b3eef3c-90a1-4019-a2f5-48cf8ebd406e">⭐️tcp如何保证可靠传输的？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0f8f3966-1f08-4489-a86a-b3b3e851b1c2">⭐️简述TCP滑动窗口和重传机制？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ff266794-c004-44db-996a-7137c733ac74">TCP重传机制</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#87cd0850-9fe6-44ea-b4be-257f9e8d9402">流量控制？——————得看一下</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e955c547-438a-45c8-aa4d-6289d919a359">⭐️拥塞控制？算法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#71c988c2-1df2-4c70-90d6-7fd476e47765">为什么有了快速重传算法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#09f6f619-297e-4f64-ba67-2306ab8a5e2b">为什么快速重传选择的是3次ACK？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#baab5310-bb30-4ca9-a037-2e4fa1518dc6">什么是AIMD？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d1a6df63-baf7-4e78-8992-ee352361e84b">如何区分流量控制和拥塞控制？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7f01556b-f513-40e4-8803-9f4cd77a8e1d">TCP什么情况下会重传？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#dfef3b98-86f0-4f8e-b2d9-42a885ae7e15">什么是超时重传？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#dd20ec9a-dddf-4b20-93cb-44ffa59d42d3">什么是快速重传？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b5b7dd1e-8c0c-4020-975a-bafb177e7f38">RTT、RTO和超时重传分别是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9c05f9dd-1f38-4670-9c7b-62628a69ca7f">如何解决 TCP 传输丢包问题？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#744b934f-0ad1-479f-b7ea-2ce59dd0adab">TCP 如何实现数据有序性？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2d2f462b-45aa-471f-9081-860a581659b3">TCP、UDP</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2169455a-9914-4293-8e1c-9ccd08266de3">UDP是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#06dc1e2e-ad56-4d32-bade-506e1169f8ad">⭐️TCP、UDP 区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2a19dada-8081-4d6c-8476-62a9e7c58a9a">TCP和UDP分别对应的应用层协议？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9e1df3d2-c66c-4859-98da-b483a89e3598">为什么TCP比UDP安全？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#70a89f6e-b294-48cd-9fc4-3bc63ee878f9">知道QUIC吗？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#01257010-7633-411f-bdca-2c3e30e59e5e">⭐️❓如何实现UDP的可靠传输？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#78ec508a-fb37-4ea3-ba48-294d29a8ad52">长短连接</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e02b4e74-4546-47ae-a3fb-55cbb5379014">⭐️TCP长连接和短连接的使用场景？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a8a2a036-1fa8-47a4-9aed-451442aa7ab9">⭐️❓TCP的keepalive是什么？与HTTP的keepalive有什么区别？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ea23e820-99b0-4765-bd82-d1e969c5cab7">其它</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#52df0057-6354-45c5-893e-b0b5ab050455">⭐️简述 TCP 的报文头部结构</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7648ae9c-c737-458f-beaf-399009eeecbb">简述 TCP 协议的延迟 ACK 和累计应答</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6ebfb14a-7754-4cd9-8c49-2af2df0c74cb">延迟确认</a></div></nav><p id="3b45e2e9-2b9e-4d67-b73f-cd7d9527f631" class="">
</p><p id="5c2e0b9a-6bd9-4347-9f86-8b052b75c972" class="">
</p><p id="a7f22e46-50c5-4986-b1ca-7c438864e53e" class="">
</p><h2 id="3cb904f0-13e1-4824-937f-92423add802f" class="">TCP握手挥手</h2><h3 id="b3c2b4d1-c42b-44da-a2c8-4a90e9a06429" class="">⭐️介绍一下TCP三次握手？作用？为什么三次？</h3><p id="af951e4a-7a9f-4a20-864f-2f81ebc3a62c" class=""><strong>三次握手</strong></p><ol id="1515292c-5f6f-4199-af59-4bf9cc6a5745" class="numbered-list" start="1"><li>首先客户端处于CLOSED状态，服务端处于LISTEN状态。</li></ol><ol id="de8c7057-c4bf-478c-89a1-c63eea67cf98" class="numbered-list" start="2"><li><strong>第一次握手</strong>：客户端在请求报文中将<mark class="highlight-purple"><strong>SYN置为1</strong></mark>，并发送序列号为<mark class="highlight-orange"><strong>seq=x</strong></mark>（序列号随机生成），此时不携带数据，客户端进入<mark class="highlight-blue"><strong>SYN-SENT状态</strong></mark>。</li></ol><ol id="36dad0b7-f441-4a98-96f3-955e8621e07a" class="numbered-list" start="3"><li><strong>第二次握手</strong>：服务端收到请求报文后，若同意建立连接，则在确认报文中将<mark class="highlight-purple"><strong>SYN和ACK都置为1</strong></mark>，确认号为<mark class="highlight-teal"><strong>ack=x+1</strong></mark>，也发送自己的序列号<mark class="highlight-orange"><strong>seq=y</strong></mark>。此时也不携带数据，服务端进入<mark class="highlight-blue"><strong>SYN-RCVD状态</strong></mark>。</li></ol><ol id="a90e625c-6032-48cf-8242-25b6b66d838d" class="numbered-list" start="4"><li><strong>第三次握手</strong>：客户端收到服务端的确认后，也要向服务端发送确认。确认报文的<mark class="highlight-purple"><strong>ACK置为1</strong></mark>，确认号为<mark class="highlight-teal"><strong>ack=y+1</strong></mark>，也发送自己的序列号<mark class="highlight-orange"><strong>seq=x+1</strong></mark>。此时双方建立连接，都进入<mark class="highlight-blue"><strong>ESTABLISHED状态</strong></mark>。</li></ol><figure id="75e752cd-0735-431d-9eb5-0f7061d059af" class="image"><a href="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled.png"><img style="width:818px" src="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled.png"/></a></figure><p id="e97eeabe-638c-4f07-bd84-b54f8ceaa029" class=""><strong>作用</strong></p><ul id="100f886d-1757-4852-84bd-0caa9b286b0c" class="bulleted-list"><li>确认双方发送及接收能力正常</li></ul><ul id="6140302b-5e08-4bbb-98dc-ca1a2d1ed157" class="bulleted-list"><li>指定自己的初始化序列号，为后面的可靠传输作准备</li></ul><ul id="43d1ea3b-b6ec-4075-b86f-18011132018f" class="bulleted-list"><li>如果是https协议，三次握手过程中还会进行数字证书的验证</li></ul><p id="8495fae7-8c46-41eb-9f37-bdb4dcf1df04" class=""><mark class="highlight-red"><strong>为什么是三次握手呢？</strong></mark></p><ul id="57baf89c-38c2-416e-bd67-e70250690dd4" class="bulleted-list"><li><strong>三次才可以让双方都知道双方的收发能力都是正常的。</strong>如果两次，服务端就不知道客户端的接收能力是否正常。⬇️</li></ul><ul id="5d54d85d-478c-4429-b141-e266fe21478b" class="bulleted-list"><li><strong>避免资源浪费。</strong>正如上面所说，如果没有确认客户端的接收能力是否正常就建立了连接，那么如果客户端发出的SYN阻塞了，就又发了多个SYN包，服务端收到一个就回复一个并建立一次连接，因为只有两次握手，服务端不知道客户端是否收到ACK并建立连接，从而建立了多个无效连接，造成资源浪费。</li></ul><ul id="7c96dc29-5be7-435c-a84a-330197ef73cc" class="bulleted-list"><li><strong>同步双方的初始序列号。</strong>发出去的序列号要收到+1就表示你和对方讨论的是同一件事。⬇️</li></ul><ul id="e3257c46-77f1-4308-a70d-5032235cb73e" class="bulleted-list"><li><strong>三次握手才可以防止旧的重复连接初始化造成混乱（主要原因）。</strong>例如客户端先发送了一个SYN没有及时收到回复，就又发送了一个SYN。这时希望收到的是新SYN的应答，然而旧的SYN的应答先到来，那就可以根据序列号判断不是想要的，从而告诉服务端中止连接，发送RST报文。</li></ul><p id="4d04cfe1-f995-4437-b0d6-177802f96a04" class="">
</p><h3 id="b32648e6-adc4-4bb2-bcbc-12bd09ffdadf" class="">⭐️四次挥手？作用？为什么四次？</h3><p id="08b2116a-c8cc-4805-b7ae-62de640be209" class="">双方都可以主动断开连接。主动断开连接就说明自己没有数据要发送了，但是还可以接收。这是<strong>半关闭(half-close)</strong>。</p><p id="af72ff96-7beb-435b-9790-d7cbea2f93e5" class=""><strong>四次挥手</strong></p><ol id="83421cdf-0db8-4c54-bf6b-ca6413377b3c" class="numbered-list" start="1"><li>客户端打算关闭连接，发送<strong>连接释放报文段（</strong>TCP报文首部<mark class="highlight-purple"><strong>FIN置为1）</strong></mark>，进入<mark class="highlight-blue"><strong>FIN_WAIT_1状态</strong></mark>。</li></ol><ol id="f18144fa-0ef4-42d3-8ed3-101f7b40f4a2" class="numbered-list" start="2"><li>服务端收到该报文，向客户端发送<strong>确认报文段（</strong><mark class="highlight-purple"><strong>ACK应答报文）</strong></mark>，进入<mark class="highlight-blue"><strong>CLOSED_WAIT状态</strong></mark>，客户端收到后进入<mark class="highlight-blue"><strong>FIN_WAIT_2状态</strong></mark></li></ol><ol id="d9b27df8-20d3-454c-867b-370c397e869d" class="numbered-list" start="3"><li>等待服务端处理完数据后，也向客户端发送<strong>连接释放报文段（</strong><mark class="highlight-purple"><strong>FIN报文）</strong></mark>，并进入<mark class="highlight-blue"><strong>LAST_ACK状态</strong></mark></li></ol><ol id="3410ba5d-ae45-46da-b937-874edbb62c54" class="numbered-list" start="4"><li>客户端收到FIN后，向服务端发送<strong>确认报文段（</strong><mark class="highlight-purple"><strong>ACK应答报文）</strong></mark>，进入<mark class="highlight-blue"><strong>TIME_WAIT状态</strong></mark></li></ol><ol id="1bddb6ba-ce9f-43bc-8a1e-e01bc9e7c839" class="numbered-list" start="5"><li>服务器收到ACK后，关闭连接，进入<mark class="highlight-blue"><strong>CLOSED状态</strong></mark>；客户端等待2MSL时间后，也进入<mark class="highlight-blue"><strong>CLOSED状态</strong></mark></li></ol><figure id="22ad4560-d7c2-43f5-92f8-97901b3d4326" class="image"><a href="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%201.png"><img style="width:792px" src="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%201.png"/></a></figure><p id="0bd26903-d2c7-4606-9889-5b264719a578" class=""><strong>为什么四次？</strong></p><p id="9e7ebaca-b867-4ad7-a62c-0335fb06d58b" class="">主要在于ACK和FIN要分开发送。</p><p id="f5d36580-8918-4ddf-9617-15d84082e4f1" class="">因为发送FIN报文仅代表不再发送数据，但还可以接收。服务端收到FIN报文后，<strong>可能还有数据要处理</strong>，所以ACK报文和FIN报文分开发送。</p><p id="fd5afafc-5ef4-4612-8951-41ee5f0314ab" class="">举个例子：A 和 B 打 电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不 能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答 “知道了”，这样通话才算结束。</p><p id="f64983a7-0db7-4923-b208-8508da50a81e" class="">
</p><h3 id="37f7f5ef-8a11-47a8-bd0e-bb64ad881d92" class="">⭐️2MSL等待状态？为什么要等待2MSL？</h3><p id="7cb85686-aab6-4515-9af7-35c31e949080" class=""><strong>介绍</strong></p><p id="b1fd1af4-ab21-4f1b-a904-7640db7e10c3" class="">TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个<strong>报文段最大生存时间 MSL(Maximum Segment Lifetime)</strong>，<strong><mark class="highlight-red"><span style="border-bottom:0.05em solid">它是任何报文段被丢弃前在网络内的最长时间</span></mark></strong>。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p><p id="9a7ab30a-7a9d-4741-bf22-073e86c557d9" class="">对一个具体实现所给定的MSL值，<strong>处理的原则是</strong>：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失(另一端超时并重发最后的FIN)。</p><p id="310b21f4-186b-4d1e-97d2-5feda10bd92c" class=""><em>注：Linux内核中一个MSL是30s，2MSL是60s。</em></p><p id="2df90847-9b0e-46f4-801c-6fa3a00e86b1" class="">
</p><p id="057ef9db-4777-49aa-a562-509766137531" class=""><strong>等待2MSL的原因：</strong></p><ul id="c5bbaddf-ceb6-4e18-ae0c-ad143d6a0438" class="bulleted-list"><li><strong>保证客户端发送的最后一个ACK报文段能够到达服务端（防止ACK丢失）</strong><p id="99c8d55c-d95e-495c-a284-d2e0c907c729" class="">例如：2MSL从客户端收到FIN后开始计时，如果被动方没有收到最后的ACK，从而超时重发FIN报文（一来一回正好2MSL），那主动方会在2MSL内收到重发的FIN报文，<span style="border-bottom:0.05em solid">又收到了服务端重发的FIN报文，则2MSL时间重新计算</span>。如果2MSL内没有收到重发的FIN，则认为对方已经收到ACK并关闭了。</p></li></ul><ul id="889707a8-997a-4a10-aab0-600300bd9eaa" class="bulleted-list"><li><strong>防止本连接关闭后“已失效的连接请求报文段”出现在下一个连接中</strong><p id="5d2949c7-2931-41aa-bb6c-04e0c95aa029" class="">客户端在发送完最后一个ACK报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</p></li></ul><p id="ad29092f-9aba-4a5a-bfda-86f11e266a61" class="">
</p><h3 id="80a3abc2-5979-4e45-bea4-b6c2276ca84e" class="">三次握手四次挥手的变迁图</h3><figure id="0a69800b-ab5b-4796-8873-ab300c366d92" class="image"><a href="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%202.png"><img style="width:1216px" src="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%202.png"/></a></figure><p id="e3f8a870-a435-4ebd-af84-e66137403a2b" class="">
</p><h3 id="87b079b2-5f5c-4804-9c4f-e03dc701336f" class="">什么是半连接队列？</h3><p id="6ee3c539-3a81-41ab-a08a-edccf6f7a9a1" class="">服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p id="de32ffa0-f867-42f7-95cd-b2e51e5cdc9d" class="">当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：服务器发送完SYN-ACK包，如果未收到客户确认包， 服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规 定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同， 一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......</p><p id="c006f653-8e28-4cfe-acc3-2237b012e997" class="">
</p><h3 id="03e0ce7b-dd6c-443d-b60b-645c6b6b746b" class="">ISN（Initial Sequence Number）是固定的吗？</h3><p id="2fde9b79-e4d3-45e8-b4ab-4d7955ee7da1" class="">是动态生成的。</p><p id="1e3b2ef4-b606-4d4b-a4d4-e8b589408442" class="">当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN<span style="border-bottom:0.05em solid">随时间而变化</span>，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。</p><p id="eec72800-528a-4691-949b-4c8799555941" class=""><strong>动态生成的原因：</strong></p><ul id="f8b9b63d-161e-44ec-9f7c-7a984632fb67" class="bulleted-list"><li>如果旧连接失效并被重用（新连接的ISN与旧连接相同），而网络中仍然存在旧连接的历史报文，但就无法分辨是历史报文还是新报文，造成数据错乱。</li></ul><ul id="64526872-2a46-4652-b760-3c4947c4a99c" class="bulleted-list"><li>提高安全性，可以防止黑客伪造相同序列被对方接收。如果相同的话，黑客只需要偷听到客户端发出的报文，就可以用相同的序列号把自己伪装成服务端。</li></ul><p id="75a673fa-b565-4765-bdc0-fb9209dca90a" class="">
</p><p id="926e92dc-3158-46ff-85e8-c19c45c14b9f" class="">
</p><h3 id="3f549c8a-b9bd-4ab2-a2af-b581062a601d" class="">为什么前两次握手不能携带数据？</h3><p id="58b358b3-4eb0-441d-abc4-d3798d8a1c0e" class="">第一次不可以放数据，因为会让服务器更容易受攻击。</p><p id="e7ff784d-546b-434e-aa8b-a3868018f880" class="">那第二次呢？</p><p id="69ed1795-7fd2-4c55-a447-7dbdafb06f6b" class="">
</p><h3 id="ed3f07ed-fa04-4690-9403-0771966358bf" class="">⭐️SYN攻击是什么？如何防御？</h3><p id="3322da5a-a5e0-4c1d-8de4-7aa2fdec2f88" class=""><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到<strong>SYN洪泛攻击</strong>。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，<strong>这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃</strong>，从而引起网络拥塞甚至系统瘫痪。<strong>SYN 攻击是一种典型的 DoS/DDoS 攻击</strong>。</p><p id="a7249400-b142-4599-a3dc-c6b28b46a61d" class="">检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><pre id="c1538138-b990-49b4-8538-13ffbd154697" class="code"><code>netstat -n -p TCP | grep SYN_RECV</code></pre><p id="e0d378aa-9635-4d61-90e4-a16169149d21" class="">防御方法：</p><ul id="1f4b1621-1172-43d0-ba21-a0ecf76010d1" class="bulleted-list"><li>设置Linux内核参数，控制队列大小和当队列满时应做什么处理<ul id="ad8e1950-9405-45f4-a8fd-c8dfe47459c6" class="bulleted-list"><li>缩短超时时间（SYN Timeout）</li></ul><ul id="84aa538d-f1a8-4697-9a24-104b016f8164" class="bulleted-list"><li>增加最大半连接数</li></ul></li></ul><ul id="e6b78107-8455-4f9c-8791-f4b4dc8f520a" class="bulleted-list"><li>过滤网关防护</li></ul><ul id="ab03854a-7522-4669-9017-730e8cca8566" class="bulleted-list"><li>SYN cookies技术<p id="c245d63f-50e7-4e84-bdd0-586af81ce8d9" class="">当队列满时，启用cookie，而不把后续收到的SYN包加入SYN队列（未连接队列）。</p></li></ul><p id="f3ef5d9c-1aaf-4e67-8fd7-f96b133a13f9" class="">
</p><p id="4429ac30-290a-4371-ad02-a1599a9d2e57" class="">
</p><h3 id="0affe715-9066-482f-83d2-80b0c370918d" class="">time_wait发生在什么时候？持续多久？</h3><p id="93d220a1-1a1d-482f-a18e-ce24558558d2" class="">发生在断开连接时，发起方在收到对方的FIN报文段后，hui fuACK，并进入TIME_WAIT状态，等待2MSL时间后，如果这段时间收到新的FIN，重新发送ACK重新计时，如果超过这段时间没收到对方新的FIN，则CLOSED。</p><p id="9dad157e-b3a9-4d8b-842e-999c96fe7e55" class="">
</p><h3 id="2dbcc291-4c4e-4149-be26-40201c44e11b" class="">⭐️大量TIME_WAIT什么原因，怎么避免？</h3><p id="3b1dc05c-7ec9-4abb-968e-aecef8be663d" class=""><strong>原因：</strong></p><p id="3463a8db-9a29-4ed3-8d27-e4703337e13a" class="">在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p><p id="6acf5d00-8961-469a-b227-7849611eb6e9" class=""><strong>如何避免：</strong></p><pre id="8eb046e0-0ddf-43d1-b914-fda6b1e2108d" class="code"><code>net.ipv4.tcp_syncookies = 1 //表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse = 1 //表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle = 1 //表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。

net.ipv4.tcp_fin_timeout //修改系統默认的 TIMEOUT 时间</code></pre><p id="d15a7f0d-0a3a-42c1-aaf5-8a4e3fe7496e" class="">SYN cookie不仅可以防SYN攻击，还可以避免大量TIME_WAIT啊🤔</p><p id="c6e599ea-7ff3-4e34-8e8c-081ae595ab5c" class="">
</p><h3 id="e04ba9c3-6689-4f05-a558-c5e5a3aa7678" class="">⭐️大量CLOSE_WAIT什么原因，如何避免？</h3><p id="c841e78a-fd4d-42a6-b5b0-0d918c2e30ca" class="">说明服务端不发FIN，可能：</p><ol id="589a4f54-c763-48fd-8e6e-4b5f4506a9bf" class="numbered-list" start="1"><li>服务端在某些异常情况下，忘记closesocket(s) —— 比如收到FIN后，应用程序层面看是抛出了SOCKET_ERROR，抛出SOCKET_ERROR之后忘了closesocket就会处于CLOSE_WAIT</li></ol><ol id="8fe58ae7-d106-4e6f-95bd-ac00d388ebbf" class="numbered-list" start="2"><li>有大量剩余事务、数据要处理</li></ol><ol id="15a893f1-6eb7-4edb-9828-e4cfe8b4a9b7" class="numbered-list" start="3"><li>客户端异常退出，剩余的数据一直发不出去</li></ol><p id="d38a37cb-228a-4585-9aab-b8b045a39220" class="">
</p><p id="d1901ea8-5ef0-4e44-9513-0f9fbba0a2b9" class="">
</p><h3 id="bd33540a-22d8-4900-9759-bbf37d8184e3" class="">延迟确认是什么？</h3><p id="72d3b105-b3aa-4f36-8233-bfe357bc9dc8" class=""><strong>为什么要延迟确认？</strong></p><p id="20458166-1504-4d89-a156-a2b5d4b1bfd8" class="">ACK有40个字节的IP头和TCP头，却没有携带报文。为了解决ACK传输效率低的问题，就有了TCP延迟确认。</p><p id="b1cc60ac-63de-4c85-9a26-10a7294c76a9" class=""><strong>具体实现</strong></p><ol id="0cc96118-f384-45b5-85eb-4855c0dde25b" class="numbered-list" start="1"><li>当有响应数据需要发送时，ACK会随着响应数据一起立刻发送给对方。</li></ol><ol id="8310e60c-acf3-421d-900e-321f471231c2" class="numbered-list" start="2"><li>当没有响应数据需要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li></ol><ol id="cdd32889-bd49-4e8a-b08e-4a9f303bc8ca" class="numbered-list" start="3"><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ol><p id="eda93892-7ba6-49f1-98b4-4d0388073f0c" class="">
</p><h3 id="0c239ebb-9d67-4004-84ff-f763fc635e3c" class="">⭐️tcp粘包、拆包？出现原因？如何避免粘包？</h3><p id="c713178b-97bd-4b75-a9f3-ec34df25679a" class=""><strong>粘包：</strong></p><p id="a332f35e-3dc4-47c6-9e24-0cc448ae47ec" class="">TCP粘包是指发送方发送的若干包到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p id="c4d44c5f-1117-48fc-8e96-7caf9cffed90" class=""><strong>拆包：</strong></p><p id="8fb74332-31c0-4f9d-b1de-e38841a91161" class="">将同一个包拆成了多个读取。</p><p id="c5b9e6e2-e444-4384-9951-c62de9289046" class=""><strong>出现原因：</strong></p><p id="c3bd2f3b-846b-4456-bfcb-de71f7d438f5" class="">接收方原因：TCP是基于连续<strong>字节流的，没有边界，首部没有表示数据长度的字段</strong>。接收方不知道消息的界限，不知道一次提取多少数据。那么程序在读取数据时<strong>不能及时把缓冲区的数据拿出来</strong>，而下一个数据到来并有一部分放入缓冲区末尾，再读取时会发生粘包（放数据的速度&gt;应用层拿数据的速度）。</p><p id="eb8cc5da-3354-4bc0-a32c-04b95a17b55d" class="">发送方原因：TCP协议传输数据时，客户端和服务端经常保持一个长连接的状态，可以一直传输数据，当发送的数据包过小的时候，那么TCP默认启动<strong>Nagle算法，将较小的数据包合并发送</strong>（缓冲区数据发送是一个堆压的过程），也就是说数据发出来已经是一个粘包的状态了。</p><ul id="baf58fb4-e2de-4266-bebf-3ce958b3dd4b" class="bulleted-list"><li>TCP<strong>连接复用</strong></li></ul><ul id="7fa90d72-4897-41fb-a599-9f5893526a2a" class="bulleted-list"><li>TCP默认会使用<strong>Nagle算法</strong>，此算法会导致粘包问题</li></ul><ul id="5b687aa4-4f52-4ab3-9a6e-8ed1a8e5fce0" class="bulleted-list"><li><strong>数据包过大</strong></li></ul><ul id="88b91c0f-4617-4785-b1e9-87a3326ef25d" class="bulleted-list"><li><strong>流量控制，拥塞控制</strong></li></ul><ul id="2800600f-f317-4f3f-b6b1-7d5cefd539a5" class="bulleted-list"><li><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></li></ul><p id="91bcd8a7-01a7-413c-a4b3-4ed9b95fa4e9" class=""><strong>解决方法：</strong></p><ul id="2d1b3fd7-a7a4-4863-bacb-5125ab0fb74b" class="bulleted-list"><li>Nagle算法问题导致的，需要结合应用场景适当<strong>关闭该算法</strong></li></ul><ul id="6e3e00ff-b7c4-45ff-986b-8be9c79a0f9e" class="bulleted-list"><li><strong>尾部标记序列</strong>。通过特殊标识符表示数据包的边界，例如\n\r，\t，或一些隐藏字符（如FTP协议）</li></ul><ul id="0f5162cc-cca3-4a9d-8fda-0df297204a01" class="bulleted-list"><li>头部标记分步接收。在TCP报文的<strong>头部加上表示数据长度</strong></li></ul><ul id="db2d0bd3-6a0f-4022-97cd-ab9a5cc9228f" class="bulleted-list"><li>应用层发送数据时<strong>定长</strong>发送。</li></ul><p id="2f9454c0-7bcb-490a-b3d4-44d80202475d" class="">个人理解：粘包和拆包应该分为发送端和接收端，都是由于缓冲区引起的。</p><p id="6dae0d5f-fd60-48c6-8402-37eb8d1a1931" class="">
</p><p id="0c35e80b-3f69-43dc-b878-2d26b4197f6c" class="">
</p><h3 id="b6f6c8a2-6d3c-42b8-96ec-7673af46bc9b" class="">UDP存在粘包吗？为什么？</h3><p id="cb5c9548-9021-4907-9d98-b14f66df504f" class="">不存在。因为UDP传送数据单位是报文，发送时不合并不拆分。UDP只要是收到的包，都是完全正确的，但存在丢包和乱序。</p><p id="df8f1026-ec98-45b2-af83-f9a0b3fc782e" class="">
</p><p id="af152220-4051-41fc-bff5-d1d4dac0ae41" class="">
</p><p id="36fd7acc-fb5f-4157-aed2-18f479e077ee" class="">
</p><p id="61762e9a-b550-4554-a024-b18408c9d5bf" class="">
</p><h2 id="536f2799-4deb-4d97-bade-2e6161075e48" class="">TCP的可靠传输</h2><h3 id="7b3eef3c-90a1-4019-a2f5-48cf8ebd406e" class="">⭐️tcp如何保证可靠传输的？</h3><ul id="a6d589f6-9c39-4819-b30d-a121bf087e3f" class="bulleted-list"><li><strong>确认和重传</strong><p id="7ab6ab6c-8e1c-4876-8871-81a592c0a93e" class="">接收方收到报文就会发送确认，发送方发送一段时间后没有收到确认就会重传</p></li></ul><ul id="a0628cc4-08e0-4a26-935c-72d9f49d2347" class="bulleted-list"><li><strong>序号机制</strong><p id="7f6c16b3-51ce-44d4-bea7-69576d9d55f4" class="">序号和确认号，确保了数据是按序、完整到达的。</p></li></ul><ul id="5f8b0d8b-dd4e-4d05-a232-89fba6d69b25" class="bulleted-list"><li><strong>数据校验（校验和）</strong><p id="d69262bd-c2bb-48b8-acc6-55086366d559" class="">TCP报文头部有校验和，用于校验报文是否损坏。CRC校验。</p><p id="3aed8b6f-45b7-4e6b-9d88-46304888a3b0" class="">若校验出错误，则丢弃报文段并且不给出响应，发送端会重发数据。</p><p id="8181203e-ba73-4010-b40c-83b9c012fac1" class=""><em>注：这个机制能查出一切错误吗？不能，虽然没查出的可能性很小。——解决方法：传输之前先使用</em><span style="border-bottom:0.05em solid"><em>MD5加密数据获得摘要</em></span><em>，跟数据一起发送到服务端，服务端接收之后对数据也进行 MD5加密，如果加密结果和摘要一致，则认为没有问题</em></p></li></ul><ul id="cf843e00-0372-4278-922c-e749b78dc51f" class="bulleted-list"><li><strong>数据合理分片和排序</strong><p id="97bcfa5d-cde8-479a-99e4-734362da6404" class="">tcp会<strong>按最大传输单元(MTU)合理分片</strong>，接收方会缓存未按序到达的数据， <strong>重新排序</strong>后交给应用层。（TCP报文段作为IP数据报来传输，而IP数据报的到达可能失序，所以TCP会将失序数据重新排序，才交给应用层。）</p><p id="7ff13803-55de-4f3e-98b4-91b8937ff88c" class="">而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，使得每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</p></li></ul><ul id="12ef435d-3c02-45bf-8de8-52cfd4597ccf" class="bulleted-list"><li><strong>流量控制</strong><p id="ee8fa3cb-19ae-4a9e-a756-8d40170ab97f" class="">当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</p></li></ul><ul id="bf8a43c7-338d-4957-8377-b970e4764ce7" class="bulleted-list"><li><strong>拥塞控制</strong><p id="6fd4fb3f-e346-490b-9fd9-6ec60ee9a2e6" class="">当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</p></li></ul><p id="d41a30d4-c296-489d-950d-e5f863988c22" class="">
</p><p id="6476fc84-34a8-473d-9c40-e31dc38d7b5e" class="">
</p><h3 id="0f8f3966-1f08-4489-a86a-b3b3e851b1c2" class="">⭐️简述TCP滑动窗口和重传机制？</h3><p id="e7bfe9fb-9b48-4f3c-b689-64f0a5c5a457" class=""><strong>发送出去的数据流可以被分为以下四部分: 已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为: 已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</strong></p><p id="c7d901d6-baaa-4e44-ad43-0c2eea234c89" class="">TCP是双工通信，每一端要维护一个发送窗口，一个接收窗口，发送窗口内包含的是 已发送并且已收到ack的+未发送但可发送的，接收窗口内是 未接收但准备接收+已接收但失序的（前面有包未收到）。</p><p id="3e64a9cd-299f-4f01-9863-311f384503a1" class="">发送窗口只有在收到发送窗口内字节的ack,才会移动左边界，带着整个窗口一起往右滑，大小是根据收到的对方的接收窗口大小来改变； 接收窗口只有在前面所有字节都收到的情况下才会移动左边界（接收窗口的左边界是第一个没收到的字节）</p><h3 id="ff266794-c004-44db-996a-7137c733ac74" class="">TCP重传机制</h3><p id="ea7427a7-52f9-495a-a752-c7269866a4e5" class="">超时重传</p><p id="d06ebd93-c9e5-4f15-bc46-510ae527d054" class="">快速重传</p><p id="c413d7f2-6e55-4314-935e-03214a334f21" class="">
</p><h3 id="87cd0850-9fe6-44ea-b4be-257f9e8d9402" class="">流量控制？——————得看一下</h3><p id="c50371bc-67f1-45ea-ab04-c05aabd6c571" class="">目的：控制发送方的发送速率，保证接收方来得及接收。（接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。）属于<strong>点对点控制</strong>。</p><p id="735077e7-f521-4e31-84c9-f3f0c74e6489" class="">工具：滑动窗口</p><p id="52cb82c5-e23c-4a9b-bce3-9e004dbbcc46" class="">滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。</p><p id="4bd1b655-3d6b-460c-b157-499c14158219" class="">当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报 来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><p id="34141b9a-baf1-40bd-b8bc-d285a8499304" class="">发送方接收方各自维护一个发送窗和接收窗</p><ul id="6a84c9d8-0468-41a7-8adf-9e44a5c0f2b4" class="bulleted-list"><li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲(受系统、硬件等限制) 大小。</li></ul><ul id="6fe3cfc4-0bc3-42d9-bfda-d50becb6d34d" class="bulleted-list"><li>接收窗：用来标记可以接收的数据大小</li></ul><p id="1e0ffd84-b6f7-4fa7-a460-f041aaf7d381" class="">
</p><p id="0bfcf5cc-d9f2-4a40-92ab-3e25e479a50f" class="">TCP是流数据，<strong>发送出去的数据流可以被分为以下四部分: 已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为: 已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</strong></p><p id="9be71e20-330f-4ffe-b5b6-ebd463837708" class="">发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</p><p id="3f96ff33-ab8f-4717-8f93-90d02788500e" class="">
</p><p id="4614b46f-2635-4876-a583-38e7110e74be" class="">
</p><h3 id="e955c547-438a-45c8-aa4d-6289d919a359" class="">⭐️拥塞控制？算法？</h3><p id="5e2ea02a-ddb1-40dd-8cf3-ae11218ea3d6" class=""><strong>目的</strong>：防止数据被过多注网络中导致网络资源(路由器、交换机等)过载。属于<strong>全局控制</strong>。</p><p id="6ffb5af6-3a3c-41b7-bf7c-2d43c1d176d3" class=""><strong>工具</strong>：拥塞窗口cwnd</p><ul id="dedf1b97-42fd-467a-8944-68875e603d1c" class="bulleted-list"><li><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">swnd=min(cwnd,rwnd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ul><ul id="e102269c-68bf-475f-b59c-981c01a88d9f" class="bulleted-list"><li>变化规则：网络中没有拥塞cwnd就增大，有拥塞就减少</li></ul><p id="09ea6f12-c251-4126-84e4-f1cb7ca01f97" class="">
</p><p id="4d666025-aa2b-48c3-a06e-cc58897851dc" class=""><strong>拥塞控制算法</strong>：</p><ul id="9fadd4d3-5437-466a-adc4-211ec3170d3a" class="bulleted-list"><li><strong>慢启动</strong> —— 当<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd&lt;ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span></span></span></span></span><span>﻿</span></span>时使用慢启动算法<ol id="b08045bc-c21a-4c2b-bbba-10bcc5185678" class="numbered-list" start="1"><li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li></ol><ol id="f38409b4-01ee-4899-843e-93aa796a28a7" class="numbered-list" start="2"><li>每收到⼀个 ACK，拥塞窗口 cwnd 的⼤小就会加 1。（指数性的增长）<p id="9ce290e4-1db2-4900-9038-dca8387ec239" class="">即每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2。</p></li></ol><ol id="5345aeb5-6ae8-458b-98d2-59d08b7c3fde" class="numbered-list" start="3"><li>还有一个ssthresh(slow start threshold)，是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”(后面会说这个算法)</li></ol></li></ul><ul id="188531bc-d6f5-4c0f-8800-b8bd9324bd1e" class="bulleted-list"><li><strong>拥塞避免</strong> —— 当<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>≥</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd\geq ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span></span></span></span></span><span>﻿</span></span>时，使用拥塞避免算法<p id="63956774-0057-4626-8a58-a3946fa3201d" class="">每当收到⼀个 ACK 时，cwnd 增加 1/cwnd。（线性增长）</p><p id="0dbdcbcc-bf9c-45fc-8ee5-89b89713e6e9" class="">即每当过了一个往返延迟时间RTT，cwnd大小加一。</p></li></ul><ul id="a955ef09-5a88-4787-b3b7-f04842f29d24" class="bulleted-list"><li><strong>拥塞发生</strong><p id="af878999-c44d-41df-9220-6db3323c2b02" class="">如何判断是否出现拥塞？ </p><p id="93159d20-8d1c-46e5-9259-03ce9bb86de4" class="">TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以<strong>丢包</strong>为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是<strong>超时重传</strong>RTO[Retransmission Timeout]超时，另一个是收到<strong>三个重复确认ACK</strong>。</p><ul id="e5ca171e-1852-4c72-9a82-53f2ee092205" class="bulleted-list"><li><strong>超时重传的处理方式 —— 这种情况拥塞比较严重</strong><ol id="cf38bbe2-f427-4ef9-8a58-1541bd7b210d" class="numbered-list" start="1"><li>将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2</li></ol><ol id="28120f0b-34fb-4d07-9be7-21ec51a56d2c" class="numbered-list" start="2"><li>cwnd重置为1</li></ol><ol id="f899b268-e339-41e1-801c-1f758d386699" class="numbered-list" start="3"><li>进入慢启动过程</li></ol></li></ul><ul id="4d3749e9-e2b2-431b-bc54-8ec5766fd591" class="bulleted-list"><li><strong>三个重复确认ACK的处理方式（快速重传） —— 这种情况拥塞不严重</strong><ol id="b2d968ad-ead4-47e3-9c54-688fff94abe8" class="numbered-list" start="1"><li>cwnd大小缩小为当前的一半</li></ol><ol id="5c075865-6570-415e-bebd-3c6011018908" class="numbered-list" start="2"><li>ssthresh设置为缩小后的cwnd大小</li></ol><ol id="74af99c0-4219-49cd-be41-3166cc871eae" class="numbered-list" start="3"><li>进入快速恢复算法Fast Recovery</li></ol></li></ul></li></ul><ul id="20b32099-9411-481a-b509-8bb35a791645" class="bulleted-list"><li><strong>快速恢复 （相当于先慢启动，重传成功了就拥塞避免？）</strong><p id="b0c543bf-b430-46bc-8af8-cb824c482bd9" class="">在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。</p><ol id="25ec8562-b084-476a-bc79-2eca260e58ab" class="numbered-list" start="1"><li>cwnd = cwnd + 3 MSS，加3 MSS的原因是因为收到3个重复的ACK。（相当于慢启动？）</li></ol><ol id="ef0ee34e-ce5c-4839-9470-93a9bbb8ca9d" class="numbered-list" start="2"><li>重传DACKs指定的数据包</li></ol><ol id="e941e638-b337-4353-89a9-2fb711ef58d7" class="numbered-list" start="3"><li>如果再收到DACKs，那么cwnd大小增加一</li></ol><ol id="97f6c976-b327-431b-895a-37a74ffe32c5" class="numbered-list" start="4"><li>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法</li></ol><figure id="ce6e45b9-d5b0-45c0-b689-dec093bb7f7a" class="image"><a href="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%203.png"><img style="width:480px" src="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%203.png"/></a></figure></li></ul><p id="9535c00b-82cc-45bf-8ae0-ee6aa67accfc" class="">
</p><h3 id="71c988c2-1df2-4c70-90d6-7fd476e47765" class="">为什么有了快速重传算法？</h3><p id="07f459cf-e2c9-41f7-a505-984bcad9b62e" class="">丢包的原因有：</p><ol id="7a281612-ec1c-43fd-8962-789c0851097b" class="numbered-list" start="1"><li>包checksum出错，校验和出错？</li></ol><ol id="ad5d8631-fe91-41bf-9f9d-536bfc787383" class="numbered-list" start="2"><li>网络拥塞</li></ol><ol id="73e12cb1-9756-48f2-aedd-3980280de37e" class="numbered-list" start="3"><li>网络断</li></ol><p id="edaa7fb1-f262-4426-8678-0fcc024fc17e" class="">前两种情况，如果是2，应该让窗口减半，但如果是1，偶然的出错就减半不合理。所以有了快速重传算法。</p><p id="5930888c-9a6d-424c-8cb2-1cf445355856" class="">
</p><h3 id="09f6f619-297e-4f64-ba67-2306ab8a5e2b" class="">为什么快速重传选择的是3次ACK？</h3><p id="8c47413b-79bc-4995-9c68-7f9748cf291e" class="">主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p><p id="d73d0ea3-d555-44da-899e-e5c769fb8fba" class=""><strong>两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！</strong>四次 duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK！综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p><p id="6fe0ada4-fe94-4f60-960e-f1a1fae750fa" class="">如果收到ACK，说明不是第3种情况。如果在timeout时间内没有收到&gt;2的duplicated ACK，则大概率为乱序，不需重传。如果收到了三个或以上duplicated ACK，大概率是丢包，先不降速，重传一次，如果接收到到正确的ACK，则一切OK，流速依然。</p><p id="7bd37d96-467b-45fc-a09e-e6e8f0a7b3ed" class="">
</p><h3 id="baab5310-bb30-4ca9-a037-2e4fa1518dc6" class="">什么是AIMD？</h3><p id="3937d809-340d-4e52-8199-535ba2f83fae" class="">加性增、乘性减（Additive-Increase， Multiplicative-Decrease, AIMD）。是TCP的拥塞控制方式。</p><p id="17c221ea-bedd-4756-a173-8b8404430cb2" class="">
</p><h3 id="d1a6df63-baf7-4e78-8992-ee352361e84b" class="">如何区分流量控制和拥塞控制？</h3><p id="22c08a1c-e6cf-4edd-9243-06242c209887" class="">区别：</p><ul id="5a8ca2c9-72fd-46e0-8e70-6e50b73ef889" class="bulleted-list"><li>流量控制是防止发送端的数据填满了<strong>接收端的缓存</strong>，属于<strong>通信双方协商；</strong>拥塞控制是避免发送端的数据填满<strong>整个网络</strong></li></ul><ul id="487714a5-a097-4982-a520-d2e3fe5696d6" class="bulleted-list"><li>流量控制需要通信双方各维护<strong>一个发送窗、一个接收窗</strong>，对任意一方，<span style="border-bottom:0.05em solid">接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定</span>；拥塞控制的<strong>拥塞窗口</strong>大小变化由<span style="border-bottom:0.05em solid">试探性发送一定数据量数据探查网络状况后而自适应调整</span></li></ul><ul id="6bd85f00-235e-4356-b6ab-d7fb246e8daf" class="bulleted-list"><li>实际最终发送窗口=min{流控发送窗口，拥塞窗口}</li></ul><p id="3faeb5e4-6a75-4548-88b4-df7b6edcc9d8" class="">
</p><h3 id="7f01556b-f513-40e4-8803-9f4cd77a8e1d" class="">TCP什么情况下会重传？</h3><ul id="5fec57eb-c8d0-4d04-ba37-3dc92ed6e81f" class="bulleted-list"><li>超过RTO的时间还没收到ACK（超时重传）</li></ul><ul id="a98e60f1-fd43-454f-8156-15d077aaa2e4" class="bulleted-list"><li>收到三个重复确认的ACK（快速重传）</li></ul><p id="d33dbda2-e11e-4976-bc71-68b1b6170230" class="">
</p><h3 id="dfef3b98-86f0-4f8e-b2d9-42a885ae7e15" class="">什么是超时重传？</h3><p id="f56fb902-f04f-42b2-ad88-4179e8eebab6" class="">发送的数据在RTO时间内没收到ACK，就会超时重传。</p><h3 id="dd20ec9a-dddf-4b20-93cb-44ffa59d42d3" class="">什么是快速重传？</h3><p id="4b48622b-e69c-4cff-80e2-9b827d1be6bc" class="">当收到更大序列号的数据包，但是之前某一个还没收到，就会发送渴望之前那个包的ACK，发送端收到三次重复确认ACK后，就会快速重传。</p><p id="6d21c136-5355-42c8-8caf-8a29dd9cd82e" class="">
</p><h3 id="b5b7dd1e-8c0c-4020-975a-bafb177e7f38" class="">RTT、RTO和超时重传分别是什么？</h3><ul id="90910901-1fe3-43c5-a73c-a89c714e72e5" class="bulleted-list"><li>RTT (Round-Trip Time)<p id="093218ca-7daa-4047-ac3a-be38c1a43eb8" class="">数据从<strong>「发送」</strong>到<strong>「接收到对方响应」</strong>之间的时间间隔，即数据包在网络中一个往返用时。</p></li></ul><ul id="78899b66-f40d-4c7f-be1d-47b221b2772d" class="bulleted-list"><li>RTO (Retransmission Timeout)<p id="4a224f19-04b0-42b5-a571-2db011f3a9da" class="">从<strong>「上一次发送数据」</strong>，因为长时间没有收到ACK，到<strong>「下一次重发」</strong>之间的时间。</p><p id="5bdb1658-5ddd-48e8-ba00-6d4907c1c453" class="">通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。如：1RTT，2RTT，4RTT，8RTT…… 重传次数到达上限后停止重传</p></li></ul><ul id="d7a5139a-988d-48e6-b54e-97fdc8b8d94a" class="bulleted-list"><li>超时重传<p id="6024855a-23c9-4226-87c8-114c2de9479c" class="">发送端发送报文后若长时间（RTO）未收到确认的报文，则需要重发该报文。</p></li></ul><p id="8be55398-afa7-4627-bd87-c1b10f5ceefb" class="">
</p><p id="be159859-dc64-4d92-ba57-a1ae1be0a1fa" class="">
</p><h3 id="9c05f9dd-1f38-4670-9c7b-62628a69ca7f" class="">如何解决 TCP 传输丢包问题？</h3><p id="5368582a-048f-4ee8-a250-7052c07cc9f7" class="">
</p><p id="f61f83ff-5824-43f8-b46d-f474c66a3bff" class="">
</p><h3 id="744b934f-0ad1-479f-b7ea-2ce59dd0adab" class="">TCP 如何实现数据有序性？</h3><p id="df60388d-a629-4a11-a071-b96d86da5419" class="">
</p><p id="4b59f005-6563-4713-8227-3ed3ae3b5c77" class="">
</p><p id="38ebdc54-b50a-4339-b131-af882c26f82a" class="">
</p><h2 id="2d2f462b-45aa-471f-9081-860a581659b3" class="">TCP、UDP</h2><h3 id="2169455a-9914-4293-8e1c-9ccd08266de3" class="">UDP是什么？</h3><p id="aa840e6e-8274-403a-912c-b45942976d75" class="">一种传输层协议。提供<strong>无连接</strong>的，尽最大努力交付的数据传输服务，<strong>不保证数据传输的可靠性</strong>。</p><h3 id="06dc1e2e-ad56-4d32-bade-506e1169f8ad" class="">⭐️TCP、UDP 区别？</h3><ul id="993f80c5-fd04-4306-8e29-098de176565d" class="bulleted-list"><li>TCP是<strong>面向连接</strong>的传输协议，传输数据之前需要建立连接；UDP<strong>不需要连接</strong></li></ul><ul id="c48d69f6-363d-4a9a-9676-806cb5967b41" class="bulleted-list"><li>每一条TCP连接只能是<strong>点到点</strong>的；UDP支持<strong>一对一，一对多，多对一和多对多</strong>的交互通信</li></ul><ul id="1d9a5fcb-2a14-4c6e-8f0d-bd316f3bcf05" class="bulleted-list"><li>TCP是<strong>可靠交付</strong>数据的，数据可以<span style="border-bottom:0.05em solid">无差错、不丢失、不重复、按序到达</span>；而UDP是<strong>尽最大努力交付，不保证可靠</strong>交付数据</li></ul><ul id="aa9beb6e-4bbe-4d23-8328-33e92eb10263" class="bulleted-list"><li>TCP面向<strong>字节流</strong>，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向<strong>报文</strong>的</li></ul><ul id="1751dd99-369e-4427-8ecb-26098dd10403" class="bulleted-list"><li>TCP具有<strong>拥塞控制和流量控制</strong>机制，保证数据传输的安全性；而UDP没有，即使网络拥堵，也不影响UDP发送速率。</li></ul><ul id="5d212819-0642-4f84-81ed-5bd25eb7dd73" class="bulleted-list"><li>TCP<strong>首部较长</strong>，在没有使用[选项]字段时是20字节，若使用还会变长，会有一定开销；而UDP<strong>首部只有8字节</strong>，开销较小</li></ul><ul id="f0e98121-95e8-473f-93b2-0827e59a551f" class="bulleted-list"><li>TCP的逻辑通信信道是<strong>全双工的可靠信道</strong>，UDP则是<strong>不可靠信道</strong></li></ul><ul id="873fca4f-f00b-40c6-b5fa-cb892e7702fa" class="bulleted-list"><li>TCP的套接字是四元组（源IP地址，源端口号，目的IP地址，目的端口号）；而UDP是二元组（目的IP地址，目的端口号）</li></ul><p id="49b98f68-ddbb-4328-bb4e-2842e345ab6c" class="">
</p><p id="d4570514-46ee-4a3d-ad31-ee0169e4a86f" class="">注：</p><p id="a94237b0-800c-4a3b-9f2a-ea7532622862" class="">TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”(缓存区)，等到可以发送的时候就发送，不能发送就等着。TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p><p id="49ad604e-39f3-4e11-afd9-ff6914267bdb" class="">这里“流”(stream)指的是流入进程或从进程流出的字节序列。</p><p id="58289bb8-52af-49e2-881f-4f50c03905c8" class="">“面向字节流”：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流</p><p id="fda81ce1-4d8e-4992-8034-9db9f6d9f293" class="">UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收 方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小。</p><p id="6be4b27a-4729-4cee-aa55-322637074d8b" class="">
</p><figure id="2aa6681e-b183-4bdd-855a-f0d033b291af" class="image"><a href="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%204.png"><img style="width:1590px" src="%E4%BC%A0%E8%BE%93%E5%B1%82%2033acd22918cf4f64b35a616ceef394b0/Untitled%204.png"/></a></figure><p id="c74933bc-b3eb-410e-ab3f-c4ca37eb4461" class="">
</p><p id="8766d7da-aa95-4de5-84c2-c1a6ac785786" class="">
</p><h3 id="2a19dada-8081-4d6c-8476-62a9e7c58a9a" class="">TCP和UDP分别对应的应用层协议？</h3><p id="c07a4a5f-e74b-46f5-83f6-5ea2161cd813" class=""><strong>TCP对应的应用层协议（即基于TCP的应用层协议）：</strong></p><ul id="da371a8f-4385-48bd-9c39-73bf249bda4f" class="bulleted-list"><li>FTP：定义了文件传输协议，21端口</li></ul><ul id="807671a3-239a-4cb8-a070-f13e2f8dfb5f" class="bulleted-list"><li>Telnet：用于远程登录，23端口</li></ul><ul id="22ed33e6-6c20-4ee9-8ba2-21d8865db7d4" class="bulleted-list"><li>SMTP：定义了简单邮件传送协议，服务器25端口</li></ul><ul id="bd7edff8-3225-48a0-89b6-31fe768b88a5" class="bulleted-list"><li>POP3：与SMTP对应，POP3用于接收邮件</li></ul><p id="625163ff-6429-48fe-b992-f0b01588b789" class=""><strong>UDP对应的应用层协议（即基于UDP的应用层协议）：</strong></p><ul id="55755d24-2a0c-45b0-b68f-5044150baab1" class="bulleted-list"><li>DNS：域名解析服务，53端口</li></ul><ul id="fd4a3462-90d2-40f4-a6fa-a785ee5b4a82" class="bulleted-list"><li>SNMP：简单网络管理协议，161端口</li></ul><ul id="e2839560-c83d-4746-ae69-b48200b90b82" class="bulleted-list"><li>TFTP：简单文件传输协议，69端口</li></ul><ul id="56e5c556-a46a-48f2-b4c1-1398b1c52977" class="bulleted-list"><li>NFS：远程文件服务器</li></ul><p id="1c08fef0-cc94-4e81-8423-8b597d533fb9" class="">
</p><p id="a228f2ca-48e3-4829-8830-033214e77e63" class="">
</p><p id="0f368e7e-3920-4021-9960-8c44ae500b7f" class="">
</p><h3 id="9e1df3d2-c66c-4859-98da-b483a89e3598" class="">为什么TCP比UDP安全？</h3><p id="321856f6-fa13-4aef-895e-e15f81483a82" class="">
</p><h3 id="70a89f6e-b294-48cd-9fc4-3bc63ee878f9" class="">知道QUIC吗？</h3><p id="9139d366-43cb-473f-9050-6f3482e97358" class="">是谷歌制定的一种基于UDP的低时延的互联网传输层协议，</p><p id="e7a97514-55dc-44eb-a394-4322ec9b4c11" class="">QUIC融合了包括TCP，TLS，HTTP/2等协议的特性，但基于UDP传输。QUIC的一个主要目标就是减少连接延迟，当客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接,相对于TCP+TLS的1-3次RTT要更加快捷。</p><p id="475efab6-a3c5-4393-bb36-eea1887df997" class="">
</p><h3 id="01257010-7633-411f-bdca-2c3e30e59e5e" class="">⭐️❓如何实现UDP的可靠传输？</h3><p id="6098c006-308f-4585-94e7-885c8eeb8c7c" class="">需要通过应用层来实现和控制，参照TCP可靠性传输的方式，实现确认、重传、</p><p id="920d90ba-7776-4c78-99f1-647672df3877" class="">
</p><p id="65eb8ba9-818e-48a4-85db-fd0b2b00feb3" class="">
</p><p id="5ae19ae3-4f79-4552-a615-4b69c94d85aa" class="">
</p><p id="99fe192c-3440-4ece-97b8-a5952d5be1a2" class="">
</p><h2 id="78ec508a-fb37-4ea3-ba48-294d29a8ad52" class="">长短连接</h2><h3 id="e02b4e74-4546-47ae-a3fb-55cbb5379014" class="">⭐️TCP长连接和短连接的使用场景？</h3><p id="ca07a06f-e99d-4969-a6b7-48c8f1b692a5" class="">长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：<strong>数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</strong></p><p id="9e04833b-4682-4a31-bcb8-6a25bb064361" class="">而像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以<strong>并发量大，但每个用户无需频繁操作情况下需用短连好</strong>；</p><p id="936575c4-d59c-4b7e-8058-debcc35a26b3" class="">
</p><h3 id="a8a2a036-1fa8-47a4-9aed-451442aa7ab9" class="">⭐️❓TCP的keepalive是什么？与HTTP的keepalive有什么区别？</h3><p id="c5b519a1-30a3-435d-acf7-a8e6c46e1e40" class="">意图不同。</p><p id="dad83746-002c-4a15-bd97-4f2207cf94fa" class="">tcp keepalive用于<strong>回收空闲的tcp连接</strong>，以释放服务器的资源，提升服务器的性能。</p><p id="56fd63dc-c3d1-4ea5-a709-7b413a57c417" class="">http keepaliveHTTP 的 keepalive，是双方约定长连接、还是收完一次数据后立刻关闭套接字。用于<strong>复用同一个tcp连接以承载多个http请求</strong>，这样减少了连接建立的三次握手和关闭的四次握手，这样降低了网络开销，也减轻了服务器压力。</p><p id="9e084e37-d0be-448d-8075-142d701611f9" class="">
</p><p id="91a5b1cd-dc9c-45be-924f-dd103a827120" class="">http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。但是需要设置keepalive-timeout时间来设置发送完最后一个响应之后多久关闭连接。</p><p id="83c81538-052d-41b2-a158-b4472ed51af4" class="">而tcp keep-alive是TCP的一种检测TCP连接状况的保活机制。每隔多久发送一个探测报文，看看对方是否还活着。</p><p id="b4634c65-a8a0-4f22-9f13-c82daa671a34" class="">
</p><p id="98f44226-8fc7-4dab-8e78-a34b0cdf0a05" class="">
</p><h2 id="ea23e820-99b0-4765-bd82-d1e969c5cab7" class="">其它</h2><h3 id="52df0057-6354-45c5-893e-b0b5ab050455" class="">⭐️简述 TCP 的报文头部结构</h3><figure id="f048a5bf-26c6-4e97-a688-89f6357fafbd" class="image"><a href="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled.png"><img style="width:1236px" src="TCP%205df568f5f9d041d6973d48798c64e0bf/Untitled.png"/></a></figure><p id="d0c33258-6b38-4a46-b9e9-652b667d5f1d" class="">
</p><h3 id="7648ae9c-c737-458f-beaf-399009eeecbb" class="">简述 TCP 协议的延迟 ACK 和累计应答</h3><p id="17c635a9-2cbe-4cb1-952d-0df53b5eb959" class="">
</p><h3 id="6ebfb14a-7754-4cd9-8c49-2af2df0c74cb" class="">延迟确认</h3></div></article></body></html>