<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>内存管理</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="f9e9499f-59a7-4496-bd55-875a09c48049" class="page sans"><header><h1 class="page-title">内存管理</h1></header><div class="page-body"><hr id="58469ac5-1d89-42c8-a224-a025adf39f7c"/><p id="a7359bfc-33e8-46a3-ae5a-e779d58ae312" class="">
</p><p id="d3a83c0d-c8d6-42d3-8d0d-fea9bd17f474" class="">
</p><nav id="b6207239-3020-4dc7-8c69-eaab35804898" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0fbfe137-263c-4988-9f92-cb1b7f0be01c">地址转换</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a36c4739-bb81-4603-95a6-699cf1dfd5a8">物理地址、逻辑地址、虚拟地址、线性地址是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7c385fd2-5851-43e0-8541-889edf1e0b0b">⭐️逻辑地址与物理地址的转换？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#83bb81db-1560-421f-836c-950176901a4d">⭐️什么是多级页表？为什么要有多级页表？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0da2d793-2ab2-401e-b73b-b046a3bad3ad">⭐️TLB是什么（快表）？有了快表，地址变换有什么区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d68c84bc-615c-4100-baf8-32b8e23d5819">快表可以快多少？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#84834848-26b6-4c1d-ba50-24df6a53aea3">什么是局部性原理？其应用？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#816b0ffc-6da3-4c24-8351-db37887e0d3e">虚拟内存和页面置换</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0e619eea-238f-43be-ad62-99c955ffd310">⭐️虚拟内存介绍一下？为啥要有虚拟内存？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2126234f-e81e-451e-990a-0894c683670b">虚拟内存如何映射到物理内存，多级页表，页表使用的算法</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8372e788-84a8-4e83-ad30-b8c7a49a65b6">虚拟地址有什么好处？虚拟内存页表中有什么东西？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9cc8d90e-1c27-44e2-a9af-8dace0e5adcc">交换空间和虚拟内存的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#574eb715-743c-4668-b927-00c5a4116d6a">如果访问内存中的页表不命中需要进行什么操作？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2adafb10-3b71-4e03-b3a9-06c275ca8799">⭐️有什么页面置换算法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c517bf9b-704b-428e-9b95-240230f4fac6">简述操作系统中的缺页中断？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#420ec742-8f9e-4438-936f-4ca45ab9cf50">抖动是什么？（也叫颠簸）</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1e7f6242-81ed-4b1b-aedd-6007e56cfd89">内存交换</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#41778f69-76c2-43a5-b384-26ff135d1c78">什么时候发生内存交换？应该换出哪些进程？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9d2a284f-0c75-434b-a903-a6b76addfefb">内存交换和覆盖的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#13a49f69-b4a0-4b18-91a7-aa6dc4748758">外存的什么位置保存被换出的进程？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ce562720-af8f-4640-a053-b8d5443738d7">内存分配和管理</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#180599a5-d5d2-4ae8-bf2f-56580a4a4591">——操作系统的内存管理</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bcea4a78-aed0-4db0-9b20-d8354010e812">⭐️操作系统如何进行内存管理的？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#159f734d-219b-48f2-a002-f924b0ea166c">⭐️操作系统如何申请和管理内存的？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4eeb8e1d-1f1f-406d-8d07-2fda212c1a45">操作系统的内存管理？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#502a0a7c-05f0-4d4c-9b49-4c7ea4431924">内存分配?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ced54ddc-4fdf-4072-8a16-4902699d9f5f">动态分区分配算法有哪些？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f4fd562b-95e6-4fd0-9752-3f95749984d7">段式存储管理</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8cb82442-9282-498b-932f-727608e02404">页式存储管理</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ab59d5fc-7a2b-4d6a-a05b-8fa300b394b0">段页式内存管理？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2480ba46-eeb6-44cd-8395-d7a9b0ed5f56">说一下内存碎片？内部碎片和外部碎片？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cf93cb09-417d-4cd6-9e0a-ed54b0639e42">如何消除碎片文件？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#689d59fd-6249-433c-aefc-2b07d45c909c">——<strong>进程的内存管理</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8b218b99-45dd-4b0d-ad68-6e6d02869b41">进程的内存管理？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9eb560c4-7620-45fa-ac85-87196e3cecc8">⭐️内存分布情况？（进程的虚拟地址空间分布）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b5f0e19c-973a-42b7-9aaf-d34b8faa679f">一个由C/C++编译的程序占用的内存分为哪几个部分？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0700bb3b-3a10-44e6-8b80-4bd2e0526eac">⭐️堆和栈的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a7e38d14-6b11-4b88-b290-6a391ec1406e">Linux/Windows平台下栈空间的大小？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2cae658f-6c5f-40a7-8ec1-879c35d2b78d">程序从堆中动态分配内存时，虚拟内存上怎么操作？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#024a0f13-33d1-4b4d-bcdc-fece544fb0db">从堆和栈上建立对象哪个快？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f4c38072-5582-43b1-9f16-efa42d0240a8">为什么堆有内存碎片，而栈没有？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0a7596a8-bd11-4064-8d41-b00fab1bf8f1">其它</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c1df6147-2128-4d64-a9b6-3a16c5691f21">操作系统在做内存管理的时候，有哪些内存管理的算法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7518228d-81a0-4b6b-8ee7-7611a255db9c">内存池是什么？为什么要有内存池？如何设计一个内存池？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2d638bd5-385a-43de-a13f-1ae34c39dda2">简述 CPU L1, L2, L3 多级缓存的基本作用</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3db5f0c2-47ff-45e2-9191-ea30a9c2833a">总结</a></div></nav><p id="5948b3ec-3b8b-4bb3-a3a7-c225b61eca3f" class="">
</p><h2 id="0fbfe137-263c-4988-9f92-cb1b7f0be01c" class="">地址转换</h2><h3 id="a36c4739-bb81-4603-95a6-699cf1dfd5a8" class="">物理地址、逻辑地址、虚拟地址、线性地址是什么？</h3><figure id="9e5a3807-8b98-4818-b4d9-621587bebbeb" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled.png"><img style="width:480px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled.png"/></a></figure><p id="3b1f8f00-2913-44b9-86cf-a59d42ee8595" class="">
</p><h3 id="7c385fd2-5851-43e0-8541-889edf1e0b0b" class="">⭐️逻辑地址与物理地址的转换？</h3><p id="066763ed-fdc3-4dad-9286-8342f21df76a" class="">（应该是虚拟地址和物理地址之间？）如果是逻辑地址，应该还要加一个查段表？</p><p id="eceb01d4-5b5f-4298-8837-bc503cb559ac" class="">系统中会设置一个<strong>页表寄存器（PTR）</strong>，存放页表在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的起始地址和页表长度在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><ol id="228c4999-6ae0-48a3-a9d7-587474a4d7af" class="numbered-list" start="1"><li>根据逻辑地址A算出页号P和页内偏移量W：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>L</mi><mo separator="true">,</mo><mi>W</mi><mo>=</mo><mi>A</mi><mi mathvariant="normal">%</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">P=A/L,W=A\%L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">A</span><span class="mord">%</span><span class="mord mathnormal">L</span></span></span></span></span><span>﻿</span></span></li></ol><ol id="d51b4226-bb7d-4904-8f8d-b0fffca4cded" class="numbered-list" start="2"><li>判断页号是否越界：比较P和M</li></ol><ol id="f571c882-150e-4851-997f-4d2256bac462" class="numbered-list" start="3"><li>查询页表，找到页号对应的页表项，从中取出内存块号（物理块号）：页表项地址=页表起始地址F+页号P*页表项长度</li></ol><ol id="5906f6da-698b-4d99-8d10-35d26415a31c" class="numbered-list" start="4"><li>用内存块号和页内偏移量得到物理地址：<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>b</mi><mo>∗</mo><mi>L</mi><mo>+</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">E=b*L+W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span><span>﻿</span></span></li></ol><figure id="5594c662-b093-4149-8e72-0192359f4ab1" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%201.png"><img style="width:1188px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%201.png"/></a></figure><p id="3358d02f-d5cb-4256-b0cf-79808a0b44c7" class=""><span style="border-bottom:0.05em solid">缺陷：空间占用大，且要连续</span></p><h3 id="83bb81db-1560-421f-836c-950176901a4d" class="">⭐️什么是多级页表？为什么要有多级页表？</h3><p id="9a829652-bb26-47cd-92ef-6b81c017f64d" class=""><strong>单级页表的问题——空间上的缺陷</strong></p><ul id="168031eb-119a-49d2-89cc-2781d5edd2d5" class="bulleted-list"><li>页表必须连续存放，因此页表很大时，需要占用很多个连续的页框</li></ul><ul id="df19896e-2d47-4f63-aea7-0269582a0c2e" class="bulleted-list"><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</li></ul><p id="871f6317-43b7-419d-bd78-3284d2133e5d" class="">
</p><p id="a228d565-8225-4833-b9c6-62090c3f2021" class=""><strong>多级页表</strong></p><p id="3ef11b96-1fe4-4b52-8757-9fabcbd90644" class="">地址转换：</p><ol id="79865ce0-cd72-4310-8ad9-7f960684dd5b" class="numbered-list" start="1"><li>从PCB中读出页目录表起始地址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li></ol><ol id="f603b035-c52c-4f23-b205-19b7bf75e416" class="numbered-list" start="2"><li>根据二级页号查表，找到最终想访问的内存块号</li></ol><ol id="8a6d5131-45c8-4826-a991-fedf97f6dffd" class="numbered-list" start="3"><li>结合页内偏移量得到物理地址</li></ol><p id="e5ae7ae9-c657-4038-ad72-c6309c166772" class="">
</p><p id="7bb5fbac-bf22-4c7b-8f95-10e7b1480bfd" class="">多级页表使得页表可以在内存中<strong>离散存储！（因为各级页表大小不超过一个页面）</strong></p><figure id="5dd4adba-5027-432f-9ab5-a9effe8f94d0" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%202.png"><img style="width:624px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%202.png"/></a></figure><p id="fbd49e0d-7337-4cd1-9c17-c62637f2bde3" class=""><strong>细节：</strong></p><ul id="3611eeeb-2b21-4f33-8019-90295929b687" class="bulleted-list"><li>各级页表的大小不能超过一个页面，若两级页表不够，可以分多级</li></ul><ul id="6af15dcb-82a1-4bd4-9f21-146731758f63" class="bulleted-list"><li>多级页表的访存次数（假设没有快表机制）——N级页表访问一个逻辑地址需要N+1次访存</li></ul><p id="16b8be38-1c80-4574-8a44-127e1dcf9bba" class=""><strong>缺陷：多了几次访存，降低了转换速度</strong></p><p id="582422ef-7339-43da-957f-ddf95376eecd" class="">
</p><p id="006577bc-abea-4d18-8694-132ce06d083f" class="">那么为什么多级页表可以减少存储呢？</p><ol id="b91e99fe-6aa0-4ca0-a3db-3e67835dcd6c" class="numbered-list" start="1"><li>如果一级页表中的某一个PTE（分页）是空的，那么相应的二级页表就根本不会存在，这代表着一种巨大的潜在节约，因为对于一个典型的程序，比如4GB,8GB的虚拟地址空间的大部分都将是未匹配的。</li></ol><ol id="61705eb1-a8e7-42a7-b67e-1d4fecc53024" class="numbered-list" start="2"><li>只有一级页表才需要总是在主存中，二级页表可以在需要的时候调入</li></ol><p id="d4b7f9f2-371f-444a-95b2-ba535e88de3d" class="">
</p><h3 id="0da2d793-2ab2-401e-b73b-b046a3bad3ad" class="">⭐️TLB是什么（快表）？有了快表，地址变换有什么区别？</h3><p id="0586cb73-4d13-4460-95ff-9ce998cd2f35" class=""><strong>快表</strong>，又称联想寄存器（TLB, translation lookaside buffer），是一种<strong>访问速度比内存快很多的高速缓冲存储器</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><figure id="481fc469-0409-4fc6-b64b-b12934823973" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%203.png"><img style="width:1484px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%203.png"/></a></figure><p id="bb18afd3-e914-4df8-a945-d10911da7eb4" class=""><strong>有无快表地址变换的区别：</strong></p><figure id="a33a5d66-3e1d-4c4a-a2f4-bfb6a5c96001" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%204.png"><img style="width:1312px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%204.png"/></a></figure><p id="272fec16-aef6-4d3f-8b12-1794468c2aee" class="">
</p><h3 id="d68c84bc-615c-4100-baf8-32b8e23d5819" class="">快表可以快多少？</h3><p id="a11de3ea-6692-4e06-8550-b422d4d7efc1" class="">由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到90%以上。</p><p id="72549f0d-da0d-4e6e-b4fa-2b23788ac823" class="">例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?
(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us
有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) * 0.9+ (100+100)
*0.1=110.9 us</p><p id="5d6228b5-d107-4787-844c-8536c3440283" class="">若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us</p><p id="ba996019-6d97-401a-9490-303a36c0cc26" class="">
</p><h3 id="84834848-26b6-4c1d-ba50-24df6a53aea3" class="">什么是局部性原理？其应用？</h3><ul id="670aba83-cf65-4398-bc42-ddbbd227dcc9" class="bulleted-list"><li><strong>时间局部性</strong><p id="48cf59ca-e349-402d-980b-e81bac5c53ca" class="">如果执行了程序中的某条指令，那么不久之后这条指令很有可能再次执行；如果某个数据被访问了，不久之后该数据很有可能再次被访问。（因为程序中存在大量的循环）</p></li></ul><ul id="e0d5cd77-ddbd-49f4-9225-31cf6d60a001" class="bulleted-list"><li><strong>空间局部性</strong><p id="0cae4236-e574-491f-96f6-ec7d29f2a04a" class="">一旦程序访问了某个存储单元，在不久之后，其附近的存储单元很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p></li></ul><p id="d386eb32-0687-4314-ac9f-3e89f01c772f" class="">快表就是利用了局部性原理，将近期常访问的页表项副本放到更高速的联想寄存器中。应该是放在寄存器中的？应该是在高速缓存中吧🤔</p><figure id="30f779c8-0427-4ca0-99e5-cfcdfca6ec84" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%205.png"><img style="width:240px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%205.png"/></a></figure><p id="e6153353-e01c-4f21-8d77-4f5360d612e5" class="">
</p><p id="f751b521-c92e-4ccf-97bd-1f8fd5543663" class="">
</p><h2 id="816b0ffc-6da3-4c24-8351-db37887e0d3e" class="">虚拟内存和页面置换</h2><h3 id="0e619eea-238f-43be-ad62-99c955ffd310" class="">⭐️虚拟内存介绍一下？为啥要有虚拟内存？</h3><p id="68769224-add8-4217-9197-b0aa812c160f" class=""><strong>虚拟内存的目的：</strong></p><p id="24614b2e-81df-40ba-bbef-cce64a9bba79" class="">是为了<strong>让物理内存扩充成更大的逻辑内存</strong>，从而让程序获得更多的可用内存。虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得<strong>有限的内存运行大程序成为可能</strong>。</p><p id="3eacf99f-9043-4ebc-949e-cef01afb118a" class=""><strong>介绍：</strong></p><p id="bf54c7cb-afbe-4a57-a1b3-0c0db55bc5be" class="">操作系统<strong>将内存抽象成地址空间</strong>，每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块成为一页。</p><p id="a6ea2187-2391-4a23-83f9-3270d9e3d9cb" class="">这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，执行<strong>页面置换算法</strong>，将页置换到内存中。</p><figure id="a564b393-e84d-4fd2-a1ce-a551b179c765" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%206.png"><img style="width:288px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%206.png"/></a></figure><p id="6303f092-9551-49ef-ab44-b513a22a50d1" class="">
</p><h3 id="2126234f-e81e-451e-990a-0894c683670b" class="">虚拟内存如何映射到物理内存，多级页表，页表使用的算法</h3><p id="c0899a01-213f-46f5-9a68-6bfa9da4a648" class="">
</p><p id="a6805bb7-10a6-4b16-8c26-f22bb48cdd88" class="">
</p><h3 id="8372e788-84a8-4e83-ad30-b8c7a49a65b6" class="">虚拟地址有什么好处？虚拟内存页表中有什么东西？</h3><p id="3679ca7c-49f9-4624-8c43-b0638b2e4b38" class=""><strong>虚拟地址好处：</strong></p><ol id="3626feed-9e5d-46a7-92b8-91c2bf5fdb20" class="numbered-list" start="1"><li>软件不需要考虑内存分配的问题</li></ol><ol id="51fa1b1c-b348-4bbe-9680-5595a8cc27e4" class="numbered-list" start="2"><li>也不需要担心内存不足和两个程序抢同一片内存导致系统整个崩溃的情况</li></ol><p id="66f4bd50-c770-4d56-9c67-634665ef5029" class=""><strong>页号，物理块号，状态位P，访问字段A，修改位M 和 外存地址</strong>； </p><ul id="602e75cf-c222-4f2e-938a-d818352ba0f2" class="bulleted-list"><li>状态位P指示该页是否调入内存，供程序访问时参考； </li></ul><ul id="5dc3f784-bfa7-4bfc-9c18-b9d3bcd49c33" class="bulleted-list"><li>访问字段A用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法 ---选择换出页面时参考； </li></ul><ul id="1ac8586a-9ee8-4226-a128-280d878c5ef9" class="bulleted-list"><li>修改位M表示该页在调入内存后是否被修改过； </li></ul><ul id="90e00709-2e2f-493a-abb3-e2854986efb7" class="bulleted-list"><li>外存地址用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用</li></ul><p id="809cbc11-d63d-4d81-9961-dc63f0f02616" class="">
</p><h3 id="9cc8d90e-1c27-44e2-a9af-8dace0e5adcc" class="">交换空间和虚拟内存的区别？</h3><p id="6adb95fb-eb7e-42a8-aaa4-6fe90980c7fa" class="">虚拟内存是对物理内存的抽象，是RAM和磁盘空间的组合。</p><p id="c40e9e21-093b-4fc5-9afa-92e923017fae" class="">交换空间对应着虚存中的用来临时存储物理内存中内容的磁盘空间。</p><p id="55a17372-5030-4d04-95ea-a73584088f7a" class="">
</p><p id="05b120df-e58a-40ca-9a8d-8903fe5b6397" class="">
</p><h3 id="574eb715-743c-4668-b927-00c5a4116d6a" class="">如果访问内存中的页表不命中需要进行什么操作？</h3><p id="8f0ed39f-d2e4-4349-bca6-0cfc4579afff" class="">如果访问内存中的页表不命中需要进行页面置换。将某些页面从内存置换出去，再通过缺页异常将交换空间中的相应部分调入物理内存。</p><h3 id="2adafb10-3b71-4e03-b3a9-06c275ca8799" class="">⭐️有什么页面置换算法？</h3><ul id="2a8ad87d-fdc6-489b-97b9-8bd1d765a1b2" class="bulleted-list"><li><strong>最佳置换法（OPT）</strong><p id="cc943a39-2617-4376-8863-c9bc270840a8" class="">算法描述：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><p id="dd98db8b-8c61-4cfa-bfd6-622a611863ec" class="">优点：缺页率最小，性能最好</p><p id="2551ea49-c81a-40d6-afc1-6f144ae97c46" class="">缺点：虽然好，但无法实现。</p></li></ul><ul id="799346d5-700e-4ba7-8792-8a1cd64275db" class="bulleted-list"><li><strong>先进先出置换算法（FIFO）</strong><p id="4f1cd680-b381-4c95-bdcf-4f343c58ed09" class="">算法描述：每次选择淘汰的页面是最早进入内存的页面。</p><p id="17922838-0c63-4b54-8e8e-7f1dc1d1de98" class="">优点：实现简单</p><p id="feb65bd8-da13-406e-bd64-a1c03e5bb3fb" class="">缺点：Belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。——与通常页面的使用规则不符合,最先进入的页面也有可能是最常被访问的，算法性能差。</p></li></ul><ul id="ad255e7b-816e-4bc9-894c-48a49fe3f84c" class="bulleted-list"><li><strong>最近最久未使用置换算法（LRU）</strong><p id="12f5aefd-a502-47e2-b3e4-20817d51b47d" class="">算法描述：每次淘汰的页面是最近最久未使用的页面</p><p id="c9c212cd-f0fd-4f35-b9c0-51c425be059e" class="">优点：性能很好</p><p id="206b8259-dc7f-41ec-b81b-9151c02dc007" class="">缺点：实现困难，需要寄存器和栈的硬件支持，开销大。</p></li></ul><ul id="2c7acc77-106b-48ed-904b-525dca204ac5" class="bulleted-list"><li><strong>最不经常使用页面置换算法（LFU）</strong><p id="226771e4-d40b-4977-b9e6-05430b5fd6b3" class="">算法描述：最低访问数的条目首先被移除。这个缓存算法使用一个计数器来记录条目被访问的频率。</p><p id="561dc0a7-e8f5-4768-87e4-a0ea0af0599e" class="">缺点：这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。</p></li></ul><ul id="2fd2f3df-e3c4-45bf-ad94-32cda659adef" class="bulleted-list"><li><strong>时钟置换算法（CLOCK），——又称最近未用算法(NRU，Not Recently Used)</strong><p id="c7d0b870-28c3-4f84-a6a1-9f2981a71218" class="">算法描述：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个<span style="border-bottom:0.05em solid">循环队列</span>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所 有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位 为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描）</p><p id="2afeae3c-19b6-491b-890b-babde3948758" class="">优点：实现简单，算法开销小</p><p id="e4c1005b-1f75-4ecf-b8a7-deca2322f533" class="">缺点：没有考虑页面是否被修改过——只有被换出的页面被修改过时，才需要写回外存。</p></li></ul><ul id="9a22175e-86eb-455e-8b75-d94961558e15" class="bulleted-list"><li><strong>改进的时钟置换算法</strong><p id="4daf953a-5267-4c0d-8acc-dfbcc53bf0ae" class="">算法描述：用(访问位，修改位)的形式表示各页面状态，在其他条件都相同时（即都没有访问过），应优先淘汰没有修改过的页面，避免I/O操作。</p><p id="c9541cc8-be4e-4306-82ca-7257a0fd28b3" class="">最多四轮扫描。优先级：(0,0)最近没访问，也没有修改的页面 &gt; (0,1)最近没访问，但修改过的页面 &gt; (1,0)最近访问过，且修改过的页面 &gt; (1,1)最近访问过，且修改过的页面。</p><ol id="646d94ac-cb2a-4847-ad03-2dcf26dcfd3f" class="numbered-list" start="1"><li>从当前位置开始扫描到第一个<mark class="highlight-red">(0, 0)</mark>的帧用于替换。</li></ol><ol id="5b6b7190-03ee-46f7-87db-d1595c91076a" class="numbered-list" start="2"><li>若第一轮扫描失败，则重新扫描，查找第一个<mark class="highlight-red">(0, 1)</mark>的帧用于替换。本轮将所有扫描过的帧访问位设为0</li></ol><ol id="168e82e6-c307-4dce-b7f5-31b301227db4" class="numbered-list" start="3"><li>若第二轮扫描失败，则重新扫描，查找第一个<mark class="highlight-red">(0, 0)</mark>的帧用于替换。</li></ol><ol id="110f3121-a914-4da8-a3d2-dd4a492dfc93" class="numbered-list" start="4"><li>若第三轮扫描失败，则重新扫描，查找第一个<mark class="highlight-red">(0, 1)</mark>的帧用于替换。</li></ol></li></ul><p id="cae58d89-a629-4f3d-8e15-20b1a7af608c" class="">
</p><h3 id="c517bf9b-704b-428e-9b95-240230f4fac6" class="">简述操作系统中的缺页中断？</h3><p id="0ae4c3cb-8f3f-446d-b19c-2ebf7812d65c" class="">缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。</p><p id="6d28d273-f6f7-41a5-baef-d54701c59059" class="">malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程第一次访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p><p id="e3c47b01-3898-439f-b3de-3804f2792e75" class="">在请求分页系统中，<strong>可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中</strong>。每当所要访问的页面不在内存是，会产生一次缺页中断，此时<strong>操作系统会根据页表中的外存地址在外存中找到所缺的一页</strong>，将其调入内存</p><p id="993e8ad1-8a74-4494-ae70-5cba223e2f2b" class="">
</p><h3 id="420ec742-8f9e-4438-936f-4ca45ab9cf50" class="">抖动是什么？（也叫颠簸）</h3><p id="6f1b74be-9c42-4c69-8f78-8a5226ac4725" class="">现象描述：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为 抖动，或颠簸。</p><p id="cd6f0f51-111a-443c-8312-5dbc3f8a99e4" class="">产生原因：进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块太少)</p><p id="4a2629f0-290f-479c-9eb1-6b419d06cbe1" class="">应该分配多少？——Denning提出进程工作集</p><p id="020f5ed1-46ae-4172-b617-1a3ba172260c" class="">
</p><p id="d67e0fc3-5f72-42b8-a9c1-a62bcd00e964" class="">
</p><h2 id="1e7f6242-81ed-4b1b-aedd-6007e56cfd89" class="">内存交换</h2><h3 id="41778f69-76c2-43a5-b384-26ff135d1c78" class="">什么时候发生内存交换？应该换出哪些进程？</h3><p id="41583f0c-fbee-4626-851a-176efcd898a8" class="">许多进程运行且内存吃紧时进行交换，而系统负荷降低就暂停。</p><p id="97021948-787a-46c6-b07d-4a00fa22820a" class="">例如：<strong>发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程。</strong></p><p id="e7b68a02-d477-412d-88f0-5340dd85383a" class="">可优先换出阻塞进程；优先级低的进程；或者还会考虑进程在内存的驻留时间</p><p id="8e66629e-b528-484d-8641-acc3556684dd" class=""><mark class="highlight-red"><strong>注意：PCB会常驻内存，不会被换出外存！</strong></mark></p><p id="89c3c0f7-f862-4441-956c-81022a13d47d" class="">
</p><h3 id="9d2a284f-0c75-434b-a903-a6b76addfefb" class="">内存交换和覆盖的区别？</h3><ul id="d9b5ecd3-50cf-4d62-88a1-b678f2ed61b0" class="bulleted-list"><li>覆盖技术<p id="71500040-3617-4d35-8dce-c2acc25796e0" class="">将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存，内存中分为一个“固定区“和若干个”覆盖区“。</p><p id="18e2f5cf-645e-4657-8950-1908555dc943" class="">缺点：编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。</p></li></ul><ul id="b5ee7b72-1a50-4172-9833-f84020fecfde" class="bulleted-list"><li>交换技术<p id="bf0bd7ff-ff37-4608-9272-aa6145ddd82f" class="">内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存。暂时换出外存的进程状态为挂起状态。</p></li></ul><p id="c021e098-c1dc-47e9-9627-41c1f0e50169" class="">区别：交换技术主要是在不同进程(或作业)之间进行，而覆盖则用于同一程序或进程中。</p><p id="1778e9d6-4ff7-4716-b67a-aa59c13d8289" class="">
</p><h3 id="13a49f69-b4a0-4b18-91a7-aa6dc4748758" class="">外存的什么位置保存被换出的进程？</h3><p id="ba69951e-8e3c-4cb7-8d07-8ccb7cbe8ce7" class="">磁盘空间分为文件区和对换区。</p><p id="34b22739-6674-4ffa-bd4c-99e2a7db5015" class=""><strong>文件区</strong>主要用于存放文件，追求存储空间的<strong>利用率</strong>，因此对文件区采用<strong>离散分配方式</strong>。</p><p id="ad189810-f0f7-4be2-a60c-f64a1e7ba330" class=""><strong>对换区</strong>只占小部分，被换出的进程数据就存放在对换区，追求<strong>换入换出速度</strong>，因此采用<strong>连续分配方式</strong>。对换区的I/O速度比文件区更快。</p><figure id="c6f5fc96-ada2-4f84-b166-6de7a61732db" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%207.png"><img style="width:166px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%207.png"/></a></figure><p id="7f1d16d7-2e06-4b93-b5ac-2a567eb364f2" class="">
</p><p id="634202c8-64a5-41bd-8b50-cb8e25a0bddb" class="">
</p><h2 id="ce562720-af8f-4640-a053-b8d5443738d7" class="">内存分配和管理</h2><h2 id="180599a5-d5d2-4ae8-bf2f-56580a4a4591" class="">——操作系统的内存管理</h2><h3 id="bcea4a78-aed0-4db0-9b20-d8354010e812" class="">⭐️操作系统如何进行内存管理的？</h3><p id="4a315ea6-a566-4b94-8775-2d95b1a0cb86" class="">
</p><h3 id="159f734d-219b-48f2-a002-f924b0ea166c" class="">⭐️操作系统如何申请和管理内存的？</h3><p id="e4157427-4068-4383-a84a-4ab150615c4b" class="">
</p><h3 id="4eeb8e1d-1f1f-406d-8d07-2fda212c1a45" class="">操作系统的内存管理？</h3><p id="2bd12d94-e7d1-445c-8a91-17ea8e3d2188" class="">内存管理分为<strong>连续内存管理</strong>和<strong>非连续内存管理</strong>，<span style="border-bottom:0.05em solid">当前的操作系统普遍采用非连续内存管理？？？</span>。</p><ul id="37389370-8094-48d8-9883-a5220e2e1534" class="bulleted-list"><li><strong>连续内存管理</strong><p id="f22e625d-bb2a-4608-a230-c9c9ac87a5b2" class="">一个内存中如果有多个进程：操作系统所占的空间是固定的，用户程序空间需要通过分区来分给多个进程。</p><ul id="725e1aa5-7c54-42f0-aadb-43a057e42772" class="bulleted-list"><li>静态分区分配 —— 分区大小相等或分区大小不等</li></ul><ul id="42d990ec-afdb-4f00-9484-fa60e1a89c21" class="bulleted-list"><li>动态分区分配 —— 动态分区分配算法</li></ul></li></ul><ul id="ed5c4a2c-6a92-4016-b2cd-28104c0c5cd3" class="bulleted-list"><li><strong>非连续内存管理</strong><ul id="bc7dbfd3-6ad7-4ac3-bca0-0637e8e68120" class="bulleted-list"><li>段式管理</li></ul><ul id="b9bd35e0-9d26-4c68-adc2-0838b5f8beea" class="bulleted-list"><li>页式管理 —— 逻辑地址到物理地址的转换</li></ul><p id="a14240db-b106-4fdf-8d33-90e4ebc6f43d" class="">它们都是<mark class="highlight-red"><strong>离散存储</strong></mark>。</p></li></ul><p id="c1b883b9-378e-45c8-814d-8b564839f217" class="">个人理解：emmm，连续内存管理出现在为新调入的进程分配内存的时候，而页式出现在虚拟地址到物理内存的映射的时候？</p><p id="2f3d06e4-c1d0-46c6-b08c-a3beba5025b5" class="">
</p><h3 id="502a0a7c-05f0-4d4c-9b49-4c7ea4431924" class="">内存分配?</h3><p id="273de6d8-d5ba-40dd-8738-dff1e5b2bb32" class="">感觉应该答静态分区分配和动态分区分配啊。</p><p id="f3add5aa-37d0-4bd1-b7ca-4779096fda67" class="">常见的内存分配方式：</p><ul id="68c0eff5-5308-4295-bae4-255b6419dd73" class="bulleted-list"><li>从静态存储区域分配<p id="b39d76fc-25a8-4809-b144-5271018e45bb" class="">内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。如：全局变量，static变量。</p></li></ul><ul id="72a7d10c-6211-426a-8184-cfc109b01799" class="bulleted-list"><li>在栈上创建<p id="823db446-3929-49b7-973e-18c742b0eb21" class="">在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这 些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有 限。</p></li></ul><ul id="8b493a62-9d06-4f86-838c-81b53ed89144" class="bulleted-list"><li>从堆上分配——动态内存分配<p id="3e318aaf-361f-491a-9652-975f23b9e079" class="">程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也 最多。</p></li></ul><p id="604c3128-ebc7-4878-bc4a-7f1fa386f57e" class="">
</p><h3 id="ced54ddc-4fdf-4072-8a16-4902699d9f5f" class="">动态分区分配算法有哪些？</h3><p id="5e1ca3f1-4d46-492e-87ee-4ce036bd3ede" class="">出现在用户级的内存分配库（malloc()），或操作系统用分段方式实现虚拟内存时。</p><p id="26b8b814-9f92-4995-b3cf-a1a04e63338c" class=""><span style="border-bottom:0.05em solid">属于连续内存管理方式。</span></p><p id="68c38d2c-2658-4ecc-b7d1-29e5ae07e044" class="">动态分区分配不预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区。</p><ul id="c516a891-0ec7-4d68-8a71-d3f239b8fd7a" class="bulleted-list"><li>首次适应算法</li></ul><ul id="4d48ab05-cfff-4229-a7b7-dc471a670fa9" class="bulleted-list"><li>最佳适应算法</li></ul><ul id="767fa213-f312-4c57-8674-8b592d594846" class="bulleted-list"><li>最坏适应算法</li></ul><ul id="cc2c7c22-21d9-4eed-ad93-8f4d6f041a96" class="bulleted-list"><li>邻近适应算法</li></ul><figure id="29d40efb-6b6c-40fc-ad35-aa2031df2515" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%208.png"><img style="width:1316px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%208.png"/></a></figure><p id="46c8a320-b8a9-4ed8-98ae-664aa8700c63" class="">
</p><h3 id="f4fd562b-95e6-4fd0-9752-3f95749984d7" class="">段式存储管理</h3><p id="7eec37ca-04ec-48aa-90ba-a78b5bb579af" class="">在段式存储管理中，将程序的地址空间按自身的逻辑关系划分为若干个段(segment)，每个段都有一个段名，每段从0开始编址。这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。</p><p id="12ac6361-469e-4cff-af19-53321a6222c7" class="">优点：</p><ul id="9909d263-f0d9-4554-b026-4eba52e880b8" class="bulleted-list"><li><strong>没有内碎片，外碎片可以通过内存紧缩来消除</strong></li></ul><ul id="813d973a-b428-4d5c-830a-d5adee051f12" class="bulleted-list"><li>便于实现内存共享</li></ul><p id="12990653-99e3-4f22-9c51-774a5f890f37" class="">缺点：</p><ul id="5dd8d4e2-9182-401c-9aba-c4b479be5b2d" class="bulleted-list"><li>进程必须全部装入内存</li></ul><ul id="98752e79-ccf0-4f2d-bb7d-d1568e87ec68" class="bulleted-list"><li>外碎片问题</li></ul><ul id="dfb07d5e-7ea8-4a89-9149-564907b10af1" class="bulleted-list"><li>内存交换的效率低</li></ul><h3 id="8cb82442-9282-498b-932f-727608e02404" class="">页式存储管理</h3><p id="1c3048fd-2636-4047-98b3-cb7ee5718cc0" class="">将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。</p><p id="db0871a3-6175-4711-b2e9-343e64da3a19" class="">程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p><p id="02702176-02b0-4a37-9dc7-d360aa83d186" class="">优点：</p><ul id="ca2e1abf-e468-4c8f-b804-7906d50293d6" class="bulleted-list"><li>一个程序不必连续存放</li></ul><ul id="ac8cc23e-9b49-4f2a-ab8d-c2045bdd3aa4" class="bulleted-list"><li><strong>没有外碎片，每个内碎片不超过页面大小</strong></li></ul><ul id="0ab41afc-97b5-4f34-802d-08a7a1ef665b" class="bulleted-list"><li>便于改变程序占用空间的大小</li></ul><p id="9e9ccd4b-bc43-4514-9a04-b2c7f13f88d4" class="">缺点：</p><ul id="8f92e205-6602-4b69-a0c8-8a18c36f7bc9" class="bulleted-list"><li>要求程序全部装入内存，没有足够的内存，程序就不能执行</li></ul><p id="354340ee-240d-405c-a7ee-89b3f6e0951f" class="">
</p><h3 id="ab59d5fc-7a2b-4d6a-a05b-8fa300b394b0" class="">段页式内存管理？</h3><p id="ba6490b5-d2a7-4b89-9a20-47f80bf629ef" class="">内存分段和内存分页并不对立，可以组合起来在同一个系统中使用，称为段页式内存管理。</p><p id="14a6fe98-49cc-4495-9b50-95b6cf8c2d23" class="">实现方式：首先将程序划分为多个有逻辑意义的段，也就是前面提到的分段；再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页。</p><figure id="257386c2-cfc3-44a7-9680-96531e5fa770" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%209.png"><img style="width:432px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%209.png"/></a></figure><p id="e6507cdf-4687-4cab-b70c-2f13ac866a03" class="">需要三次访存：</p><ol id="c30c3efe-ca71-42f4-b470-d9be936d4193" class="numbered-list" start="1"><li>访问段表，得到页表起始地址</li></ol><ol id="96e6edfc-946c-4181-848b-5aa54450d89a" class="numbered-list" start="2"><li>访问页表，得到物理页号</li></ol><ol id="91cdcf88-07c0-4015-9322-41bf5f934df1" class="numbered-list" start="3"><li>将物理页号和段内偏移组合，得到物理地址</li></ol><p id="54603788-bfd8-4912-9b0f-5d6c4ecfaa22" class="">
</p><p id="f80ac5ac-2359-4ffc-84d0-7028414ba7be" class="">
</p><h3 id="2480ba46-eeb6-44cd-8395-d7a9b0ed5f56" class="">说一下内存碎片？内部碎片和外部碎片？</h3><p id="211698b1-33ec-4539-8400-dfaff4895d5e" class=""><strong>内部碎片：</strong><div class="indented"><p id="368de557-6a12-4876-9701-a1126fd2f3d5" class="">分配给某进程的内存区域中，有些部分没有用上。</p><p id="c4b21f81-d4d9-44c7-bc35-05f783369947" class=""><span style="border-bottom:0.05em solid">常见于连续内存管理中的固定分配方式。或非连续内存管理中的分页管理？</span></p></div></p><p id="8e75a57e-8ec8-4ae5-8761-8a3cce27568c" class=""><strong>外部碎片：</strong><div class="indented"><p id="7fa0cbf7-34cd-4b84-a83a-213acef10507" class="">内存中的某些空闲分区由于太小，难以利用。</p><p id="86455ef0-5b77-489a-9264-10128aca3379" class=""><span style="border-bottom:0.05em solid">常见于连续内存管理中的动态分配方式。或非连续内存管理中的分段管理？</span></p></div></p><p id="32c9f5d4-2634-4027-9d8b-4125c8b5a990" class="">
</p><h3 id="cf93cb09-417d-4cd6-9e0a-ed54b0639e42" class="">如何消除碎片文件？</h3><ul id="9d6ec2a0-b97f-4794-a073-152aa29fba1b" class="bulleted-list"><li>紧凑技术（内存紧锁）<p id="f377327b-a1c3-4484-a8e2-fafe0192ab26" class="">操作系统不时地对进程进行移动和整理：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。需要动态重定位寄存器的支持，且相对费时。</p></li></ul><ul id="ef4694eb-4a62-4f14-893f-884f6c916088" class="bulleted-list"><li>内存交换<p id="486519cb-2739-498f-98b9-3c4d22b6cc25" class="">把某个进程先交换出去，再从硬盘上读回来到内存里，不过不是装载到原来的位置，而是紧紧跟着已经被占用的512M内存后面。</p></li></ul><p id="9683c3a6-0147-4275-b57f-11a9f6574545" class="">
</p><p id="aa6c2fba-6362-4036-84af-4b0e73d3ba45" class="">
</p><p id="5477d2b1-86fe-4b6e-a08d-fb76f55a4271" class="">
</p><h2 id="689d59fd-6249-433c-aefc-2b07d45c909c" class="">——<strong>进程的内存管理</strong></h2><h3 id="8b218b99-45dd-4b0d-ad68-6e6d02869b41" class="">进程的内存管理？</h3><p id="56192700-e8a1-4198-914f-e4862674b23b" class="">操作系统会给每个进程分配虚拟地址，虚拟地址的大小与处理器的位数有关，如32位处理器进程可分配4GB的虚拟内存供程序正常运行。</p><p id="5c2d1154-0add-4f27-9e0f-ece59f5595d2" class="">分区详见下一问。</p><p id="0879c483-be91-4443-93eb-c65c01b2766e" class="">
</p><h3 id="9eb560c4-7620-45fa-ac85-87196e3cecc8" class="">⭐️内存分布情况？（进程的虚拟地址空间分布）</h3><figure id="3ab604a3-2f41-48ac-8514-a6d935847460" class="image"><a href="../C++%203513a0f1f8cd4110b7553b6d1b1047f9/neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled%201.png"><img style="width:240px" src="../C++%203513a0f1f8cd4110b7553b6d1b1047f9/neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled%201.png"/></a></figure><p id="11b206b6-ef24-449e-a39f-01ec0f3695a2" class="">
</p><ul id="e71fa04a-4a4e-4c9e-b136-71ca57e61881" class="bulleted-list"><li>程序文件段，包括二进制可执行代码</li></ul><ul id="398b02c3-d328-427f-a94d-15594dded0c4" class="bulleted-list"><li>已初始化数据段，包括静态常量</li></ul><ul id="9b463ec0-bb26-44ea-b53c-b5937f784bcb" class="bulleted-list"><li>未初始化数据段，包括未初始化的静态变量</li></ul><ul id="92cd4dc4-448e-425c-93a8-13fe1a927e38" class="bulleted-list"><li>堆段，包括动态分配的内存，从低地址开始向上增长</li></ul><ul id="56ade39b-7bdd-4663-8242-8dd3cf1c7d26" class="bulleted-list"><li>文件映射段，包括动态库、共享内存等</li></ul><ul id="a2a123f6-fe35-424f-9a9b-811f5d261154" class="bulleted-list"><li>栈段，包括局部变量和函数调用的上下文等，从高地址向下增长。Linux下栈的大小是固定的，一般是8MB，也可以自定义。</li></ul><p id="1344b68d-d4a7-4ac5-8bf7-1e7df588de39" class="">
</p><h3 id="b5f0e19c-973a-42b7-9aaf-d34b8faa679f" class="">一个由C/C++编译的程序占用的内存分为哪几个部分？</h3><ul id="387a0d99-3090-4db4-b1c7-d9bf171c64f4" class="bulleted-list"><li>栈区（stack）：地址向下增长，存放局部变量、函数调用的上下文等（包括函数参数），<span style="border-bottom:0.05em solid">由编译器自动分配释放。</span></li></ul><ul id="89caa464-5621-4407-9535-9c2506809401" class="bulleted-list"><li>堆区（heap）：地址向上增长，一般<span style="border-bottom:0.05em solid">由程序员分配释放</span>，若程序员不释放，程序结束时可能由OS回收。<mark class="highlight-red"><strong>与数据结构中的堆是两回事，分配方式类似于链表。</strong></mark></li></ul><ul id="572bf903-c0b6-4f75-bb51-9344e2208c31" class="bulleted-list"><li>全局区（静态区）（static）<p id="121ba373-b244-4d46-b447-2eb2f3731436" class="">存放全局变量和静态变量。<span style="border-bottom:0.05em solid">初始化的</span>全局变量和静态变量在一块区域，<span style="border-bottom:0.05em solid">未初始化的</span>在相邻的另一块区域。</p></li></ul><ul id="25dd9f9c-fc6e-4fe7-9014-1aebf433b8b9" class="bulleted-list"><li>文字常量区<p id="6ac57568-c8e8-478e-8321-6b24876ae3d0" class="">常量字符串放在这里，程序结束后由系统释放。</p></li></ul><ul id="96bd1f47-9ff9-4a0b-acdf-d20764db13e0" class="bulleted-list"><li>程序代码区（text）<p id="703c602f-1f9a-4338-bded-7852aa39832a" class="">存放函数体的二进制代码。</p></li></ul><p id="11ca6c3e-214c-42ab-a4b4-58ae4facaefd" class="">
</p><h3 id="0700bb3b-3a10-44e6-8b80-4bd2e0526eac" class="">⭐️堆和栈的区别？</h3><p id="dcd5be09-6c5d-4f29-97d1-a5b7dd792f83" class="">主要的区别由以下几点：</p><p id="628dcb60-7d7c-4958-82c1-0718452b7ebe" class="">(1). 管理方式不同</p><p id="494d5cf3-06e5-4a9d-85d2-d7b555937aa8" class="">(2). 空间大小不同</p><p id="a706e0ab-6460-4a78-b025-60c29a2500e8" class="">(3). 能否产生碎片不同</p><p id="ff2d37ed-2eaf-44bd-b4b4-85025d93befb" class="">(4). 生长方向不同</p><p id="bb474f5c-b617-47ab-a8c9-a699b745813e" class="">(5). 分配方式不同</p><p id="7413c121-0158-468e-b8fb-e8fd34163935" class="">(6). 分配效率不同</p><p id="dd8ade36-df0e-405b-a70e-9e14480679c3" class=""><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生 <code>memory leak</code>。</p><p id="c3ef6887-7248-44ae-ae81-5aca083cc523" class=""><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改。</p><p id="3b5e4838-7981-431b-8b37-a7b370dc77b4" class=""><strong>碎片问题</strong>：对于堆来讲，频繁的 <code>new/delete</code> 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p><p id="6a12d64e-baa8-494e-9eb6-07db5e4647b0" class=""><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p id="5d6fa3d1-87a0-4f23-a778-7922d6b94ecd" class=""><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 <code>alloca</code> 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p id="81aee312-75f7-48a9-aeb5-9c041bdfc4b0" class=""><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p id="b731379c-89d6-48e5-b5b7-4523d8fe62c7" class="">从这里我们可以看到，堆和栈相比，由于大量 <code>new/delete</code> 的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><p id="d95d625a-9121-4372-b770-05f7a031b582" class="">虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p><p id="d366821a-9e8a-43bd-b2d0-eb8316faf8d2" class="">
</p><p id="00e8af45-ac0c-49f7-b9d6-b6f4e2fcc1d4" class="">
</p><h3 id="a7e38d14-6b11-4b88-b290-6a391ec1406e" class="">Linux/Windows平台下栈空间的大小？</h3><p id="4882c82a-06e9-4096-bf99-605ca02e1f1d" class="">Linux下<span style="border-bottom:0.05em solid">由操作系统决定</span>，一般是8MB，可通过ulimit查看和修改</p><p id="cdf4c6b0-6b11-489b-8dae-b8c2995f68b4" class="">Windows下<span style="border-bottom:0.05em solid">由编译器决定</span>，VC++6.0一般是1M</p><p id="a1eba8bf-edba-44e0-809a-cf5ba43bccc5" class="">
</p><h3 id="2cae658f-6c5f-40a7-8ec1-879c35d2b78d" class="">程序从堆中动态分配内存时，虚拟内存上怎么操作？</h3><p id="4d4d1bb6-d966-46cd-91fc-6113377335b0" class="">操作系统在硬盘上创建或申请一段虚拟内存空间，并更新到<span style="border-bottom:0.05em solid">页表</span>（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。</p><p id="5165a611-6521-4b57-97f2-e41e9e554e05" class="">页表是存放在物理内存中数据结构，记录了虚拟页与物理页的映射关系。</p><p id="f647cfd1-cbfe-4eee-8946-c794e26343e5" class="">
</p><h3 id="024a0f13-33d1-4b4d-bcdc-fece544fb0db" class="">从堆和栈上建立对象哪个快？</h3><p id="c24fc0d4-a558-4f3f-b564-76bbca61ba66" class="">栈快</p><ul id="40692f50-b8dc-4328-9987-e331fc936c1e" class="bulleted-list"><li>分配和释放</li></ul><ul id="e3e03076-39d9-481b-9e10-8ecf0bfc0485" class="bulleted-list"><li>访问时间<p id="318e7983-04d8-4d46-b982-d196ac66f624" class="">访问堆的一个具体单元，需要两次访存，第一次取得指针，第二次才是真正的数据；栈只需要一次。且堆的内容被操作系统交换到外存的概率比栈大。</p></li></ul><p id="6c5aa633-e0d0-48f0-9859-3d2f2d4fe1e0" class="">
</p><p id="86102888-da8c-4eae-8afb-2902d4a39e38" class="">
</p><h3 id="f4c38072-5582-43b1-9f16-efa42d0240a8" class="">为什么堆有内存碎片，而栈没有？</h3><p id="74a4c310-ede3-43be-9e0a-d45ea99f8275" class="">
</p><p id="f9cbb689-f3bb-4f10-bbb1-0128f6ed7d47" class="">
</p><h2 id="0a7596a8-bd11-4064-8d41-b00fab1bf8f1" class="">其它</h2><h3 id="c1df6147-2128-4d64-a9b6-3a16c5691f21" class="">操作系统在做内存管理的时候，有哪些内存管理的算法？</h3><p id="5b26134f-bbe7-4631-b6a3-792b5b4dba9d" class="">动态内存分配算法和页面置换算法？</p><p id="ae3b72da-eeab-4df1-8a19-8e10607e187b" class="">
</p><p id="e7b858b4-f941-425b-bd7c-68791b79a460" class="">
</p><h3 id="7518228d-81a0-4b6b-8ee7-7611a255db9c" class="">内存池是什么？为什么要有内存池？如何设计一个内存池？</h3><p id="7cd7ef45-ca86-491b-ba7a-a00e196f2068" class=""><strong>定义</strong></p><p id="d9aa17d8-8b7a-40af-b40a-34d887c48c39" class="">应用程序可以通过系统的内存分配调用预先一次性申请适当大小的内存作为一个内存池，之后应用程序自己对内存的分配和释放则可以通过这个内存池来完成。只有当内存池大小需要动态扩展时，才需要再调用系统的内存分配函数，其他时间对内存的一切操作都在应用程序的掌控之中。</p><p id="6797ee69-8647-42b1-b9a5-e972ff03df0e" class=""><strong>为什么要有内存池？</strong></p><p id="a891a48f-2119-4b43-8283-e2ca6cc229f6" class="">直接使用系统调用malloc/free、new/delete进行内存分配和释放，有以下弊端：</p><ol id="470f6cc4-3ce2-42c4-b1ad-a3a4393d04a1" class="numbered-list" start="1"><li>调用malloc/new,系统需要根据“最先匹配”、“最优匹配”或其他算法在内存空闲块表中查找一块空闲内存，调用free/delete,系统可能需要合并空闲内存块，这些会产生额外开销</li></ol><ol id="d690d3c1-2e0c-4053-b6d3-4237cb581890" class="numbered-list" start="2"><li>频繁使用时会产生大量内存碎片，从而降低程序运行效率</li></ol><ol id="d621f04e-22e4-48c6-986a-d73ef578b625" class="numbered-list" start="3"><li>容易造成内存泄漏</li></ol><p id="db800495-15fe-45e8-8f39-85f3cdb3ee11" class="">
</p><p id="e034bc0e-deb5-4486-b318-857f15301fa8" class="">
</p><p id="b5924df5-5656-4045-a251-f02e34f58647" class="">
</p><p id="2dad824e-107a-4269-aff6-0ad4aa1b7fad" class="">
</p><h3 id="2d638bd5-385a-43de-a13f-1ae34c39dda2" class="">简述 CPU L1, L2, L3 多级缓存的基本作用</h3><p id="605faa34-1ad4-4138-b574-ab57c1fd95ac" class="">高速缓存SRAM（静态RAM），内存DRAM（动态RAM）</p><p id="60ab536b-591a-4592-87a7-4859e04dd20b" class="">都是集成在CPU内的缓存，缓存级别：L1、L2、L3，根据缓存速度来划分</p><figure id="a86d6836-eab2-474e-ad49-4a398f2e1d99" class="image"><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%2010.png"><img style="width:716px" src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20f9e9499f59a74496bd55875a09c48049/Untitled%2010.png"/></a></figure><p id="01cee4f8-7318-4600-908e-40f219a5a436" class="">L1、L2、L3大小增加，速度递减。</p><p id="96edb94a-f6eb-42f7-bb49-94ee96b81a82" class="">二级缓存就是一级缓存的缓冲器：一级缓存<strong>制造成本很高因此它的容量有限</strong>，二级缓存的作用就是存储那些CPU处理时需要用到、一级缓存又无法存储的数据。同样道理，三级缓存和内存可以看作是二级缓存的缓冲器，它们的容量递增，但单位制造成本却递减。需要注意的是，无论是二级缓存、三级缓存还是内存都不能存储处理器操作的原始指令，这些指令只能存储在CPU的一级指令缓存中，而余下的二级缓存、三级缓存和内存仅用于存储CPU所需数据。</p><p id="7a18a28a-8615-4846-bd2f-3a2ed19bcfef" class="">一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取</p><p id="f4ed90c8-ce6e-4464-a73c-43d40d1acc32" class="">
</p><p id="462733cf-005d-435a-b80f-21fe5e280084" class="">
</p><p id="c82e3848-f5e0-457b-9763-7672392cdead" class="">
</p><p id="22c78cc8-8d8f-4dd2-86ad-ba40df3c2e78" class="">
</p><p id="e81def56-0815-4deb-8780-6b1b322fffca" class="">
</p><h2 id="3db5f0c2-47ff-45e2-9191-ea30a9c2833a" class="">总结</h2><ul id="b8885ae3-b709-494b-8341-71b922c369fd" class="bulleted-list"><li>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套的虚拟地址空间，每个程序只关系自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。</li></ul><ul id="14cca3ef-6a79-4349-b549-965c5f4a3a9d" class="bulleted-list"><li>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。</li></ul><ul id="a2087d24-cf7c-4fd8-be5a-222f237d18cf" class="bulleted-list"><li>那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。</li></ul><ul id="fa0de664-9585-48d4-ba59-62063e393a82" class="bulleted-list"><li>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据端、代码段等（这是以前的操作系统了？），这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。</li></ul><ul id="46a2383b-45ac-44ac-8577-d7a4f8baf779" class="bulleted-list"><li>于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘就一个页或几个页，这就大大提高内存交换的效率。</li></ul><ul id="4f98e175-1974-43fc-8e96-de1745001c09" class="bulleted-list"><li>为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</li></ul><ul id="b0892e8c-970b-4cd4-8df3-9609fcb50eb5" class="bulleted-list"><li><span style="border-bottom:0.05em solid">Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所面程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。（现代操作系统并不想使用从16位系统遗留下来的分段机制，而CPU为了保持兼容性还保留了这些分段机制，所以现代OS大都使用这种扁平式的分段管理，将CPU「糊弄」过去。）</span></li></ul><ul id="79e00fde-13b8-4d74-a1b6-2839dfbcde51" class="bulleted-list"><li>另外，Linux 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。</li></ul></div></article></body></html>