<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>进程线程</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="430885c0-6763-4aae-97e6-21ffe1e6ef7e" class="page sans"><header><h1 class="page-title">进程线程</h1></header><div class="page-body"><hr id="9a4f690e-2167-4c51-8753-e799348d9c38"/><p id="6a6354f8-882a-4512-8b71-2374fd37ce34" class="">
</p><nav id="bdb5e35c-b01f-4276-ba8c-d3f30639bdb4" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#80c24b24-4e7e-4d1c-8525-8117d84c08f4">进程、线程比较</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2f01a97f-3d00-47ff-b757-795952542f93">⭐️进程、线程、协程三者的区别？多线程多进程使用场景？协程使用场景？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#00e9ab83-dcae-46df-9139-c204b0e14f56">为什么有了进程还要有线程？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#362adbd7-e1ce-4d2e-b9ef-a20676d79e62">⭐️进程线程切换的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2f9ae6fa-295f-47ae-bd98-1865f076475e">对并发和并行的理解？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3adfaa10-82b7-42b6-8d2a-698f3da5e8fe">进程</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8a828be2-e54d-4427-8e1f-b293ca41e542">⭐️进程状态的切换？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c4889838-9cf8-4ab7-889f-021a92e4abda">⭐️进程间的通信方式？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#199e21f6-6dfc-4595-b4a4-0fee4b38001d">❓管道实现原理是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#30ee6812-8623-48c3-9ead-75eac3c49987">父进程、子进程、进程组、作业和会话？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f56a9767-1cec-4be7-abaa-450de94d0b19">进程和程序的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b11d2621-4ce2-4652-82eb-57683110623f">进程结构？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0da5fd6e-780c-417d-b330-afe7fe6c5790">子进程从父进程继承了什么？独有什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#57616baf-0a34-4ae2-8b00-2f4b650ba04f">Linux中如何创建进程？如何判断是父进程还是子进程？进程创建成功返回什么？如果返回不为0就一定失败吗？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#98bfc194-708d-445d-b70a-3662094386dd">孤儿进程 ？守护进程？守护进程 与后台进程区别 nohup吗？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8b1de861-58f4-4405-aa10-9b2f618ef93a">如何创建一个守护进程？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0b7002d0-0de7-4cdf-8e78-077bea93f48d">⭐️僵尸进程是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#020430c2-23af-44fb-bf3c-b04ea98f03ee">如何避免僵尸进程？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#915c9054-4a12-4eff-a2fe-d4ee87299f22">进程终止的几种方式？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#801dcd5e-4161-4eef-8a46-52f634295d4d">⭐️Linux进程调度方法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1b57ccd9-12fa-4032-8260-457d29e80195">进程阻塞和挂起的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2ddd3dee-b9dd-4705-a1c9-1123252d0d70">线程</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c5d7f772-02e1-4dc4-babe-e5b63670f779">一个进程可以创建多少线程？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1879bbb9-34a8-4548-88ca-f639fbf85558">linux系统下线程是怎么实现的？创建线程有多少种方式？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bdc0b608-08e5-4eaf-9376-babb07879457">什么是多线程模型？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#29ef48c9-57ad-46a0-8c66-ef4b4e93caf9">⭐️线程共享和独有的资源？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b951c03a-4755-4f21-8494-62aca34e4a64">线程池怎么实现的？说一下线程池的参数？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#994660c2-4b6c-47c2-bea1-dde034621d2f">怎样保证线程安全，各个实现方法有什么区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1e357b4a-f224-4901-9c13-d4e2494cd9c6">多线程如何使用智能指针？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#804e6905-69d1-4c87-bfe0-ac60acf4f93a">线程间通信的方法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7df251e7-1dc5-41d5-b720-d4391002ae9d">⭐️有哪些多线程同步的方法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ed2182d5-75f2-444c-b5e2-f73666d2dfcc">⭐️线程有多少种状态，状态之间如何转换？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0c0d9154-78f8-4230-80bd-efe6686007d4">怎么回收线程？有哪几种方法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f4cc220c-d856-4331-92f6-37736c1ebc2f">⭐️sleep和wait的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#52b8a4e3-777c-4e18-b7a0-1b496c884128">IO密集型和CPU密集型？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e992aa12-d4e3-4e08-a1cc-6d140a3b3ade">手写三个线程交替打印一个共享变量</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#207d9048-1242-4deb-87f1-599c7f1aa380">锁、死锁</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a9726995-821c-4094-b051-de5054428b77">⭐️死锁的原因、条件和避免死锁的方法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d429f6fb-e595-4451-8c59-a6a1ce145f29">死锁检测算法</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d35992db-d911-40d3-b345-f33af928449d">银行家算法描述？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#78379aee-d9c0-4a46-847a-3619c2c42d1f">找到造成死锁的进程怎么处理（杀死，抢占，回滚），❓回滚如何实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b838a30e-1817-467e-9a07-b6a54b6f107d">介绍一下几种典型的锁</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2886c571-8cba-4f21-9aa2-767a92fae3f9">⭐️简述自旋锁与互斥锁的使用场景</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#57d9048d-7c2b-4b89-bfa9-ace512c00924">乐观锁、悲观锁？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0ed24b3c-5d33-4d64-8d8f-dde1f5d51a0d">多线程队列实现（读写锁 || 条件变量和互斥量）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bf103fc4-dbef-4277-987c-1d58757649aa">自旋锁的实现</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#484098c3-4fb0-46e6-a919-476539c2a6be">❓无锁编程了解吗？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f12ed70d-b88a-4764-a785-383dc18d9832">能不能用无锁的方式来实现共享内存之间的同步？具体的解决方法描述一下？如果大家同时取的版本号都一样呢？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6dd7a58d-7d05-49e7-96dc-6a2931a918e7">多进程如何对共享内存进行加锁（互斥锁），有没有性能更高的？（读写锁？）</a></div></nav><p id="a624ff7a-777d-4c53-8b6f-ddfc33430164" class="">
</p><h2 id="80c24b24-4e7e-4d1c-8525-8117d84c08f4" class="">进程、线程比较</h2><h3 id="2f01a97f-3d00-47ff-b757-795952542f93" class="">⭐️进程、线程、协程三者的区别？多线程多进程使用场景？协程使用场景？</h3><p id="0d796616-70c3-4f50-b94f-a87709b63e18" class=""><strong>概念：</strong></p><ul id="c366ad74-7bd8-43fd-a6fb-2513a49f5245" class="bulleted-list"><li>进程：是系统进行<strong>资源分配</strong><del>和调度</del>的基本单位，是系统中并发执行的单位。</li></ul><ul id="6819d2b6-ff33-4b2d-add6-a9e993a05466" class="bulleted-list"><li>线程：是进程的一个实体，也是CPU<strong>调度</strong>和分派的基本单位，是比进程更小的能独立运行的基本单位。</li></ul><ul id="c395fb1b-4065-404c-914c-07424255f9c9" class="bulleted-list"><li>协程：协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</li></ul><p id="f904c8fb-b843-470c-904c-488bfebde483" class="">不同进程地址空间相互独立，有自己的堆，<mark class="highlight-red"><strong>同一进程内的线程共享同一地址空间</strong></mark>。一个进程的线程在另一个进程不可见。</p><p id="8d5d27d8-89da-46d8-b30c-4daeeaea0f27" class="">这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p id="b943f72f-6cd0-42c4-8dc2-4c5d2110000b" class=""><strong>区别：</strong></p><ul id="be074719-6561-4f04-831b-a4af462de79c" class="bulleted-list"><li>线程不能独立执行，必须依存于进程，线程是更加轻量级的，划分尺度小于进程</li></ul><ul id="a61754ec-bc45-4f85-a696-8eeadb366663" class="bulleted-list"><li>资源：进程是<strong>资源分配的基本单位</strong>，但是线程不拥有资源，线程可以访问隶属于进程的资源。属于同一进程的所有线程都具有相同的地址空间。属于同一进程的线程，堆是共享的，栈是私有的。</li></ul><ul id="59d8864e-4c00-4237-96df-dc49d9b3639d" class="bulleted-list"><li>调度：线程是<strong>独立调度的基本单位</strong>，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li></ul><ul id="483edec3-bcca-4c49-8e43-7edfc56ddf6c" class="bulleted-list"><li>开销：由于创建或撤销进程时，系统都要为之<strong>分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销</strong>。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li></ul><ul id="04a8b443-32e5-47cc-8f04-c11a972d383f" class="bulleted-list"><li>通信：线程间可以通过直接读写同一进程中的数据进行通信，而进程通信需要借助IPC。</li></ul><p id="e02cda41-7f80-483b-9628-79c24961c3cb" class=""><strong>优点比较：</strong></p><ul id="66a63b92-6c32-49e9-99f2-1cb0becce365" class="bulleted-list"><li>多进程的优点：<ul id="72e4e6e1-4cef-44b5-b8de-f85579afa06c" class="bulleted-list"><li>编程相对容易</li></ul><ul id="f0f04c07-66a0-40f2-924f-5e4313734773" class="bulleted-list"><li>更强的容错性：一个进程崩溃了不会影响其他进程</li></ul><ul id="246dbfdd-2213-41a6-8240-3e67ffddf05b" class="bulleted-list"><li>有内核保证的隔离：数据和错误隔离。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）。</li></ul></li></ul><ul id="e43c2f5c-5d6f-45ed-acd0-890bb5775adb" class="bulleted-list"><li>多线程的优点：<ul id="cb34eefd-49dc-4e9e-ba10-0588131f57ad" class="bulleted-list"><li>创建速度快，更加高效的数据共享（内存共享）</li></ul><ul id="edd39eff-6038-413e-9358-aa8cd8666433" class="bulleted-list"><li>较轻的上下文切换开销：不用切换地址空间，不用更改寄存器，不用刷新TLB。</li></ul><ul id="77e5ec6e-c86e-4733-abd5-40554634801c" class="bulleted-list"><li>提供非均质的服务：如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。</li></ul></li></ul><ul id="722b9394-a993-4e94-b41a-2dce6d53ffc5" class="bulleted-list"><li>协程的优点：<ul id="b85574ae-ba64-4ade-9992-8630819cda02" class="bulleted-list"><li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li></ul><ul id="611421a4-5b0b-45e8-bb96-b78cdb292f52" class="bulleted-list"><li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul></li></ul><p id="26efd710-eef7-47ba-82c1-c72cc8f0907d" class=""><strong>使用场景：</strong></p><ul id="69036c8a-eb4e-4028-9848-a65afa306aee" class="bulleted-list"><li>多进程<ul id="a61a23ee-7e68-439a-a723-4c85d3ba066b" class="bulleted-list"><li>nginx主流的工作模式是多进程模式（也支持多线程模型） </li></ul><ul id="7d8c0d60-f014-473b-b288-edba913abd04" class="bulleted-list"><li>几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，例如apached,httpd等等以d结尾的进程包括init.d本身就是0级总进程，所有你认知的进程都是它的子进程； </li></ul><ul id="5e539d87-a788-4d90-8bea-ed2d0755a045" class="bulleted-list"><li>chrome浏览器也是多进程方式。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。②网页之间互相隔离，保证安全，不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。）</li></ul><ul id="f0418bd5-8576-4b37-a921-aea6344bc0f9" class="bulleted-list"><li>redis也可以归类到“多进程单线程”模型（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）</li></ul></li></ul><ul id="296538d6-d04e-498b-8255-82dc5e834778" class="bulleted-list"><li>多线程<ul id="9b6b257f-cf47-448d-988b-6792308278e5" class="bulleted-list"><li>线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）。</li></ul><ul id="73a842b7-2672-492a-952d-eb2b8647188b" class="bulleted-list"><li>提供非均质的服务（有优先级任务处理）事件响应有优先级。</li></ul><ul id="f38f89aa-457d-4ac4-9ec3-e13c5e706298" class="bulleted-list"><li>单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延。</li></ul><ul id="081b4eb9-e3e7-4cc8-88c8-f30790ecc593" class="bulleted-list"><li>与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）
案例：桌面软件，响应用户输入的是一个线程，后台程序处理是另外的线程； memcached</li></ul></li></ul><ul id="bcf2a0e2-0485-409d-b42f-ede414ec2015" class="bulleted-list"><li>协程<ul id="9d3bda75-9704-45aa-950f-0982ab8c154f" class="bulleted-list"><li>用同步的方式完成回调函数的工作（用同步的方式写异步的代码？）</li></ul><ul id="591ac5fe-e7de-41ec-abe6-187bee731176" class="bulleted-list"><li>系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。这时可以用协程，当出现长时间的I/O操作时，让出目前的协程调度，执行下一个任务。</li></ul></li></ul><p id="65330958-da39-4973-b5d9-66dd4cb030e8" class=""><strong>选什么：</strong></p><ul id="0d343191-7b40-480c-bf9f-e0d26cd354eb" class="bulleted-list"><li>需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大），如Web服务器</li></ul><ul id="62f1fd19-b03c-4aa9-9dc2-ff3d750bebef" class="bulleted-list"><li>需要进行大量计算的优先使用线程（CPU频繁切换）</li></ul><ul id="f7b190de-8a68-4a92-b941-d8830ed2ee71" class="bulleted-list"><li>强相关的处理用线程，弱相关的处理用进程</li></ul><ul id="3326218c-8239-4771-a293-3ff1386212b2" class="bulleted-list"><li>可能要扩展到多机分布的用进程，多核分布的用线程</li></ul><p id="909bc2bf-f4f2-4dd8-959c-dad6e4c5b75d" class="">
</p><h3 id="00e9ab83-dcae-46df-9139-c204b0e14f56" class="">为什么有了进程还要有线程？</h3><ul id="397f7885-d70d-456d-8c25-e294f8cf04cf" class="bulleted-list"><li>进程运行环境的切换开销大</li></ul><ul id="b242d471-d1e1-4c34-984d-61b8090144f2" class="bulleted-list"><li>使同一个进程同一时间也能做多件事情，提高了并发度。</li></ul><p id="672a3bb3-59d0-4beb-abbd-440b0f860db7" class="">
</p><h3 id="362adbd7-e1ce-4d2e-b9ef-a20676d79e62" class="">⭐️进程线程切换的区别？</h3><p id="0d1b8cfd-d533-4eab-abd0-9b9eefbb1997" class="">进程切换涉及到<strong>虚拟地址空间</strong>的切换而线程切换则不会。</p><p id="f9598cc7-88bf-4b1a-95c3-a1f6b0ae32d8" class="block-color-yellow_background"><strong>为什么进程切换比线程切换慢？</strong><div class="indented"><p id="b50e557f-2989-432d-8bde-1c7f16015f46" class="">首先，同一个进程中的线程共享进程的数据，因此需要切换的上下文内容少</p><p id="2ce9326d-182b-441a-8156-c6f58225515f" class="">更重要的是，<div class="indented"><p id="2cd9bec0-5047-4cda-89e3-912ee060f671" class="">因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了，那么虚拟地址转换为物理地址就会变慢</strong>，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p></div></p></div></p><p id="d1e9da27-3ea8-4e0f-bc8e-f4da75e8c955" class="">
</p><p id="336a6370-0612-439a-b2e8-de6a2020cca8" class="">
</p><h3 id="2f9ae6fa-295f-47ae-bd98-1865f076475e" class="">对并发和并行的理解？</h3><ul id="b138bf7b-a795-401c-9ce3-ad5bac48047c" class="bulleted-list"><li>并发：<strong>宏观上</strong>在一个时间段中多个程序都启动运行在同一个处理机中。是你有处理多个任务的能力，不一定要同时。</li></ul><ul id="218194d1-4e1d-45df-82dd-1816ffb1d009" class="bulleted-list"><li>并行：A、B两个进程，分别由不同的CPU管理执行，两个进程不抢占CPU资源且可以<strong>同时</strong>运行。是你有同时处理多个任务的能力。<strong>需要硬件支持</strong>。</li></ul><p id="e82e1c94-4040-466f-ac54-0f64249d20c0" class="">
</p><p id="28bea5b8-9450-42e0-846a-cef97f0166d9" class="">
</p><h2 id="3adfaa10-82b7-42b6-8d2a-698f3da5e8fe" class="">进程</h2><h3 id="8a828be2-e54d-4427-8e1f-b293ca41e542" class="">⭐️进程状态的切换？</h3><p id="e93599a0-41a5-4150-ac40-81271b937c92" class="">几种状态：</p><ul id="565c4a3b-2a7f-4273-9fb7-19b9ba5f7e55" class="bulleted-list"><li>就绪：已经具备运行条件，等待被调度（现在可能没有空闲CPU）</li></ul><ul id="ace5b027-bbf8-4171-8e2b-8e273620ac96" class="bulleted-list"><li>运行：占有CPU，并在CPU上运行</li></ul><ul id="6478d021-c229-44a6-9964-23e01ae0a73a" class="bulleted-list"><li>阻塞：因等待某一事件而暂时不能运行</li></ul><figure id="d7a6efab-4b63-4fec-8740-0400f96a9114" class="image"><a href="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled.png"><img style="width:750px" src="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled.png"/></a></figure><p id="23d59d8c-1bed-474a-bc10-86efdc580359" class="">只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p><p id="4a94b3e5-a0ed-4ffe-817b-24b09ed1635c" class="">阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时 间会从运行态转换为就绪态。</p><p id="956b2eae-e0c6-45be-b393-181493bd5094" class="">
</p><h3 id="c4889838-9cf8-4ab7-889f-021a92e4abda" class="">⭐️进程间的通信方式？</h3><ul id="f57fef45-0a5d-4fa7-9c2a-d087b97e9ebe" class="bulleted-list"><li><strong>内存共享——最快的IPC方式</strong><ul id="37d317da-b0f6-4510-ae16-92f2dee6473e" class="bulleted-list"><li>基于数据结构的共享：比如共享空间只能存放长度为10 的数组。这种共享方式速度慢，限制多，是一种低级通信的方式。</li></ul><ul id="c1e92fcf-71a0-4b84-b9e6-2dfce1189cb0" class="bulleted-list"><li>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。这种共享方式相比之下更快，是一种高级通信方式。</li></ul></li></ul><ul id="56871eb1-a5de-4680-93cf-1171bcddb701" class="bulleted-list"><li><strong>管道</strong>：连接读写进程的共享文件，在内存中开辟一个大小固定的缓冲区<ul id="000b96f5-e122-4919-acb7-04a3e58a8748" class="bulleted-list"><li>半双工</li></ul><ul id="0d448208-9d34-464b-bd23-6054baded80b" class="bulleted-list"><li>管道写满时，写进程被阻塞；管道变空时，读进程被阻塞</li></ul><ul id="e654a6c7-98f7-461d-b7be-293aa98104e1" class="bulleted-list"><li>如果没写满，不允许读，如果没读空，不允许写</li></ul><ul id="0ccd301a-fed8-4da9-aec6-4a8ea18e462d" class="bulleted-list"><li>数据一旦被读出，就被抛弃——只能有一个读进程</li></ul></li></ul><ul id="7e450733-b0cc-4fc6-ba39-11b4005d158c" class="bulleted-list"><li><strong>消息传递</strong><p id="494bdf62-3a08-4986-b216-5ca26c01782f" class="">消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li></ul><ul id="af28efc7-15cf-4042-9483-5580cd78115b" class="bulleted-list"><li><strong>信号</strong><p id="68fad828-6ec5-448c-9c4f-abbd131849dd" class="">用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p></li></ul><ul id="81dbbcc5-727b-41be-a5bb-7ec29bf3219a" class="bulleted-list"><li><strong>信号量</strong><p id="bd216038-0f5c-455a-9c6d-70a7af537c52" class="">信号量的本质就是一个计数器，用来实现进程之间的互斥和同步。</p></li></ul><ul id="3dcd1dcf-fcf0-41e2-af05-09c72f1a30e6" class="bulleted-list"><li><strong>套接字socket</strong><p id="9af3f1da-aecb-4831-b78b-75a2214754e4" class="">可用于不同机器之间的进程间通信。</p></li></ul><p id="ee9e925c-d7f6-42ee-a2a2-241d79ef0ed8" class="">
</p><h3 id="199e21f6-6dfc-4595-b4a4-0fee4b38001d" class="">❓管道实现原理是什么？</h3><p id="f97b2fc5-4c7b-4838-9409-7b614eea40ab" class="">实际是要通信的两个进程访问同一个文件。</p><p id="103628b1-a522-48d1-aa83-e2aee1f1acf1" class="">
</p><h3 id="30ee6812-8623-48c3-9ead-75eac3c49987" class="">父进程、子进程、进程组、作业和会话？</h3><p id="df3ffec7-3957-4c40-9ab5-5d641b84ce15" class=""><strong>父进程</strong></p><p id="05dbf022-77c8-400e-b7b9-80c1e97c0782" class="">已创建一个或多个子进程的进程</p><p id="7ab54658-a376-4a59-86e4-02ff706ae4cf" class=""><strong>子进程</strong></p><p id="988d60bb-f560-4d43-8021-9c89769941f1" class="">由fork创建的新进程称为子进程。</p><p id="7bbc4090-5728-47a2-bcef-083d857559f1" class="">fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置(两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的)。</p><p id="f47c166c-a5f0-495e-850e-d6af9d12f348" class=""><strong>进程组</strong></p><p id="9d605e1a-19a6-488b-92a8-fe2c91b481cd" class="">多个进程的集合，其中肯定有一个是组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，与其组长进程是否终止无关。</p><p id="4dca3fb4-1b3d-402e-8f01-a8d457791b06" class=""><strong>作业</strong></p><p id="dc04a762-e258-4c84-b898-7a1ac35230e9" class="">作业是用户需要计算机完成的某项任务，是要求计算机所做<strong>工作的集合</strong></p><p id="d6157614-0a69-4078-8b39-853eefe9e3b0" class="">shell分前后台来控制的不是进程而是作业(job)或者进程(Process Group)。
一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制</p><p id="713d0e21-833d-409e-bdd8-8d7c5a932c54" class=""><strong>会话</strong></p><p id="0e9fd2fc-3961-478d-9939-6cf2e8318660" class="">会话(Session)是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p><p id="27047af2-7e6a-4129-8a37-0127d1c2b8f3" class="">
</p><h3 id="f56a9767-1cec-4be7-abaa-450de94d0b19" class="">进程和程序的区别？</h3><ul id="e7b63a6d-3eb2-40f9-b098-fb403f22b4ab" class="bulleted-list"><li>进程更能真实地描述并发，而程序不能。</li></ul><ul id="319ffb07-0dd4-4548-a5b0-1aa06c72b0c4" class="bulleted-list"><li><strong>进程由程序和数据两部分组成</strong>，进程是竞争计算机系统有限资源的基本单位，也是进程处理机调度的基本单位。</li></ul><ul id="5614abd0-cc28-4f8e-b699-bcc8ec0e4ac9" class="bulleted-list"><li><strong>程序是静态</strong>的概念；进程是程序在处理机上一次执行的过程，是动态的概念。</li></ul><ul id="ee2dff41-df52-486b-a5cb-0b2a0bdfb95e" class="bulleted-list"><li>进程有生存周期，有诞生有消亡。是短暂的；而程序是相对长久的。</li></ul><ul id="53754d81-9388-40bd-9149-0e12303882f2" class="bulleted-list"><li>一个程序可以作为多个进程的运行程序；一个进程也可以运行多个程序。</li></ul><ul id="3e02206a-77ee-452c-8b67-5c5a0489c1f1" class="bulleted-list"><li>进程具有创建其他进程的功能；而程序没有。</li></ul><p id="9b4c2b8c-bf1e-4953-a609-c818f17362b2" class="">
</p><h3 id="b11d2621-4ce2-4652-82eb-57683110623f" class="">进程结构？</h3><p id="eced11ad-3ad0-4023-b66d-9b8b6f06e732" class="">进程结构由以下几个部分组成:代码段、堆栈段、数据段。代码段是静态的二进制代码，多个进程可以共享。</p><p id="9721eaae-6623-45f2-a9ef-8f118217f564" class="">
</p><p id="e150d41c-eaa7-49fd-9777-b9b3f3e2dcf5" class="">
</p><h3 id="0da5fd6e-780c-417d-b330-afe7fe6c5790" class="">子进程从父进程继承了什么？独有什么？</h3><p id="0f789182-beea-48d6-8f7f-2bcdcfef15b1" class=""><strong>子进程从父进程继承的有:</strong></p><ul id="fc91aa98-6fb5-4903-9ffa-931d16c76248" class="bulleted-list"><li>进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))</li></ul><ul id="6e30b78c-2cd9-418a-806f-a5c9c9444dd5" class="bulleted-list"><li>环境(environment)</li></ul><ul id="8140a314-f9ea-4eb8-b93d-4e9c21ff57fd" class="bulleted-list"><li>堆栈</li></ul><ul id="135a9d44-94a9-4a2a-87f6-13341f9a2cfe" class="bulleted-list"><li>内存</li></ul><ul id="5ad05aff-9b64-4bb0-94a7-178f2b99dc6c" class="bulleted-list"><li>进程组号</li></ul><p id="bad87492-1eb0-4be0-894b-3fda3ffc740e" class=""><strong>独有：</strong></p><ul id="8b8599d1-c00f-4a97-b0cf-c8ea114a2b10" class="bulleted-list"><li>进程号</li></ul><ul id="1d7a65b4-5f81-4c06-83bc-467aa9d158a2" class="bulleted-list"><li>不同的父进程号（即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到）</li></ul><ul id="0f35ca84-30d5-426d-afd8-09b7f17b1b58" class="bulleted-list"><li>资源使用设定为0</li></ul><p id="1055160b-c212-4cc0-a91c-77c4c13965d1" class="">
</p><h3 id="57616baf-0a34-4ae2-8b00-2f4b650ba04f" class="">Linux中如何创建进程？如何判断是父进程还是子进程？进程创建成功返回什么？如果返回不为0就一定失败吗？</h3><p id="792f74d4-3f59-488d-9a80-ebaf9d8601c3" class="">fork创建子进程，该函数调用一次，返回两次，两次返回的区别是<strong>子进程的返回值是0，父进程的返回值是新进程（子进程）的进程id</strong>。</p><p id="f9f89cbc-d907-46a5-a404-d2d7f0c070f1" class="">如果进程创建失败，返回负数？</p><p id="46023933-35b8-477a-a1c7-156e4c47ad4c" class="">
</p><h3 id="98bfc194-708d-445d-b70a-3662094386dd" class="">孤儿进程 ？守护进程？守护进程 与后台进程区别 nohup吗？</h3><ul id="ae651a14-392f-4258-9659-9fafa8abe409" class="bulleted-list"><li>守护进程：指在后台运行的，没有控制终端与之相连的进程。它<strong>独立于控制终端，周期性地执行某种任务</strong>。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等。</li></ul><ul id="8f0a156f-b184-4bec-bff2-3770e53efbee" class="bulleted-list"><li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）收养。</li></ul><p id="0baf5aa2-0e6e-49d3-871f-7ea889844f4b" class=""><strong>守护进程与后台进程的区别：</strong></p><ul id="60c9e890-9e9c-4533-804c-529800c2b567" class="bulleted-list"><li>守护进程完全脱离终端控制台，而后台进程并未完全脱离终端：在终端未关闭前还是会往终端输出结果</li></ul><ul id="7eac01f9-d48e-4d1e-91c5-6d7becbc9c83" class="bulleted-list"><li>守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以nohup command &amp; 格式才能避免影响</li></ul><ul id="aaa333ce-302c-4058-ad61-494c98410dcd" class="bulleted-list"><li>守护进程的会话组和当前目录，文件描述符都是独立的。后台进程只是终端进行了一次fork，让程序在后台执行，这些都没改变。</li></ul><p id="f641198e-cc80-4f68-899c-17052654da6b" class="">
</p><h3 id="8b1de861-58f4-4405-aa10-9b2f618ef93a" class="">如何创建一个守护进程？</h3><ol id="2b9e81ba-cc3d-492e-84c4-e319a3909915" class="numbered-list" start="1"><li><strong>让程序在后台执行</strong><p id="bca2dccb-40aa-4222-9569-be62ccfa663c" class="">fork一个子进程，然后父进程退出</p></li></ol><ol id="d1b50ee4-0f98-4cf1-8433-23aab03b103b" class="numbered-list" start="2"><li><strong>创建一个新对话期</strong><p id="70ef916e-350b-45f3-9594-efa672d31c5c" class="">控制终端、登录会话和进程组通常是从父进程继承下来的，守 护进程要摆脱它们，不受它们的影响，方法是调用setsid()使进程成为一个会话组长。setsid()调 用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</p></li></ol><ol id="4302277b-33e0-456c-8908-60a12ea4a942" class="numbered-list" start="3"><li><strong>禁止进程重新打开控制终端</strong><p id="dc507e42-a321-4749-8886-d308ed0f549a" class="">经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以 重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过 fork()创建新的子进程，使调用fork的进程退出。</p></li></ol><ol id="f8c59ae4-d6cf-4c4e-9a85-9481f570da57" class="numbered-list" start="4"><li><strong>关闭不再需要的文件描述符</strong><p id="6fd2df81-4d96-40d8-84d3-14fa8700fe67" class="">子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统 资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后 用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</p></li></ol><ol id="21fe42bc-df27-4cae-b6bb-d676bbcdaec7" class="numbered-list" start="5"><li><strong>将当前目录更改为根目录</strong></li></ol><ol id="568571e2-c234-4956-bbe1-002941fefef1" class="numbered-list" start="6"><li><strong>将屏蔽字清零</strong><p id="b178f4f1-ccee-4df8-873b-036c9a9b3f0c" class="">子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。unmask(0)将屏蔽字清零。</p></li></ol><ol id="92cb7153-6418-452f-8ca1-94c9c1d30955" class="numbered-list" start="7"><li><strong>处理SIGCHLD信号</strong><p id="183dfa75-7d31-4317-a884-c4463c92872d" class="">对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待 父进程捕获状态，则子进程将成为僵尸进程(zombie)，从而占用系统资源。如果父进程等待子进程 结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操 作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。</p></li></ol><p id="96ca2a58-f93f-4066-810d-083f57d8b0b9" class="">
</p><h3 id="0b7002d0-0de7-4cdf-8e78-077bea93f48d" class="">⭐️僵尸进程是什么？</h3><p id="bf7e4962-24ac-4789-9ed2-13d4f34f0270" class=""><span style="border-bottom:0.05em solid">如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</span></p><p id="e11f2f72-d87c-4d07-b2f2-6453fdef56dc" class="">设置<strong>僵尸进程的目的</strong>是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。<span style="border-bottom:0.05em solid">如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1(init进程)。</span>继承这些子进程的init进程将清理它们(也就是说init进程将wait它们，从而去除它们的僵尸状态)。</p><p id="c9c312b5-ebcd-4e00-8d39-95d6b531e20f" class="">
</p><h3 id="020430c2-23af-44fb-bf3c-b04ea98f03ee" class="">如何避免僵尸进程？</h3><ul id="80a9f324-ef7f-4ed0-85c6-f5f0b7134b78" class="bulleted-list"><li>通过signal(SIGCHLD,SIG_IGN)通知内核对子进程的结束不关心，由内核回收。</li></ul><ul id="ba4df025-7dcf-4295-bf33-6f52a2101ee8" class="bulleted-list"><li>父进程调用wait/waitpid函数等待子进程结束，如果尚无子进程退出会导致父进程阻塞。waitpid可以通过传递WHOHANG使父进程不阻塞立即返回。</li></ul><ul id="b9dd3997-1efa-46a8-83dc-93de7a0c86d0" class="bulleted-list"><li>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出。</li></ul><ul id="91f197ad-6e5a-44bc-ae63-f3b69cbaa42d" class="bulleted-list"><li>两次调用fork。父进程先fork一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而孙进程变成了孤儿进程，会被init进程收养，孙进程结束后，init会等待回收。</li></ul><p id="84ea40a3-025d-4974-b9fc-283c13ea37f6" class="">
</p><h3 id="915c9054-4a12-4eff-a2fe-d4ee87299f22" class="">进程终止的几种方式？</h3><ul id="50928a05-e4f2-4f1e-9617-e4dd13d3d1ca" class="bulleted-list"><li>main函数自然返回，return</li></ul><ul id="fb775d5f-09c9-4bf7-911b-5a87c8527bc7" class="bulleted-list"><li>调用exit函数，属于c的函数库</li></ul><ul id="1170e228-3c8b-40f0-9cf3-0bd5bde214ec" class="bulleted-list"><li>调用_exit函数，属于系统调用</li></ul><ul id="dfdee0cc-f63f-4819-82a4-1b6f40704f40" class="bulleted-list"><li>调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程</li></ul><ul id="8589190b-eca9-4f25-8567-66389af43a1e" class="bulleted-list"><li>接受能导致进程终止的信号：crtl+c、SIGINT</li></ul><p id="ece056d9-93d6-4061-8b8c-b9d113056091" class="">exit和_exit的区别：_exit的作用是直接使进程停止运行，清除其使用的内存空间，并清除其在内核的各种数据结构</p><figure id="372f409e-7109-47b6-9c71-6bb27effe2f3" class="image"><a href="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%201.png"><img style="width:192px" src="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%201.png"/></a></figure><ul id="4682e96c-c350-4577-9848-592dfb0c0b6b" class="bulleted-list"><li>exit()会首先将所有使用atexit注册的函数进行调用以后再推出，而_exit()则是直接结束程序。图中的“调用终止处理程序”。</li></ul><ul id="56ed75c8-d41e-42eb-b798-b81269920330" class="bulleted-list"><li>exit()函数在调用exit 系统调用前要检查文件的打开情况，把文件缓冲区中的内容写回文件。也就是图中的“清理I/O缓冲”。</li></ul><p id="9900ac06-04ea-4387-b377-c621e1df3ac4" class="">
</p><h3 id="801dcd5e-4161-4eef-8a46-52f634295d4d" class="">⭐️Linux进程调度方法？</h3><ul id="6f958df5-d54e-402d-92bc-3630805eceb2" class="bulleted-list"><li><strong>先来先服务（FCFS）</strong><p id="1b2a620d-2d48-4abb-8860-2701e170ab47" class="">每一次调度都从队列中选择最先进入队列的投入运行。</p><p id="354362af-7f7c-4e98-b53a-8c7f34512db0" class="">优点：公平，实现简单。</p><p id="8b9192b0-8b61-4491-ae5a-7767b7242da0" class="">缺点：排在长作业后面的短作业需要等待很长时间，对短作业来说用户体验不好。</p><p id="e653ff05-c5dd-4084-b4a3-72439c5ea620" class="">是否导致饥饿：不会❌</p><p id="14863278-766a-4f00-a77d-da40a6111739" class="">是否抢占：不抢占❌</p></li></ul><ul id="2a26eedd-a2c1-4a07-b6c2-bdd858550503" class="bulleted-list"><li><strong>短作业优先（SJF）</strong><p id="7c440eb8-716c-44d9-998e-736f48fb6a57" class="">执行时间短的进程会优先执行。</p><p id="c7c765ac-c593-4fdf-a083-dc16337423ed" class="">优点：“最短的”平均等待时间、平均周转时间。</p><p id="ef92bffb-658e-4395-9eb1-e0c7e19e83be" class="">缺点：不公平，对短作业有利，对长作业不利。另外，作业运行时间是用户提供，不一定真实，不一定能真正的短作业优先。</p><p id="cc54c17c-1b99-4301-9530-343715d639d0" class="">是否导致饥饿：会✅ （如果源源不断的短作业到来，会导致长作业饥饿）</p><p id="d0674a27-f1f7-4851-8da0-a9d91b90d45b" class="">是否抢占：不抢占❌</p></li></ul><ul id="1035bd1c-e32a-410c-b907-4cf996668498" class="bulleted-list"><li><strong>最短剩余时间优先（SRTN）—— 为啥提出这个来着？？？</strong><p id="c25974e2-f4bb-4014-a3d6-6349f5f6e621" class="">针对短作业优先方法增加了<strong>抢占机制</strong>，进程调度总是选择预期剩余时间最短的进程，当一个进程加入到就绪队列时，它可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就有可能抢占当前正在运行的进程。</p><p id="10341a85-d32b-4a2f-b37f-b6358e13816e" class="">是否导致饥饿：会✅</p><p id="94944c36-bcaf-41a4-8b2a-2045e2800dc4" class="">是否抢占：抢占✅</p></li></ul><ul id="d7ae7c5d-8c91-4f68-bfc5-b34df734c83f" class="bulleted-list"><li><strong>高响应比优先</strong><p id="b4107bd2-26d4-4c03-9cff-bd91823a2cb8" class="">响应比=（等待时间+要求服务时间）/要求服务时间</p><p id="1e8ea1b3-660f-45fc-81da-38a7495bd761" class="">优点：综合考虑了作业的等待时间和要求服务时间。解决饥饿问题？</p><p id="e00327f5-7e65-4cc0-ab1e-02e651a1f79d" class="">是否导致饥饿：不会❌</p><p id="e2e1ae54-ebef-4832-bb64-649ba2afaccd" class="">是否抢占：不抢占❌</p></li></ul><ul id="0a2231ab-086a-4ccc-840d-199c74b65fd5" class="bulleted-list"><li><strong>时间片轮转</strong><p id="6919bb68-ee31-4c57-be55-3959af9a7584" class="">将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p><p id="242a9701-2556-405a-8293-0203ff4493f9" class="">当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p id="663197a6-43dc-4273-8948-c48e6efda798" class="">优点：公平、响应快，适用于分时操作系统。</p><p id="1af7de9d-7d1b-4b3a-a13a-ad1b973e8014" class="">缺点：进程切换有一定开销、不区分任务紧急度。</p><p id="02e6dfc2-18ec-48c2-bbff-9e2a07d5b88a" class="">是否导致饥饿：不会❌</p><p id="3093fff4-6f79-4200-9cca-f65411acf972" class="">是否抢占：抢占✅</p></li></ul><ul id="c36cb990-95a9-4ff3-b854-2488918f4ada" class="bulleted-list"><li><strong>优先级调度</strong><p id="d45f4b33-6dd3-4302-97dd-4763a46c8251" class="">为每个进程分配一个优先级，按优先级进行调度。</p><p id="53aa7427-dd00-462a-ab49-2bc9b9321a45" class="">为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p id="b573ebcb-700b-4b1f-94ce-4b7a596b52fb" class="">优点：用优先级区分紧急度，适用于实时操作系统。可灵活调整对各种作业的偏好程度。</p><p id="5de872ab-7120-4284-b268-a8b3834763bd" class="">缺点：若源源不断有高优先级到来，可能导致饥饿。</p><p id="7fc87d26-ef3b-4867-ac13-245775e3cfb8" class="">是否导致饥饿：会✅</p><p id="3671b170-c115-496f-a200-5d13096a994e" class="">是否抢占：抢占、不抢占都有</p></li></ul><ul id="ef830c88-ce4e-43a6-9c54-6499b72fac71" class="bulleted-list"><li><strong>多级反馈调度 —— 时间片轮转调度算法和优先级调度算法的结合。</strong><p id="c41e7c10-7aa3-49bc-a64e-aa9b6d71c4b7" class="">提出目的：对于需要连续执行多个时间片的进程，会进行很多次进程交换。</p><p id="ab4cffef-e1d8-4c27-b434-0933774c4a1c" class="">它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p><p id="2e3ebc3d-46c3-45bd-93e7-3bd2bc0c11da" class="">这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p id="7c8c2bf3-ab1b-452e-aef1-51bfd50cb245" class="">是否导致饥饿：会✅</p><p id="4f2ceafc-fe85-452d-9135-ab86cd66db5a" class="">是否抢占：抢占✅</p><p id="f229b55a-600c-4ed7-8010-21471898e572" class="">
</p></li></ul><h3 id="1b57ccd9-12fa-4032-8260-457d29e80195" class="">进程阻塞和挂起的区别？</h3><ul id="e8c203a8-fcf3-4b2b-9ade-0f5c90abfa50" class="bulleted-list"><li>共同点<ol id="f31ee12f-a8c0-4103-aa8d-c81186167d6d" class="numbered-list" start="1"><li>进程都暂停执行</li></ol><ol id="a1bc6d3f-048c-4fd2-b540-577050275a30" class="numbered-list" start="2"><li>进程都释放CPU，即都会涉及上下文切换</li></ol></li></ul><ul id="67a8f1d1-f63c-4e05-b5f0-223d19cdf60a" class="bulleted-list"><li>不同点<ol id="ef948d7f-5031-44fa-a07d-72250efde7ef" class="numbered-list" start="1"><li>对系统资源的占用不同：虽然都释放了CPU，但是阻塞的进程仍在内存中，而挂起的进程被换出到外存。</li></ol><ol id="ac060fd8-051b-484a-a239-78c5c28a152c" class="numbered-list" start="2"><li>发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘</li></ol><ol id="c9a3ebfc-51a4-48de-9b53-946f117fde9e" class="numbered-list" start="3"><li>恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活</li></ol></li></ul><p id="51dede2b-c687-4352-b8f4-60e8ac7cdccf" class="">
</p><h2 id="2ddd3dee-b9dd-4705-a1c9-1123252d0d70" class="">线程</h2><h3 id="c5d7f772-02e1-4dc4-babe-e5b63670f779" class="">一个进程可以创建多少线程？</h3><p id="69796976-28d1-4111-bb93-d9326c345e9f" class="">一个进程可用的虚拟空间是2G，默认情况下，线程的栈大小是1MB，所以理论上只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置（减小线程栈的大小）。</p><p id="5d0f7c7c-c13b-4700-adf2-b14f766dd968" class="">
</p><h3 id="1879bbb9-34a8-4548-88ca-f639fbf85558" class="">linux系统下线程是怎么实现的？创建线程有多少种方式？</h3><ol id="84489471-97b3-4e8e-9b7b-528437fbd307" class="numbered-list" start="1"><li>通过函数指针<p id="63423b19-fefb-496b-9398-0cfd6b8a3def" class=""><code>std::thread thr(A);</code></p></li></ol><ol id="fa37fb74-206b-49fb-a364-35c039dcc365" class="numbered-list" start="2"><li>通过类<pre id="305f42ff-add2-4809-a300-b426c990c800" class="code"><code>//A是重载了()的类
std::thread thr1{A};

//或
A a;
std::thread thr2(a);

//或
std::thread thr3 = std::thread(A);</code></pre></li></ol><ol id="86c48269-5bb0-409f-b64d-8d9d9b3e62e5" class="numbered-list" start="3"><li>通过lambda表达式<pre id="1dfd3df1-5501-4a45-98d6-60a11d813f36" class="code"><code>std::thread thr([](){cout &lt;&lt; &quot;hhh&quot; &lt;&lt; endl;}); //放前面后面都可以</code></pre></li></ol><p id="6ffcb6c6-99df-48fa-850f-53c5b87bb16e" class="">
</p><p id="5236f81b-6d09-4424-b909-970ca285745d" class="">
</p><h3 id="bdc0b608-08e5-4eaf-9376-babb07879457" class="">什么是多线程模型？</h3><p id="e37a063d-406f-49d6-98ab-f1f8544021a9" class="">线程的实现方式分为用户级线程和内核级线程。</p><ul id="6c156d49-8a9e-4926-917f-4981b3b95496" class="bulleted-list"><li>用户级线程：由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责。线程切换可以在用户态下即可完成，无需操作系统干预。在用户看来，是多个线程，但<strong>在操作系统看来，意识不到线程的存在。</strong></li></ul><ul id="87c91978-f318-4c37-a0fc-df9c61027680" class="bulleted-list"><li>内核级线程：由操作系统完成，线程调度、切换等工作都由内核负责，需要在核心态下才能完成。</li></ul><p id="26519684-5076-4906-b5da-96306b2cbc72" class="">
</p><h3 id="29ef48c9-57ad-46a0-8c66-ef4b4e93caf9" class="">⭐️线程共享和独有的资源？</h3><ul id="00e9f24d-ac19-434e-8077-bd1f8eff522b" class="bulleted-list"><li>共享：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</li></ul><ul id="25b80337-bb57-4a10-a75b-44e2246dd919" class="bulleted-list"><li>独有：<ul id="574f0111-6108-4196-8be0-38380f5013b7" class="bulleted-list"><li>上下文：线程的优先级、寄存器组的值</li></ul><ul id="bf40bdbb-cf0c-4664-8815-473dae704809" class="bulleted-list"><li>栈结构：线程的堆栈（在一个进程的线程共享堆区，而进程中的线程各自维持自己堆栈，）</li></ul><ul id="3c8edc66-55b0-4793-93ac-1514fe57f9ef" class="bulleted-list"><li>其他：线程ID、错误返回码、线程的信号屏蔽码</li></ul></li></ul><p id="1d01393f-d386-4705-a9e0-9ad1fa721233" class="">独有线程堆栈的原因：线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。</p><p id="113896c5-4093-4469-95e2-5d97865062fa" class="">
</p><h3 id="b951c03a-4755-4f21-8494-62aca34e4a64" class="">线程池怎么实现的？说一下线程池的参数？</h3><p id="5aa253ef-2ed8-4897-a7ea-a98373d7b68a" class="">一种线程的使用模式，线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。</p><p id="50b31629-820c-4fae-90ff-59c210033817" class="">通过事先创建一定数量的线程放入线程池，线程池开启之后，这些线程开始不断从任务队列中拿取任务来执行，拿任务和添加任务的过程要加锁。</p><p id="27c6384e-99a5-4605-95ef-32cd83a06612" class="">线程池的参数：是说的Java里的吧，Java中有一个ThreadPoolExecutor，有7个参数：corePoolSize（核心线程大小）, maximumPoolSize（最大线程数量）, keepAliveTime（空闲线程存活时间）, unit（空闲线程存活时间单位）, workQueue（工作队列）, threadFactory（线程工厂）, handler（拒绝策略）。</p><p id="df0c995e-4a37-435c-a49f-397c3efc1e34" class="">
</p><h3 id="994660c2-4b6c-47c2-bea1-dde034621d2f" class="">怎样保证线程安全，各个实现方法有什么区别？</h3><ol id="806aa679-34c3-40dc-b0dc-7ac1b8aa811e" class="numbered-list" start="1"><li>互斥同步：加锁</li></ol><ol id="8e630187-23a0-412f-90fb-b54d964bc700" class="numbered-list" start="2"><li>非阻塞同步：<p id="e5f82e1d-82aa-4d83-922e-42474dd2b6b3" class="">CAS就是一种非阻塞同步：内存地址V，旧的预期值A，要修改的新值B，更新一个变量的时候，当提交更新时，只有当变量的旧的预期值A和内存地址V中的值相同的时候，才会将内存地址V中的值更新为新值B。——属于悲观锁。——ABA的问题用版本号来解决。——如何保证获取的当前值时内存中的最新值？（用volatile关键字修饰变量）</p></li></ol><ol id="c38421cf-f930-4c04-b804-9bc0a7649deb" class="numbered-list" start="3"><li>无同步：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题</li></ol><p id="0a8bba94-603b-452d-a1d2-1c5b8763d406" class="">
</p><p id="c777a31b-ebcc-4548-b0b9-e5f796d4bb6c" class="">
</p><h3 id="1e357b4a-f224-4901-9c13-d4e2494cd9c6" class="">多线程如何使用智能指针？</h3><p id="3858bcda-3ae0-4975-a061-83d9afd6e115" class="">虽然shared_ptr的引用计数是原子安全的，但是它有两个数据成员，指针和引用计数，对它们一同的写不能原子化。这里其实还是回到了它的本质，所指向对象的引用计数是否会因为多线程环境出现安全问题。主要问题还是<strong>指针指向更新和引用计数更新不同步</strong>的问题，导致空悬指针及引用计数出错的问题。</p><p id="16fa16f5-80ad-4520-b257-1228998de9a1" class="">所以要在读写同一个智能指针的时候加锁（产生一个智能指针或销毁一个智能指针）</p><p id="2eea20c0-8aec-4567-932f-aed23b8d8a8f" class="">
</p><h3 id="804e6905-69d1-4c87-bfe0-ac60acf4f93a" class="">线程间通信的方法？</h3><p id="167009f7-02a7-44d8-98ff-c5b93237370b" class="">同一个进程创建的线程之间共享进程的数据，可以通过<strong>共享的数据</strong>进行通信。</p><p id="a2ed3376-cfa7-4400-ac7f-2371eac62799" class="">当然，<strong>进程的通信方法</strong>如：共享内存、信号量、信号等也可以用来线程间通信。</p><p id="ac630fca-3694-47cf-966e-d9768631e0a8" class="">
</p><h3 id="7df251e7-1dc5-41d5-b720-d4391002ae9d" class="">⭐️有哪些多线程同步的方法？</h3><ul id="b8663212-fb9e-4654-a0d9-cc0734cf575c" class="bulleted-list"><li>信号量：可用于进程同步，也可用于线程同步</li></ul><ul id="77c31241-181c-4cb8-be05-9355123ef46d" class="bulleted-list"><li>互斥锁+条件变量：只能用于线程同步</li></ul><p id="e22d46bc-a8b5-4d22-94f0-6c6cbf79ede1" class="">
</p><h3 id="ed2182d5-75f2-444c-b5e2-f73666d2dfcc" class="">⭐️线程有多少种状态，状态之间如何转换？</h3><ol id="773c5e58-983c-4904-bc97-c3c7b712f5d0" class="numbered-list" start="1"><li>新建（NEW）</li></ol><ol id="4126a965-2dfe-427d-ae0e-8489543851b9" class="numbered-list" start="2"><li>可运行（RUNNABLE）</li></ol><ol id="d52c568e-2ef0-432e-b4b6-634f938edb78" class="numbered-list" start="3"><li>运行（RUNNING）</li></ol><ol id="684b5fd4-fe13-4880-bd56-8ca0b3abff28" class="numbered-list" start="4"><li>阻塞（BLOCKING）</li></ol><ol id="615bc364-bf5f-47c7-9ff1-3b2d01b473b4" class="numbered-list" start="5"><li>死亡（DEAD）</li></ol><figure id="48573a7b-57ac-49f0-8ae8-c7263420487b" class="image"><a href="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%202.png"><img style="width:1934px" src="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%202.png"/></a></figure><figure id="5346fe71-941e-4f59-992e-811e02d41130" class="image"><a href="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%203.png"><img style="width:1278px" src="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%203.png"/></a></figure><p id="41e21067-586f-4356-9c92-c11779632475" class="">
</p><h3 id="0c0d9154-78f8-4230-80bd-efe6686007d4" class="">怎么回收线程？有哪几种方法？</h3><ul id="9a2c182d-8c89-4784-9e14-69338aa3338c" class="bulleted-list"><li>等待线程结束<p id="deabb409-7837-4f84-af22-cbe01c63cc3d" class="">主线程调用，等待自线程退出并回收其资源。</p><p id="01d875ab-f713-40ee-8333-0600e5752170" class=""><code>int pthread_join(pthread_t tid, void** retval)</code></p></li></ul><ul id="42589d2c-2f76-40fc-b278-298df61b3dee" class="bulleted-list"><li>结束线程<p id="9bf452ec-235f-49db-8d7c-f8547d3d849e" class="">子线程调用，用来结束当前线程并通过retval传递返回值。</p><p id="d70a06b3-175a-4674-8653-6c7b84c841cc" class=""><code>pthread_exit(void** retval)</code></p></li></ul><ul id="61d60487-d320-485b-b67a-232a3590c129" class="bulleted-list"><li>分离线程<p id="a14c76de-8fb6-477d-9355-f983afc4b5bd" class="">主线程、子线程都可调用。</p><p id="429a73f3-e899-4ce3-be1e-b3784fbca9c3" class=""><code>pthread_detcach(tid)</code></p><p id="ef585a66-171f-4868-a71b-51775f95f76c" class=""><code>pthread_detach(pthread_self())</code></p></li></ul><p id="52c7721e-ab2c-4a62-a177-926841a2f9f2" class="">
</p><p id="3ed1122c-63e6-4513-a2f1-ab2e84fe1ebe" class="">
</p><h3 id="f4cc220c-d856-4331-92f6-37736c1ebc2f" class="">⭐️sleep和wait的区别？</h3><ol id="82b630b8-6cbf-46c5-8a92-9959d818a272" class="numbered-list" start="1"><li><mark class="highlight-red"><strong>sleep()方法不会释放锁，wait()方法释放对象锁。</strong></mark>（但是都会释放CPU？sleep线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。）</li></ol><ol id="b76eafa5-704e-476c-b534-650110949ced" class="numbered-list" start="2"><li>sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。</li></ol><ol id="ab042ff5-bd3e-4540-9106-5224b0afe639" class="numbered-list" start="3"><li>sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。</li></ol><p id="1a6a5072-604a-4b03-ac41-6d6b3e2f890b" class="">个人理解注：wait的线程轮到他运行时，会不会唤醒，如果只是单纯的wait()，需要等待其它线程来唤醒；如果是wait某个条件变量，轮到他了会再判断一次是否满足条件了？好像并不会🤔，只有被通知了才会被唤醒🤔</p><p id="d60ff449-9cc1-4ab9-aaab-91e559457a15" class="">
</p><p id="13484ce5-3ff9-4bd3-bd59-3462ac99400c" class="">
</p><h3 id="52b8a4e3-777c-4e18-b7a0-1b496c884128" class="">IO密集型和CPU密集型？</h3><p id="52bb07f6-6721-4324-a974-98e7d9c76433" class="">
</p><p id="7f8657a7-74db-475d-9e5c-3109abdeb398" class="">
</p><p id="0d096696-1805-4530-9384-acb2653470ac" class="">
</p><h3 id="e992aa12-d4e3-4e08-a1cc-6d140a3b3ade" class="">手写三个线程交替打印一个共享变量</h3><pre id="a42ed0ed-6cd1-4e34-85ab-9e2b3b0e08ca" class="code"><code>//两个的话用一个flag就行了
//循环里面是指从1打印到20
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

using namespace std;

condition_variable cond;
mutex mux;

int shared_i = 1;
bool flag1 = true;
bool flag2 = true;

void threadA(){
    for (int i=0; i&lt;20; ++i){
        std::unique_lock&lt;std::mutex&gt; lk(mux);
        cond.wait(lk,[](){return flag1 &amp;&amp; flag2;});
        std::cout &lt;&lt; shared_i &lt;&lt; std::endl;
        shared_i++;
        flag1 = false;
        cond.notify_all();
    }
}

void threadB(){
    for (int i=0; i&lt;20; ++i){
        std::unique_lock&lt;std::mutex&gt; lk(mux);
        cond.wait(lk,[](){return !flag1 &amp;&amp; flag2;});
        std::cout &lt;&lt; shared_i &lt;&lt; std::endl;
        shared_i++;
        flag2 = false;
        cond.notify_all();
    }
}

void threadC(){
    for (int i=0; i&lt;20; ++i){
        std::unique_lock&lt;std::mutex&gt; lk(mux);
        cond.wait(lk,[](){return !flag1 &amp;&amp; !flag2;});
        std::cout &lt;&lt; shared_i &lt;&lt; std::endl;
        shared_i++;
        flag1 = true;
        flag2 = true;
        cond.notify_all();
    }
}

int main(int argc, const char * argv[]) {
    std::thread thr1(threadA);
    std::thread thr2(threadB);
    std::thread thr3(threadC);
    thr1.join();
    thr2.join();
    thr3.join();
    
    return 0;
}</code></pre><p id="3cf82180-0a73-46bb-9ddf-158b2f82f65a" class="">
</p><p id="26a772ad-67aa-49d0-85e0-9ebfe9ee73e8" class="">
</p><p id="a08d4e3c-57c3-4c37-b3b4-2eec787cadd8" class="">
</p><h2 id="207d9048-1242-4deb-87f1-599c7f1aa380" class="">锁、死锁</h2><h3 id="a9726995-821c-4094-b051-de5054428b77" class="">⭐️死锁的原因、条件和避免死锁的方法？</h3><p id="801a7aba-a024-4314-be30-6048613c7c6a" class=""><strong>什么是死锁：</strong><div class="indented"><p id="16b04cf6-7329-433f-8bed-a17d21d4aa91" class="">进程在等待永远等不到的资源，例如两个进程在互相等待对方握着的资源。</p></div></p><p id="31ab277a-9d05-4562-810f-7df8bb1c27cf" class=""><strong>死锁产生原因：</strong><div class="indented"><ul id="adfcbbc4-532d-40cb-bf30-b0de45aef530" class="bulleted-list"><li>进程顺序不当</li></ul><ul id="c9561ea9-34e7-4820-bf16-4a51b5863cf5" class="bulleted-list"><li>PV操作使用不当</li></ul><ul id="34f3638a-7c00-433a-82ed-bbbd94043cdc" class="bulleted-list"><li>同类资源分配不均</li></ul><ul id="23c591ca-1f01-4535-9b3f-65027d64390c" class="bulleted-list"><li>对某些资源的使用未加限制</li></ul></div></p><p id="26d0fc0c-d2d9-48c6-85f4-02823fe50fe2" class=""><strong>死锁的条件：——四个缺一不可</strong><div class="indented"><ul id="cbbcd85a-a577-4053-bf87-9eede34a66bb" class="bulleted-list"><li><strong>互斥条件：</strong>进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li></ul><ul id="819bf20e-fe70-4550-8248-878b8f926b6b" class="bulleted-list"><li><strong>不剥夺条件：</strong>进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</li></ul><ul id="c4cc4907-66be-4ed1-9390-fa26f1f46d5d" class="bulleted-list"><li><strong>请求和保持条件：</strong>进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li></ul><ul id="134a26b8-96ef-47ed-aa31-c6221b349e42" class="bulleted-list"><li><strong>循环等待条件：</strong>存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ul></div></p><p id="e65b2057-e0db-41f5-8dfe-63c12df4eba6" class=""><strong>预防、避免死锁的方法：</strong><div class="indented"><ul id="77e98ad6-ddaa-45b2-99bf-355e6920bade" class="bulleted-list"><li>破坏上述四个条件之一（互斥无法被破坏）<ul id="29b66a72-6c89-4717-9487-3554a121a3c3" class="bulleted-list"><li>采用资源静态分配策略，破坏部分分配条件，一个进程在运行前一次性申请完所需全部资源，只要有一个未满足，就不准运行。</li></ul><ul id="fb291597-82a9-4e98-a007-938589f43bc7" class="bulleted-list"><li>当一个以保持了某些不可剥夺资源的进程，请求新的资源时得不到满足，它必须释放已经保持的所有资源，待以后需要时再重新申请。</li></ul><ul id="97847ebf-48da-49ff-bda3-c9a4b215db0d" class="bulleted-list"><li>采用资源有序分配法，给资源统一编号，进程只能按编号顺序请求资源。破坏“环路”条件。（保证上锁的顺序一致）</li></ul></li></ul><ul id="45d515d4-5a71-48db-af69-9e9e05da20f2" class="bulleted-list"><li>银行家算法？</li></ul></div></p><p id="239c4807-2bdf-4425-82e5-22035eedfc7e" class=""><strong>死锁解除的方法：</strong><div class="indented"><ul id="a7a0b66c-839f-4575-811e-7edb805c6649" class="bulleted-list"><li><strong>抢占</strong>「资源剥夺」：挂起某些死锁进程，抢占其资源，分配给其他死锁进程</li></ul><ul id="b6cf9ace-4cff-4b64-805c-2b6299444204" class="bulleted-list"><li><strong>杀死</strong>「撤销进程」：强制撤销部分或全部死锁进程，并剥夺资源</li></ul><ul id="5eede514-ff80-4e28-a69a-bbb168585a71" class="bulleted-list"><li><strong>回滚</strong>「进程回退」：让一个或多个进程回退到足以避免死锁的地步。这要求系统保持进程的历史信息，设置还原点。—— 进程回退是自愿释放资源而不是被剥夺。</li></ul></div></p><p id="2ba0e1b1-2316-4748-98ee-e200da0319d0" class="">
</p><h3 id="d429f6fb-e595-4451-8c59-a6a1ce145f29" class="">死锁检测算法</h3><ol id="8fa40a65-8e6c-4003-8c9b-2714af6ff4e5" class="numbered-list" start="1"><li>寻找一个没有被标记的进程<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>，它所请求的资源小于等于A</li></ol><ol id="986e2755-da75-41b4-9a69-68e75313c156" class="numbered-list" start="2"><li>如果找到了这样一个进程，则将C矩阵的第i行向量加到A中，标记该进程，并回到1</li></ol><ol id="955f49a7-8fe3-41a6-ae19-1432a8a05e4e" class="numbered-list" start="3"><li>如果没有这样一个进程，算法结束，没有被标记的进程都是死锁进程</li></ol><figure id="0e7e5770-c707-4217-a175-5de8fd0168a8" class="image"><a href="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%204.png"><img style="width:736px" src="%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%20430885c067634aae97e621ffe1e6ef7e/Untitled%204.png"/></a></figure><p id="174c6f48-2052-4940-9434-08fc96732337" class="">
</p><h3 id="d35992db-d911-40d3-b345-f33af928449d" class="">银行家算法描述？</h3><p id="91f4e134-4775-4ff6-accb-18fcccab9145" class=""><strong>安全状态：</strong></p><p id="378c9536-f729-4699-81b0-8eb4a9d5162f" class="">如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p id="bdb73f3b-faf4-4411-9a8d-2a570d5907ce" class=""><strong>检查安全状态的算法：</strong></p><ol id="cb5b97a0-eb2d-493c-bcfd-9e46f0e52003" class="numbered-list" start="1"><li>查找「还需分配资源矩阵」中是否存在一行小于等于「剩余可用资源向量A」。如果不存在，则将会发生死锁</li></ol><ol id="9ad0230b-44d6-4dc7-aabb-646a193a6ae3" class="numbered-list" start="2"><li>如果找到了这样一行，将该进程标记为终止，并将其已分配资源加到A中</li></ol><ol id="a21613e7-2e93-4591-a2cf-2fca03a31229" class="numbered-list" start="3"><li>重复以上两步，直到所有进程都标记为终止，则状态是安全的。</li></ol><p id="538176db-ff10-4a01-9af7-52d7e810a7e9" class=""><strong>银行家算法：</strong></p><p id="e833102a-d006-4679-b98b-8be3d3f85dbf" class="">当进程请求资源时，要判断「如果满足了请求，是否会进入不安全状态」，如果是就拒绝请求，否则予以分配。</p><p id="909f3641-cf13-4106-933c-de3a7d06d080" class="">
</p><p id="ad170b2e-346e-4fc5-a321-f3fe822bc9c8" class=""><em>emmm，如果是安全状态，但是那个能够推进的进程一直不申请，而分配给其他进程了就会进入不安全状态了怎么办——改进一下？要有两个推进进程才是安全状态？</em></p><p id="2dda8741-3648-4dd6-8881-6d6d7f0da1e5" class="">
</p><p id="43fd1eab-0471-4c1a-b852-457b02dbae06" class="">
</p><h3 id="78379aee-d9c0-4a46-847a-3619c2c42d1f" class="">找到造成死锁的进程怎么处理（杀死，抢占，回滚），❓回滚如何实现？</h3><ul id="f40e79d7-f395-42ef-8e85-9b1abb696630" class="bulleted-list"><li>杀死：撤销进程，剥夺资源</li></ul><ul id="3b3cfa55-42d1-4a81-acf2-08e5511c37dd" class="bulleted-list"><li>抢占：挂起进程，抢占资源</li></ul><ul id="1953be2c-3ca9-428e-969c-20066f3ebf2b" class="bulleted-list"><li>回滚：进程自愿回退，让一个或多个进程回退到足以避免死锁的地步。</li></ul><p id="a96fd529-0044-4957-b337-08bd6be90c18" class="">
</p><p id="e56a62b4-21da-4ef0-9f43-6fe8c106f2f4" class="">
</p><h3 id="b838a30e-1817-467e-9a07-b6a54b6f107d" class="">介绍一下几种典型的锁</h3><p id="4f5967f1-ceeb-4856-bbeb-8bc8c51aa4ea" class=""><strong>读写锁：</strong><div class="indented"><ul id="2d4c2854-f718-430a-a9ae-1c97e3da28f3" class="bulleted-list"><li>多个读者可以同时读</li></ul><ul id="bc030397-8f64-47c2-8ddd-d197a3f15ca4" class="bulleted-list"><li>写者必须互斥，读写也互斥</li></ul><ul id="5370c35f-6a33-4caf-bc20-b0e66f977472" class="bulleted-list"><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul></div></p><p id="6c26fadb-4993-4c46-8668-74af177d24ae" class=""><strong>互斥锁：</strong><div class="indented"><p id="4c8afd63-355b-412c-9b84-6232fdd02366" class="">一次只能一个线程拥有互斥锁，其他线程只能等待</p><p id="f16485f3-4060-42fa-974c-e07d31f3daa3" class="">进程/线程抢锁失败后会主动放弃CPU进入睡眠状态，等待唤醒。操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或进程，需要把锁交给操作系统管理，所以加锁时涉及上下文切换。</p></div></p><p id="94ba1ac8-3ca8-492d-82ef-94814ed4e65f" class=""><strong>自旋锁：</strong><div class="indented"><p id="01d00637-a9c8-419e-8e64-61d2ab02ceca" class="">如果进程/线程无法获得锁，不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</p></div></p><figure id="24b18df8-ab0d-44f1-870c-3c57413eb79d"><a href="https://www.cnblogs.com/xiaolincoding/p/13675202.html" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景</div><div class="bookmark-description">生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。 但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。 那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。 如何用好锁，也是程序员的基本素养之一了。 高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。 所以，知道各种锁的开销，以及应用场景是很有必要的。 接下来，就谈一谈常见的这几种锁： 多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。 最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。 如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。 所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。 对症下药，才能减少锁对高并发性能的影响。 那接下来，针对不同的应用场景，谈一谈「 互斥锁、自旋锁、读写锁、乐观锁、悲观锁 」的选择和使用。 最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。 加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。 当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的： 互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程， 既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞 。 对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的 。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图： 所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。 那这个开销成本是什么呢？会有 两次线程上下文切换的成本 ： 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行； 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。 线程的上下文切换的是什么？当两个线程是属于同一个进程， 因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。 上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。 所以， 如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。 自旋锁是通过 CPU 提供的 CAS 函数（ Compare And Swap ），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。 一般加锁的过程，包含两个步骤： CAS 函数就把这两个步骤合并成一条硬件级指令，形成 原子指令 ，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。 使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。 自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。 需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。 自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU ...</div></div><div class="bookmark-href"><img src="https://www.cnblogs.com/favicon.ico" class="icon bookmark-icon"/>https://www.cnblogs.com/xiaolincoding/p/13675202.html</div></div></a></figure><p id="a1ecf8c4-9f1e-48fa-9e31-9e2b473ee732" class="">使用原子操作模拟互斥锁的行为就是自旋锁，互斥锁的状态是有操作系统控制的，自旋锁的状态是由程序员自己控制的。</p><p id="ff77df27-5751-445e-a13b-200e1f99f810" class="">
</p><h3 id="2886c571-8cba-4f21-9aa2-767a92fae3f9" class="">⭐️简述自旋锁与互斥锁的使用场景</h3><p id="1136dd0a-4e59-4488-9e5e-a7649ddf0b79" class="">个人解答：互斥锁在获取锁失败之后会主动放弃CPU进入睡眠（阻塞状态），当锁被释放，又会从睡眠进入就绪状态，等待自己的时间片运行，需要两次上下文切换；而自旋锁在获取锁失败之后不会放弃CPU，而是一直循环尝试获取锁，知道获取为止，如果没有时间片这些限制，它就不需要线程切换。但是如果其他线程持有锁的时间很短，可以用自旋锁，避免额外的切换开销，否则用互斥锁。但是现代操作系统的互斥锁很多都是混合型的，会先自旋一段时间再放弃CPU，所以一般情况下都可以用互斥锁。</p><p id="bd79a30b-e4bd-4fcd-8157-6556c6b66e91" class="">
</p><p id="9ef1354f-a645-4f5e-a2ab-8296453a0b69" class="">自旋锁一般应用于<strong>加锁时间很短</strong>的场景，这时效率比较高。在多核系统上，特别是大量线程只会短时间持有锁的时候，<span style="border-bottom:0.05em solid">在使线程睡眠和唤醒线程上会浪费大量时间</span>，适合用自旋锁。</p><p id="e0122fe1-1668-4052-b76f-0dd2facbedc3" class="">在非抢占式调度器的单核系统上自旋锁没有用，因为线程会一直占用CPU去尝试获取锁，其他线程不可能运行，这个锁也不会被解锁。一般情况下互斥锁都是合适的，因为大多数现代的操作系统都是「混合型互斥锁」——在获取锁的时候先自旋一段时间。</p><p id="065c3759-7b63-4458-8d51-6a8ba81bd329" class="">
</p><h3 id="57d9048d-7c2b-4b89-bfa9-ace512c00924" class="">乐观锁、悲观锁？</h3><p id="79f5b1c3-f703-4db5-a175-e9b6bbf6797e" class=""><strong>乐观锁：</strong></p><p id="b3fe8115-96e6-470d-b28b-50a90fd3994e" class="">当认为数据被并发修改的几率比较大，需要在修改/读取之前，先对数据进行加锁的思想被称为悲观锁。</p><p id="884617b7-d998-41f1-a709-e20fc8d1e2ff" class=""><span style="border-bottom:0.05em solid">适合多写的场景。</span>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><p id="e7a68ee7-3692-4a98-89cc-647715046e06" class=""><strong>悲观锁：</strong></p><p id="f2674d72-9378-4361-a26e-4fcf6cd81792" class="">总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</p><p id="0f5e1d1f-c869-42d8-9c87-f8bedf7f1428" class=""><span style="border-bottom:0.05em solid">适用于多读的应用类型，可以提高吞吐量</span>，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p id="70c89a83-dff4-433f-a549-66aa85c02a26" class="">乐观锁常见的两种实现方式：版本号机制和CAS算法；</p><p id="120fe61d-4f50-4a6d-aaae-7fd5942f9878" class="">乐观锁的缺点：ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p><p id="568ea6fe-6dc6-4fc1-96dd-5d947e15ee4b" class="">
</p><h3 id="0ed24b3c-5d33-4d64-8d8f-dde1f5d51a0d" class="">多线程队列实现（读写锁 || 条件变量和互斥量）</h3><p id="d28af149-514a-4f1d-8a1d-eca54c16b731" class="">
</p><p id="c1ed8acb-e72f-4db5-879a-fc06939269a7" class="">
</p><p id="781c4d08-c0bb-4fff-83d0-887094a98ddf" class="">
</p><h3 id="bf103fc4-dbef-4277-987c-1d58757649aa" class="">自旋锁的实现</h3><p id="aaa96238-e57e-48b6-8e97-0a25df8e949c" class="">常见的自旋锁模型有TAS（Test-and-set）和CAS（Compare-and-swap）。</p><p id="2236b9de-9f0d-4231-a1ae-4b5f03d74d3c" class="">TAS实现自旋锁:</p><pre id="d59123cf-b19f-42aa-9eda-a2a0e0dd528c" class="code"><code>//自旋锁的实现
class spinlock{
public:
    spinlock():flag(ATOMIC_FLAG_INIT){}
    
    ~spinlock(){}
    
    void lock(){
        while(flag.test_and_set());
    }
    void unlock(){
        flag.clear();
    }
    
private:
    std::atomic_flag flag;
};


//以下为使用
spinlock sp;
void pr(){
    for (int i=0; i&lt;200000; ++i){
       sp.lock();

        ++num;

        sp.unlock();
    }
}</code></pre><p id="45690aed-b89f-46f8-8304-eb5befcb63df" class="">CAS实现自旋锁：</p><pre id="18857798-642c-45c5-bac2-573a7bfed0f7" class="code"><code>//自旋锁的实现
class spinlock{
public:
    spinlock():flag2(false){}
    
    ~spinlock(){}
    
    void lock2(){
        bool expected = false;
        while (!flag2.compare_exchange_strong(expected, true)){
            expected = false;
        }
    }
    void unlock2(){
        flag2.store(false);
    }
private:
    std::atomic&lt;bool&gt; flag2;
};

//以下为使用
spinlock sp;
void pr(){
    for (int i=0; i&lt;200000; ++i){
        sp.lock();

        ++num;

        sp.unlock();
    }
}</code></pre><p id="d5f5006a-6332-456d-be7f-1bdd1a8b9c7a" class="">注：C++的 <code>compare_exchange_strong</code> 和其它版本的不太一样，如果交换失败，会把expected 设为 newval， 所以要在while循环中再设置一遍，这个操作就很迷🤔</p><p id="99ca9810-f9ba-491e-ae5c-491d91a61f36" class="">
</p><p id="67980a8e-cd61-4f55-b7d3-25e365b4e1a9" class="">
</p><h3 id="484098c3-4fb0-46e6-a919-476539c2a6be" class="">❓无锁编程了解吗？</h3><p id="3fe5a10a-5a65-41e5-ab1a-50ec77d86142" class="">原子操作、内存栅栏等。</p><p id="a2ad8a91-231b-4285-9da1-c94486c6b3e5" class="">CAS是利用原子操作的一种无锁编程方式，中心思想是：先把某个内存存储的数据读出来，在新开辟的内存中进行一些操作，然后再次查看原内存中的数据是不是还是原来的数据，如果是，就把它和新内存中算出来的数据交换，如果不是，说明在这段时间这个数据被改了，那就重新进行上述操作。CAS会遇到ABA问题。</p><p id="8db9f3dc-7a80-4040-9b30-e9d4225da9c6" class="">ABA问题的解决方法：</p><ol id="405b8dc3-2da1-46e1-901c-ee0598f9bef3" class="numbered-list" start="1"><li>double-length CAS（DCAS）</li></ol><ol id="1b0c05c4-5d01-48b5-a843-19f31f2da2ab" class="numbered-list" start="2"><li>safe memory reclamation （SMR）</li></ol><p id="1e28d5bb-2fb5-4434-90f3-c8281bc20b93" class="">
</p><p id="d4fc4a7f-9d1f-47f8-bd48-bd065facf84b" class="">
</p><h3 id="f12ed70d-b88a-4764-a785-383dc18d9832" class="">能不能用无锁的方式来实现共享内存之间的同步？具体的解决方法描述一下？如果大家同时取的版本号都一样呢？</h3><p id="069fbcc6-fc19-4c68-9933-7b427be3f336" class="">
</p><p id="fbaf558f-16b7-40b7-a027-1ed622efc699" class="">
</p><h3 id="6dd7a58d-7d05-49e7-96dc-6a2931a918e7" class="">多进程如何对共享内存进行加锁（互斥锁），有没有性能更高的？（读写锁？）</h3><p id="ee2af897-1968-45bf-9ae4-13cbec4b910a" class="">
</p><p id="b04a486e-b6e1-4fe7-86a2-f7bad4f23cd8" class="">
</p><p id="fcdf1eb2-68cb-4a7c-b148-c1e1b548cc08" class="">
</p><p id="2f04386e-caac-4bed-b15a-5f8dda599f60" class="">
</p></div></article></body></html>