<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>STL</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="e08fa8cf-2eb7-4eb6-9554-99d6bf0bee68" class="page sans"><header><h1 class="page-title">STL</h1></header><div class="page-body"><hr id="14586d55-eaf6-4ce2-9441-36f5666394c2"/><p id="8fe0177e-c841-485a-911f-6ffcfc01cc22" class="">
</p><p id="d8a3ab25-b863-4dfa-85db-03bb458fda70" class="">
</p><p id="5d19850e-4488-4387-b7bb-c9b40326524b" class="">
</p><nav id="49d7fc94-d444-4e7a-b4e7-2160c8132607" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9b0876d9-644e-4564-a561-375034990dd3">通用</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f6479c51-f1ac-4b7a-a1db-ae32fcc39b41">STL六大组件？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#99809d86-80b2-4ec4-aa96-3e7c227d8c9c">有哪两种类型的容器？分别有哪些？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ae4dec49-1c30-4469-9822-4e2451bef4af">每种容器对应的迭代器？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#00d68fb4-6a29-4e2f-823e-59d3e361988a">常见容器性质总结？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#812b77f8-9116-4c00-a129-9391a5795bf6">traits技法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ad7a4e0e-41bd-4ef1-bf91-2a8e3ea9ac4f">空间配置器？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a72b464e-6d29-48e2-88e1-f2d490337f96">容器内部删除一个元素？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0b313033-56bb-4dc7-840e-3a4c1ccdaf29">迭代器如何实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d66dcfd7-2c55-49a6-b3bb-765ce26f3221">迭代器失效的情况？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1130af19-967c-4c29-bc2c-bf082effcfe5">vector</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1242d956-ae7c-451f-ad06-74abbe959dde">vector的实现</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#62175be3-de1d-47b3-a17b-feebefe70f6a">vector的增加和删除是怎么做的？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d000704f-55f7-49ee-be8e-650b0be6de9c">vector的动态扩容的规则？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8f826a0c-0bed-45e5-a0e4-589d088f1a37">为什么是两倍扩容？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#82b8e5b3-5f42-44f7-8242-7d8b8a791a47">vector如何释放空间？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#48b973b7-29b9-4ffa-94e7-bdd2b988a370">list</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8a7d94a8-768a-4386-ba3e-fb74a8006bdc">list的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6d7c303f-175c-4d94-a8bc-ecc2fd3671ce">list的size是如何实现的？遍历还是用一个变量记录？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d82c3ce9-3c84-4f1c-b245-191d4c4b03b9">slist是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cb2a3333-a25f-4795-a867-bfc7d579dc7f">list有哪些方法？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f22353cb-0d33-4940-9350-97e54f591419">queue、stack</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8d9427aa-6c11-4a2d-b9e4-ced8b580ca3e">deque的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5b19a105-f7dc-498a-a4b8-6dae4bf506a1">stack的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#eb67c5c2-b59a-4acd-a5f2-a10b0ec88264">queue的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#85e82971-28b3-4251-b199-c7c2a9194739">priority_queue的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7a32d790-33d8-47db-b8e6-7777186c920e">map、set</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#db13a499-1b8d-4815-9a8c-9da99566efeb">set的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b96ab76d-b20d-4d2a-83dd-f61bbae468ba">map的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ddd46316-762e-412b-aaf0-68ca4018043d">map的插入方式有几种？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#35902c8c-23ef-4b86-bb58-6283a22478e9">map中[]和find的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#26faa08e-9704-4720-84c8-6a99c10201d6">什么是红黑树？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#51f15bf4-12db-4e9f-af14-08d8cbffe355">红黑树是平衡二叉树吗？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#416db510-db3f-4385-b221-d0178298d43c">unordered_map（hash_map）和map的区别？应用场景？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d68c4775-ddc9-41f5-ae28-7eccc5e542d1">hashtable的实现？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6915877d-4f2f-4396-b788-abf85611a134">hashtable中解决冲突有哪些方法？</a></div></nav><p id="c15d4c5d-d745-4a8f-9e11-41366d81913d" class="">
</p><p id="31754e01-c886-43ec-a593-80bb09ccea14" class="">
</p><p id="2a75a724-4a31-4b8e-a8bd-eab7c4320d63" class="">
</p><h2 id="9b0876d9-644e-4564-a561-375034990dd3" class="">通用</h2><h3 id="f6479c51-f1ac-4b7a-a1db-ae32fcc39b41" class="">STL六大组件？</h3><ol id="4ddc33e1-5521-4899-b2fa-d35e0e4ca9af" class="numbered-list" start="1"><li>容器（containers）<p id="75ff4e06-441b-43f1-a0e2-a19361fd9805" class="">用来存放数据的各种数据结构</p></li></ol><ol id="9a05a834-b05c-4288-861a-0bf64465db49" class="numbered-list" start="2"><li>算法（algorithms）<p id="2b90e7a8-aa51-4e5e-90b2-02317b9bc2c5" class="">各种算法</p></li></ol><ol id="c834b0a0-16b4-47f3-acbd-c3201190625d" class="numbered-list" start="3"><li>迭代器（iterators）<p id="40c08c7a-b0ea-4866-bb79-bd2d195d388e" class="">容器和算法之间的胶合剂，是“范型指针”</p></li></ol><ol id="164829f0-f435-408e-a729-e4c521e53791" class="numbered-list" start="4"><li>仿函数（functors）<p id="a876f9d2-da38-4883-9a2f-743adb684a42" class="">可作为算法的某种策略</p></li></ol><ol id="a0a2389c-6803-416c-a2bd-c114eb01b060" class="numbered-list" start="5"><li>配接器（adapters）<p id="000c51b7-b0a0-4d5b-84fb-b660f335a72e" class="">修饰容器或仿函数或迭代器接口的东西</p></li></ol><ol id="8333a547-a2d7-422c-80bd-cfdf93c90038" class="numbered-list" start="6"><li>配置器（allocators）<p id="1401d80e-0f82-4b99-bfcf-b67a863e41f7" class="">负责空间配置和管理</p></li></ol><p id="3e47becc-d264-4e60-8807-8c9514e42c20" class="">
</p><h3 id="99809d86-80b2-4ec4-aa96-3e7c227d8c9c" class="">有哪两种类型的容器？分别有哪些？</h3><ul id="c91c03c3-56b9-421b-be1c-d7397f0a73e2" class="bulleted-list"><li>序列式容器：array（C++内建）、vector、list、deque、（stack、queue、priority-queue）</li></ul><ul id="6d362ce6-d083-41a1-b9c0-d714c7fe3edd" class="bulleted-list"><li>关联式容器：set、map、multiset、multimap</li></ul><p id="03308e4d-c11d-4c7b-9a31-3a79326ea25a" class="">
</p><h3 id="ae4dec49-1c30-4469-9822-4e2451bef4af" class="">每种容器对应的迭代器？</h3><figure id="ed4937d1-7c3e-4f55-b6cf-59be84d5c186" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled.png"><img style="width:1232px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled.png"/></a></figure><p id="d65cb2bd-6b69-4544-bb16-930bff238239" class="">
</p><h3 id="00d68fb4-6a29-4e2f-823e-59d3e361988a" class="">常见容器性质总结？</h3><ul id="2dc03659-c9e1-4d84-85be-e7319f61ed96" class="bulleted-list"><li><strong>vector</strong> 底层数据结构为数组 ，支持快速随机访问</li></ul><ul id="39662e25-d888-4c4a-b811-d974b5b97191" class="bulleted-list"><li><strong>list</strong> 底层数据结构为双向链表，支持快速增删</li></ul><ul id="e9033861-db1c-4755-ac6a-5eb3c674827b" class="bulleted-list"><li><strong>deque</strong> 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾(中间不能)快速增删，也支持随机访问
deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下：[堆1] --&gt; [堆2] --&gt;[堆3] --&gt; ...<p id="8f513b53-9b89-4a8d-bdb1-6fd4916be31f" class="">每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p></li></ul><ul id="46e14abd-bd9d-4275-b839-57a4364eabf4" class="bulleted-list"><li><strong>stack</strong> 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</li></ul><ul id="39b1fcb6-64a2-4f95-a317-a1c28c474864" class="bulleted-list"><li><strong>queue</strong> 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时(stack和queue其实是适配器,而不叫容器，因为是对容器的再封装)</li></ul><ul id="2c839c34-1e56-4fbe-bc9e-b622e4046a8a" class="bulleted-list"><li><strong>priority_queue</strong> 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</li></ul><ul id="8a522208-0f59-4e73-a7ac-a45303ce5d68" class="bulleted-list"><li><strong>set</strong> 底层数据结构为红黑树，有序，不重复</li></ul><ul id="fd4a682a-ef1e-416a-b6c6-6caef810a244" class="bulleted-list"><li><strong>multiset</strong> 底层数据结构为红黑树，有序，可重复</li></ul><ul id="d024d2db-22a3-4ebc-817b-b49265aa75d6" class="bulleted-list"><li><strong>map</strong> 底层数据结构为红黑树，有序，不重复</li></ul><ul id="f14fa2e3-d1d0-41ae-aa64-bee2ada6f63a" class="bulleted-list"><li><strong>multimap</strong> 底层数据结构为红黑树，有序，可重复</li></ul><ul id="ae1378b6-9af5-4d7b-b055-9fe5452d47bd" class="bulleted-list"><li><strong>unordered_set</strong> 底层数据结构为hash表，无序，不重复</li></ul><ul id="e731edf4-412c-4729-85f0-6e77346cf6d5" class="bulleted-list"><li><strong>unordered_multiset</strong> 底层数据结构为hash表，无序，可重复</li></ul><p id="8df8bc71-a2bb-4464-bbc5-298c1fba1d4d" class="">
</p><h3 id="812b77f8-9116-4c00-a129-9391a5795bf6" class="">traits技法？</h3><p id="d706792c-3e75-4133-9b15-79933fe035c9" class="">traits技法利用“内嵌型别“的编程技巧与<strong>编译器的template参数推导功能</strong>，增强C++未能提供的关于型 别认证方面的能力。常用的有iterator_traits和type_traits。</p><p id="aee7c9c3-1be9-4bb4-b159-467cdebc353d" class=""><strong>iterator_traits</strong><div class="indented"><p id="14e60e48-312d-46c4-bda4-31fe6b978b7e" class="">特性萃取机，能够让外界获取一下5种型别：</p><ul id="ee3fb91b-f1d6-4b4c-8eb5-70a336384a83" class="bulleted-list"><li>value_type：迭代器所指对象的型别</li></ul><ul id="60846805-e3fb-4f96-ade4-1366084adfe0" class="bulleted-list"><li>difference_type：两个迭代器之间的距离</li></ul><ul id="c3b8c510-f4e8-450b-8221-c2b381a8fc72" class="bulleted-list"><li>pointer：迭代器所指向的型别</li></ul><ul id="888f9cb3-6f1c-48db-bf21-613da4f9a262" class="bulleted-list"><li>reference：迭代器所引用的型别</li></ul><ul id="e31b7e28-2ff0-4d9e-bb1d-975cdd651675" class="bulleted-list"><li>iterator_category：迭代器的种类<ul id="6fdb7bcf-6db6-4e5a-a5c6-ddaa2368482b" class="bulleted-list"><li>Input Iterator</li></ul><ul id="d13182ba-43e0-46b7-848f-cc8bd4a34ea2" class="bulleted-list"><li>Output Iterator</li></ul><ul id="4bc1914b-5cc3-4c95-ac0f-abc4755cba7c" class="bulleted-list"><li>Forward Iterator</li></ul><ul id="4f0c8f0b-a541-4999-a374-0ceb2ec19605" class="bulleted-list"><li>Bidirectional Iterator</li></ul><ul id="16b3459a-787c-4db1-8109-d7af214c1cad" class="bulleted-list"><li>Random Access Iterator</li></ul></li></ul></div></p><p id="081972fc-4f5f-420c-85d9-bc104c840200" class="">__<strong>type_traits</strong><div class="indented"><p id="f514088f-fad6-4810-8cb0-55faaa039502" class="">关注型别的特性，因此在对某个型别进行构造、析构、拷贝、赋值等操作时，就可以采用最有效率的措施。</p><pre id="698a1329-8430-43ae-83bc-364ace24a345" class="code"><code>//__type_traits支持以下五种类型的判断
__type_traits&lt;T&gt;::has_trivial_default_constructor
__type_traits&lt;T&gt;::has_trivial_copy_constructor
__type_traits&lt;T&gt;::has_trivial_assignment_operator
__type_traits&lt;T&gt;::has_trivial_destructor
__type_traits&lt;T&gt;::is_POD_type


//得到的结果是
struct __true_type{};
struct __false_type{};</code></pre></div></p><p id="5a08280e-82b2-4242-ac15-8566f2131c10" class="">回去看一下。</p><p id="d9ee9fae-c1b4-4e29-b334-196ec7810148" class="">
</p><h3 id="ad7a4e0e-41bd-4ef1-bf91-2a8e3ea9ac4f" class="">空间配置器？</h3><p id="88730430-1499-48a2-a51e-b00cd2ac183d" class="">用于配置内存。分为一级配置器和二级配置器。</p><p id="d8073691-f1fc-490e-9b83-065d08f2004e" class=""><strong>为什么要有两级？</strong></p><ul id="d88bc22d-11b0-46c3-b4ea-26b7f323bc92" class="bulleted-list"><li>我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间;</li></ul><ul id="edbae5d5-a036-4310-9a1f-dd7f6e9beb7e" class="bulleted-list"><li>每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率;</li></ul><ul id="e13cdc7d-cafe-4b7b-b857-2a7cab49cd61" class="bulleted-list"><li>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效
率。</li></ul><p id="bf41e6ae-f2bd-43ca-a11b-3e5bc64d682c" class=""><strong>介绍：</strong></p><p id="f3c8cbaf-d206-44d4-871a-dacf1c9c635b" class="">默认的配置器是二级配置器，但是当要求的内存大小大于128bytes，会调用一级配置器。</p><ul id="10cc1f63-2eaa-4865-84f9-a515544c90cf" class="bulleted-list"><li>一级配置器：<figure id="535d7414-a2a2-4726-b3c3-dd7c54883778" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%201.png"><img style="width:576px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%201.png"/></a></figure></li></ul><ul id="a8a0d17d-32fd-4e27-a872-2a2f47e108b6" class="bulleted-list"><li>二级配置器：<p id="7bc00652-cc22-4c0d-a973-a6fbafa4e34f" class="">在二级配置器中，由于要求的内存小，如果零散管理会导致内存碎片和配置时的额外负担。因此用内存池来管理。每次配置一大块内存，并维护对应的自由链表。共有16个自由链表，每个对应一种内存块大小，为8～128的8的倍数。</p><p id="540ca9e0-3007-4ea4-a405-7d32f4c4aa33" class="">当要新的一块内存时，从对应大小的链表中取一块，如果链表中没有了，就从内存池中新取20个对应大小的块给链表，其中一个交给客端，19个放在链表中继续维护，如果不够20个，就有多少取多少，如果一个都没有了 → </p><p id="7998a5db-1e0f-4913-9db2-6f9816e71756" class="">如果内存池中也没有了，就把内存池中剩余的一丢丢空间挂在相应的链表上，然后重新malloc <code>2*需求量+附加量</code> 的内存，然后其中20个给链表维护（1+19），其余的放在内存池中。</p><figure id="81b9f813-7fe5-4d3b-a67c-523f2b1d3462" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%202.png"><img style="width:1316px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%202.png"/></a></figure></li></ul><p id="0e3c3ace-203c-4970-a986-6f8f3f9f18d1" class="">缺点：</p><ol id="630206fe-2c49-4c32-900c-97bbbf5f3ccd" class="numbered-list" start="1"><li>因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它 会给你8个字节，即浪费了7个字节，所以它又引入了<strong>内部碎片</strong>的问题，若相似情况出现很多次，就会造成很多内部碎片</li></ol><ol id="b284355e-276f-4f46-931f-1a1384c2dc94" class="numbered-list" start="2"><li>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过 程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全 是静态的，所以它申请的所有内存只有<strong>在进程结束才会释放内存</strong>，还给操作系统，由此带来的问题有: <ol id="4fd76716-4869-4917-b004-133751f3bc90" class="numbered-list" start="1"><li>即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败</li></ol><ol id="f7b399a8-a7d6-4880-8185-5bc2461a3af7" class="numbered-list" start="2"><li>若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请 不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li></ol></li></ol><p id="949be3db-9c54-460a-bdd8-b85119f81132" class="">
</p><p id="15c6262b-dfe9-4f59-a711-d494b2021e9c" class="">
</p><h3 id="a72b464e-6d29-48e2-88e1-f2d490337f96" class="">容器内部删除一个元素？</h3><p id="5427b856-c49b-4bb2-bc3c-6eb221b10df5" class="">
</p><p id="ccedab5b-a798-46f5-a929-ff64c2a09c46" class="">
</p><h3 id="0b313033-56bb-4dc7-840e-3a4c1ccdaf29" class="">迭代器如何实现？</h3><p id="a84a4f7e-5d88-4ad2-828a-2641bbef76e0" class="">迭代器提供了一个遍历容器内部所有元素的接口，也作为容器和STL算法的粘合剂。</p><p id="886f1668-aa50-4b75-8168-026127670814" class="">迭代器内部保存了一个与容器相关联的指针，然后<strong>重载各种运算操作，最重要的是*和→，以及++、—等可能需要重载的运算符</strong>。</p><p id="cf602ddf-3745-4c77-9b32-41e5de473844" class="">类似于智能指针。</p><p id="d1b88d74-46a4-4134-9a2d-788d6025dc83" class="">
</p><h3 id="d66dcfd7-2c55-49a6-b3bb-765ce26f3221" class="">迭代器失效的情况？</h3><p id="880f2bd0-86a0-4887-887b-02449189e969" class=""><strong>对于连续内存的序列式容器</strong></p><p id="6fba140e-e39c-4463-8640-f6f3af379b56" class="">插入元素时：</p><ul id="023b9600-629d-489b-8397-59f836d26fb5" class="bulleted-list"><li>size&lt;capacity时，插入点及其之后的迭代器失效</li></ul><ul id="6ae6386c-a8e5-4fa7-83df-33fc8fe08c0d" class="bulleted-list"><li>size==capacity时，所有迭代器都失效</li></ul><p id="cbe50fe1-019a-46ed-8475-95a12e7e2920" class="">删除元素时：</p><ul id="83a2166e-3ede-4155-818a-a72d4d9351d4" class="bulleted-list"><li>删除位置到尾的所有迭代器失效</li></ul><p id="b17c2796-ae5a-4b06-84ce-0fddc614dc44" class="">
</p><p id="9e82320c-9d74-4c64-a28d-b2af89f2f994" class=""><strong>对于非连续内存的序列式容器</strong></p><ul id="6a4c37d7-ca02-4339-a1b5-42eaa54ad103" class="bulleted-list"><li>删除节点仅当前迭代器失效</li></ul><p id="51c0e1a1-9192-4d30-969b-0346795a996c" class="">
</p><p id="8e28888f-1b71-4ed9-b713-e40916ea7a0e" class=""><strong>对于关联式容器</strong></p><ul id="c822ebe8-f576-456e-b04e-03621c7dffe3" class="bulleted-list"><li>底层是红黑树删除节点不会影响其他节点的迭代器，使用递增方法获取下一个迭代器 mmp.erase(iter++)</li></ul><p id="d2737540-4902-4947-a6ba-da24f2095158" class="">
</p><h2 id="1130af19-967c-4c29-bc2c-bf082effcfe5" class="">vector</h2><h3 id="1242d956-ae7c-451f-ad06-74abbe959dde" class="">vector的实现</h3><p id="f9f3df1f-c9c7-4034-8fd6-50af0b31dc74" class="">vector是一种<strong>序列式容器</strong>，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于<strong>空间运用的灵活性</strong>，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则 使用<strong>灵活的动态空间配置</strong>，维护一块连续的线性空间，在空间不足时，可以自动扩展空间容纳新元素， 做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。</p><p id="09525026-d4f7-4791-8805-f56d3e1e402c" class="">
</p><h3 id="62175be3-de1d-47b3-a17b-feebefe70f6a" class="">vector的增加和删除是怎么做的？</h3><ul id="50718c86-473f-429a-8b9f-0307b2a34b48" class="bulleted-list"><li>新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素</li></ul><ul id="ec8ea756-cc27-4e38-a470-d1ce38c13d30" class="bulleted-list"><li>删除元素：<ul id="abc39c40-1b7e-47e4-b021-330ccde40868" class="bulleted-list"><li>pop_back()</li></ul><ul id="6284e390-4172-4843-b784-b2a2fd54e6d7" class="bulleted-list"><li>erase() 删除由迭代器指定的元素或制定范围的元素</li></ul><ul id="2caba0ed-e898-4807-807b-00a84c5645de" class="bulleted-list"><li>remove() 通用算法删除，但不会改变容器的大小</li></ul></li></ul><p id="8061860b-d500-449b-8b39-0174816d3011" class="">
</p><h3 id="d000704f-55f7-49ee-be8e-650b0be6de9c" class="">vector的动态扩容的规则？</h3><p id="31c3b580-81c3-4f4c-acc3-3dec861232ba" class="">当空间不足时，以原大小的两倍配置另外一块较大的空间(或者旧长度+新增元素 的个数)，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍。</p><p id="5b580322-41a6-4a6f-b26b-49d0f70f4800" class=""><code>const size_type len = old_size + max(old_size, n);</code></p><p id="18034c0b-db1f-4729-bd49-e9ae4abeac20" class="">然后将原内容拷贝过来，再开始在原内容之后构造新元素，并释放原空间。</p><p id="ccf8ff20-574e-4955-9060-e937bee76054" class="">个人理解：这个扩容的操作应该是用空间配置器来做的吧。</p><h3 id="8f826a0c-0bed-45e5-a0e4-589d088f1a37" class="">为什么是两倍扩容？</h3><p id="dc217f27-520c-4b4e-a660-f1d3d4d2f1e4" class="">好像是实验经验，这样效率比较高。</p><p id="d0673364-92ef-4927-a5e0-1a3419d54c6c" class="">
</p><h3 id="82b8e5b3-5f42-44f7-8242-7d8b8a791a47" class="">vector如何释放空间？</h3><p id="1317546b-8602-4fd1-8bba-f14c5cc738eb" class="">vector的内存占用空间<strong>只增不减</strong>，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留 下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。 empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空 间依然如故，无法保证内存的回收。</p><p id="9ee2a448-f700-4ca8-84c6-4f03a64b9191" class="">可以用swap()来帮助你释放内存。</p><pre id="e7775ef8-1427-438f-ba2e-68553fd74cc9" class="code"><code>//释放多余的空间（收缩到合适）
vector&lt;int&gt;(ivec).swap(ivec);
//强行释放所有内存
vector&lt;int&gt;().swap(ivec);</code></pre><p id="32fbdc97-c1f8-4d16-b65e-eece9c4b4276" class="">
</p><h2 id="48b973b7-29b9-4ffa-94e7-bdd2b988a370" class="">list</h2><h3 id="8a7d94a8-768a-4386-ba3e-fb74a8006bdc" class="">list的实现？</h3><p id="6913e56f-97c0-4ef6-a57e-2451acb4dcfb" class="">是一个<strong>双向链表</strong>。而且还是环状双向链表。</p><p id="ae7aceff-5f44-4c2b-9784-7dc1467a2a21" class="">list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节 点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</p><p id="fb79f6be-3889-453e-a654-5003e7958680" class="">list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</p><p id="d32f6fd5-5cd8-45b1-aaad-8d77661e1aad" class="">
</p><h3 id="6d7c303f-175c-4d94-a8bc-ecc2fd3671ce" class="">list的size是如何实现的？遍历还是用一个变量记录？</h3><p id="eb5e45a3-6479-403b-9128-2d3091489c91" class=""><strong>遍历实现的。</strong></p><p id="f70575fd-2049-4773-879c-a525301d17c1" class="">作者考虑了某些函数的性能，取了折中。</p><p id="85a06b85-7c45-4faf-9785-8892786b75ea" class="">假如用变量size来记录，那么进行一些拼接和拆分操作的时候，如何更新size呢，必须要遍历来做，这就要O(N)的时间。所以干脆直接不更新，要知道长度的时候再遍历求取。</p><p id="e82ccac7-aa8b-4aaf-943e-9de79e30add6" class="">
</p><p id="82c8ed36-a85b-4ddd-b6b9-b07293cb6da9" class="">
</p><h3 id="d82c3ce9-3c84-4f1c-b245-191d4c4b03b9" class="">slist是什么？</h3><p id="cf67a2c4-8785-4d39-b2a7-26794d3eea27" class="">是<strong>单向链表</strong>。</p><p id="d55c4e80-37dc-4e80-b1e1-9463a9408160" class="">与list的区别：list的迭代器是双向 的Bidirectional iterator，slist的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p id="31ff472e-ce3b-470c-9d30-e6f8a6d091fd" class="">需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++ 11中出现，它与slist的区别是没 有size()方法。</p><p id="f020eee9-9144-443c-9814-f219d539abd4" class="">
</p><h3 id="cb2a3333-a25f-4795-a867-bfc7d579dc7f" class="">list有哪些方法？</h3><p id="58884a0f-8c1e-4ab9-a91b-7472362447e0" class="">push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort</p><p id="e8c6d091-69c3-41fc-a0f1-68c7ecd0951e" class="">
</p><p id="dc469878-9d11-4eee-879b-37b9e308cd99" class="">
</p><h2 id="f22353cb-0d33-4940-9350-97e54f591419" class="">queue、stack</h2><h3 id="8d9427aa-6c11-4a2d-b9e4-ced8b580ca3e" class="">deque的实现？</h3><p id="2eb8ac85-6ed4-4cdf-a359-af4817d11299" class="">vector是单向开口(尾部)的连续线性空间，deque则是一种双向开口的连续线性空间。</p><p id="2b57cc22-84c5-4c7a-a6a9-c09a856fcd31" class="">deque与vector的区别？</p><ol id="40f9cd7a-ac3e-4f69-aab6-1c68a990ce85" class="numbered-list" start="1"><li>deque以常数时间对头端进行元素操作</li></ol><ol id="48c8bc15-f2a3-40c7-a871-ff058d8dd1df" class="numbered-list" start="2"><li><strong>没有容量的概念，动态地以分段连续空间组合而成</strong>，可以随时增加一段新的空间并链接起来</li></ol><p id="19f53549-0cd3-4e2a-8417-e9ef34e0c8b4" class="">具体实现：</p><p id="5bd1c68c-f9b4-4dd5-a2e6-3401f65b273d" class="">deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头 部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性</p><figure id="0480159e-9063-4d0e-8e8b-ab2690a345b6" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%203.png"><img style="width:1214px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%203.png"/></a></figure><p id="0583a636-bd3a-4699-9d21-7bbeed49bad1" class="">
</p><p id="21f6684f-1f48-4667-9013-c3087425c2ae" class="">deque内部有<strong>一个指针指向map</strong>，map是一小块连续空间，其中的每个元素称为一个节点，node，每 个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的 区域，默认大小512bytes。整体结构如上图所示。</p><p id="fd4d1ed5-87ca-4bd5-aa87-61905e7ea5bf" class="">设计中最关键的是，deque迭代器的前进和后退，一旦行进时遇到缓冲区边缘，要特别当心，可能要跳一个缓冲区。</p><p id="1cddbc8b-c761-4da8-9490-7801d7c25792" class="">当map不够时，要reallocate_map，配置一块新的空间，新空间的大小是 <code>map_size+max(map_size, nodes_to_add)+2</code> </p><p id="fbec75f8-24f7-413b-8cd0-d1c0ce86c549" class="">
</p><h3 id="5b19a105-f7dc-498a-a4b8-6dae4bf506a1" class="">stack的实现？</h3><p id="89fa978a-7370-4ac1-b49d-816fa80e5f66" class=""><strong>先进后出(First In Last Out)</strong>的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素。<strong>没有迭代器。</strong></p><p id="aebf7606-77a4-4f58-983e-5a396a0a6dc9" class="">stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，只需要根据stack的性质对应<strong>移除某些接口</strong>即可实现。底层默认为deque，也可以用list实现。</p><p id="a80b63eb-ff66-4f9f-858a-b5276f34946e" class="">stack这种“修改某种接口，形成另一种风貌”的行为，成为<strong>adapter(配接器)</strong>。常将其归类为 container adapter而非container。</p><p id="75bcd175-ecf3-4259-97ad-203066677256" class="">
</p><h3 id="eb67c5c2-b59a-4acd-a5f2-a10b0ec88264" class="">queue的实现？</h3><p id="a257bac7-2f45-40e0-86bd-8f2aa4591d0c" class=""><strong>先进先出(First In First Out)</strong>的数据结构，只有一个入口和一个出口，分别位 于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素</p><p id="e8f5ff2f-14fa-4c63-9408-a7196b40565e" class="">同样也可以用deque或list作为底层来实现。</p><p id="d7e4fb2f-3df1-4cc8-9191-a4896617ea75" class="">
</p><h3 id="85e82971-28b3-4251-b199-c7c2a9194739" class="">priority_queue的实现？</h3><p id="fa93f70d-326b-4139-b412-d9f6adf3fdaa" class="">底层容器是vector，<strong>底层处理规则是heap（堆），而heap的底层存储又是vector</strong>。</p><p id="3d201f31-0f29-4ba5-96a6-40459f58e79e" class="">heap本质是一种完全二叉树。</p><p id="f5652527-c424-45eb-98b9-a343c9ea38fb" class="">heap的几种算法：</p><ul id="14b9f2f9-8a3d-4d30-accf-e876e699fd59" class="bulleted-list"><li>插入（push_heap）：上溯</li></ul><ul id="5027437d-3ca0-4809-9673-c6416a89af5f" class="bulleted-list"><li>弹出（pop_heap）：下溯</li></ul><ul id="f2e13769-8bbd-4ce0-a539-4d332b6a8fc7" class="bulleted-list"><li>排序（sort）：不断执行pop_heap直到树为空，即可得到一个递增序列</li></ul><ul id="004cac5c-1ced-41da-845d-b999f63ab83f" class="bulleted-list"><li>构造（make_heap）：将一段数据转化为heap，一个一个数据插入</li></ul><p id="46d3b342-3fa6-4059-a7a7-1b430d8891fa" class="">heap不可遍历，没有迭代器。</p><p id="2ddfc694-22a1-47f2-8232-29e4dc08de30" class="">
</p><p id="3d7dae94-d1f0-4c92-a3fa-889002153e60" class="">
</p><p id="5e019907-b19c-4c8a-a30b-c955ebe41bac" class="">
</p><p id="139f5c41-8291-4bda-bc0c-6fe618b4d8b2" class="">
</p><h2 id="7a32d790-33d8-47db-b8e6-7777186c920e" class="">map、set</h2><h3 id="db13a499-1b8d-4815-9a8c-9da99566efeb" class="">set的实现？</h3><p id="42148665-c95b-415d-bcd5-3df195971baa" class="">关联式容器。所有元素都会根据元素的值自动被排序(默认升序)，set元素的键值就是实值，实值就 是键值，set不允许有两个相同的键值。</p><p id="7a911bdb-22c0-406a-8b15-ce2741a5efee" class="">set不允许迭代器修改元素的值，其迭代器是一种constance iterators。</p><p id="79ebb93f-0570-41ca-9312-173941744604" class="">以RB-tree（红黑树）作为底层机制。</p><h3 id="b96ab76d-b20d-4d2a-83dd-f61bbae468ba" class="">map的实现？</h3><p id="628177ff-2b08-4321-a050-76a92db930fb" class="">所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值 (value)两个部分，并且不允许元素有相同的key。</p><p id="d0c7b56b-7748-403e-b68b-4dd665469239" class="">一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既 不是constant iterator，也不是mutable iterator。</p><p id="7c28b96a-e2f8-4855-bb6f-1b3bd4ca3078" class="">以RB-tree（红黑树）作为底层机制。</p><p id="a351a9ab-577c-4563-86a9-981ff140b23d" class="">
</p><h3 id="ddd46316-762e-412b-aaf0-68ca4018043d" class="">map的插入方式有几种？</h3><pre id="c956ff0e-d86d-44e1-a746-7ab6a861bb23" class="code"><code>//1) 用insert函数插入pair数据，
mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));
//2) 用insert函数插入value_type数据
mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); 
//3) 在insert函数中使用make_pair()函数
mapStudent.insert(make_pair(1, &quot;student_one&quot;));
//4) 用数组方式插入数据
mapStudent[1] = &quot;student_one&quot;;</code></pre><p id="ed2b817c-2c81-47c8-a5c8-60a44cac4c35" class="">
</p><h3 id="35902c8c-23ef-4b86-bb58-6283a22478e9" class="">map中[]和find的区别？</h3><p id="8ec974f1-45ff-4ef0-b6cb-76cf4f8bb385" class="">都是用关键码key执行查找，</p><ul id="e148504d-554c-4634-b288-8427c305a1cb" class="bulleted-list"><li> []如果找到了就返回对应的值，如果没找到就将一个具有该key和值类型的<strong>默认值</strong>的项插入这个map</li></ul><ul id="698045ed-4eb0-4b09-8e5f-10f3bd3a882b" class="bulleted-list"><li>find如果找到了就返回该位置的迭代器，如果没找到就返回尾迭代器</li></ul><p id="f9cc0858-3a05-4fb5-beb0-517e7885f249" class="">
</p><p id="eef171c7-9471-4855-8680-ad568fadd6eb" class="">
</p><h3 id="26faa08e-9704-4720-84c8-6a99c10201d6" class="">什么是红黑树？</h3><ol id="ed65e0d0-72e0-4d7e-856d-29d4d9ef3dfa" class="numbered-list" start="1"><li>是一种二叉搜索树<ul id="9ae9ae94-68c7-4e10-bd85-d45425a6ab2b" class="bulleted-list"><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</li></ul><ul id="db3807b2-bb5b-4472-a359-da5c883543db" class="bulleted-list"><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</li></ul><ul id="81acfe6d-b250-43c9-ac2f-930230df6cc1" class="bulleted-list"><li>左、右子树也分别为二叉排序树。</li></ul></li></ol><ol id="00f467d6-88c4-4cdc-970e-18312a34fffc" class="numbered-list" start="2"><li>满足几点要求<ul id="4dab8703-c838-4d2c-a1e0-39c835dc6b4d" class="bulleted-list"><li>树中所有节点非红即黑。</li></ul><ul id="277b2c37-ad7b-42ab-8f7a-10e95d18eff9" class="bulleted-list"><li>根节点必定为黑</li></ul><ul id="87473ae7-46ce-4576-af71-9fe13b92afdd" class="bulleted-list"><li>红节点的子节点必定为黑</li></ul><ul id="f24f0334-a076-4361-ac0f-372d94a2a2ea" class="bulleted-list"><li>从任一节点至(NULL)树尾端的任何路径，所含的黑节点数量必相同</li></ul></li></ol><ol id="ab2dbaeb-dd72-4768-b637-4fcf70501eff" class="numbered-list" start="3"><li>查找时间为<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></li></ol><p id="6d032531-9906-4fc8-9852-55796f3902d7" class=""><strong>每次插入和删除导致的不平衡都能在一次改颜色和两次旋转之内完成</strong></p><p id="7b5ce124-27b8-4d44-a5a2-966dd650335e" class="">
</p><h3 id="51f15bf4-12db-4e9f-af14-08d8cbffe355" class="">红黑树是平衡二叉树吗？</h3><p id="1637e1ec-f2cd-4fc8-8e2b-e9c3291421a8" class="">属于平衡二叉树，但它不是严格控制左、右子树高度或节点数之差小于等于1，但红黑树高度依然是平均log(n),且最坏情况高度不会超过2log(n),这有数学证明。所以它算平衡二叉树，只是不严格。</p><p id="af12888c-6777-4dc8-bc83-b497c3cfdb21" class="">
</p><h3 id="416db510-db3f-4385-b221-d0178298d43c" class="">unordered_map（hash_map）和map的区别？应用场景？</h3><p id="fa528273-d1bc-4b87-8af5-dddc04279e0f" class=""><strong>区别：</strong></p><ul id="ad62c1c9-e37a-4b06-836d-e5bc21e0c60f" class="bulleted-list"><li>map支持键值的自动排序，<strong>底层机制是红黑树</strong>，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</li></ul><ul id="4879217f-5a07-4e70-a263-c3b49cc4ccb8" class="bulleted-list"><li>unordered_map是C++ 11新添加的容器，<strong>底层机制是哈希表（hash_table）</strong>，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</li></ul><p id="ddfd9b32-3f19-4c8d-b082-694c2177efc2" class=""><strong>应用场景：</strong></p><ul id="c4da3fbb-5970-456e-8827-88c037d2196c" class="bulleted-list"><li>map适用于有序数据</li></ul><ul id="c675389c-2f4b-49a2-93dc-11f3f4b4642b" class="bulleted-list"><li>unordered_map适用于高效查询</li></ul><p id="3ceb0594-4cdc-4e22-926c-f65c58622c69" class="">
</p><p id="3b158009-818b-4214-859e-eaf92c1685f5" class="">
</p><h3 id="d68c4775-ddc9-41f5-ae28-7eccc5e542d1" class="">hashtable的实现？</h3><p id="c64ddf5a-71b8-4c38-8813-fc3719f0f40e" class="">使用的是<strong>开链法</strong>解决hash冲突问题</p><figure id="9f216aad-7423-4750-9dff-c8bea24ee53a" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%204.png"><img style="width:384px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%204.png"/></a></figure><p id="d998e221-7c02-45eb-bbab-228b0a7938b4" class="">
</p><p id="2172794d-9eb9-4fcd-a935-f3d3ebdb6c25" class="">hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p><p id="a422f21a-4544-4670-8ef6-0e9e075d1355" class="">在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,...,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量(vector的长度)，其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</p><p id="4e161e9a-a6eb-47e9-abd5-05b98eafe44d" class="">
</p><h3 id="6915877d-4f2f-4396-b788-abf85611a134" class="">hashtable中解决冲突有哪些方法？</h3><ol id="683f55a0-b62f-4bf5-ad8e-f822c482d4c2" class="numbered-list" start="1"><li>线性探测（开放定址法）<figure id="c413b699-82ba-4b88-a3ed-dea6e24b50dd" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%205.png"><img style="width:1294px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%205.png"/></a></figure><p id="cb8e5692-add0-44e8-95cd-3435ad5957cf" class="">存在问题：主集团</p></li></ol><ol id="c66dbb43-b94f-47f4-b800-bc9dd9db7513" class="numbered-list" start="2"><li>二次探测<p id="eed88d28-fc25-48ce-9935-7921980126f1" class="">如果hash计算出新元素位置为H，而该位置实际上已被使用，那我们依序尝试 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">H+1^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">H+2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">...</span></span></span></span></span><span>﻿</span></span>, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">H+i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>，而不是线性探测。</p><p id="2473cf21-ba5f-4919-8ebb-ddbfcbdedd93" class="">存在问题：次集团，两个元素hash出来的位置若相同，则探测的位置也相同，造成浪费。</p></li></ol><ol id="76e9951e-fcba-4007-a00c-3934dce343b1" class="numbered-list" start="3"><li>开链（SGI STL的hash table就是这种方法）<p id="e2fa69dd-b097-4524-8724-351b73aa5a94" class="">每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来</p></li></ol><ol id="686ccbac-9c76-4e3a-b104-409d23aa01e1" class="numbered-list" start="4"><li>再散列（再哈希法）<p id="5824b279-2f07-418f-a235-fb5c72cb6a5a" class="">发生冲突时使用另一种hash函数再计算一个地址，直到不冲突。</p></li></ol><ol id="6d24a6f7-7fc5-4ec4-b128-0416345a5a8f" class="numbered-list" start="5"><li>公共溢出区<p id="7f552718-5704-42eb-9fc0-8df7e79f1dfd" class="">将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p></li></ol><p id="63f25282-c687-4771-9895-83788452f41a" class="">
</p><p id="62e333bd-ccc4-4f71-a0c4-861d58f6fcc4" class="">
</p><figure id="8ca4e6f5-4a22-42b7-97a4-7834c118b345" class="image"><a href="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%206.png"><img style="width:1246px" src="STL%20e08fa8cf2eb74eb6955499d6bf0bee68/Untitled%206.png"/></a></figure><p id="05391419-3a87-4aa5-9891-7f22e6769633" class="">
</p></div></article></body></html>