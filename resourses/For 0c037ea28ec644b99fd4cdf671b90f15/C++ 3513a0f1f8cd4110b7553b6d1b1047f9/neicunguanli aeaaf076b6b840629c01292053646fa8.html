<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>neicunguanli</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="aeaaf076-b6b8-4062-9c01-292053646fa8" class="page sans"><header><h1 class="page-title">neicunguanli</h1></header><div class="page-body"><hr id="586b6940-f0bf-4e45-a518-aac5a1457ef0"/><p id="975d5d9b-7336-4274-9342-cdc8383c2cfb" class="">
</p><p id="a3261dc5-0271-476f-bc85-c887062601e0" class="">
</p><p id="b7d7a7c9-6105-4360-b1b9-419dee8d646e" class="">
</p><nav id="c376cec4-f79b-4294-a95d-5d0787d59c59" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#fa9b5627-5681-4949-aeb2-ae1aef3ec95a">内存分布</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c2ad29b7-cc8f-47f9-8236-5f684fdcb613">C++的内存分区？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#32db3fce-dad7-4b32-8723-3b44f881c36c">堆和栈的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9e3f2752-d625-48d7-ac0a-1a0258f0fb09">main函数执行之前和之后执行的代码可能是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#59d57b08-0458-4623-9b41-b0710291c6b2">结构体内存对齐问题？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#436e748d-381c-4830-a94d-0d01e33e8733">类的数据成员和成员函数内存分布情况？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#85a85c0b-cdbe-49d7-8b95-2cf917747c95">new、delete</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#afcf4a76-c4df-449a-a63e-e19e644c6044">new和malloc的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fd85fd38-f844-4a42-afbf-28ea8d2d4ed4">new和delete的实现原理？delete如何知道释放内存的大小的？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#85a3b9c4-424f-4151-b9d4-5db3d7c0368f">malloc和free的实现原理？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6ec5b175-3658-4283-947e-8043a357c822">malloc、realloc、calloc的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#89f0df77-515a-4ccd-a6b8-216388d570ca">内存泄漏是什么？如何检测和避免？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#df12a3fc-3179-43d0-a8d7-3b53b0929b9c">内存泄漏有哪些发生场景？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cb4fd850-1446-422c-abb8-09854116242a">Valgrind检查内存泄漏？</a></div></nav><p id="2cd1e25b-5264-421c-a1ad-76ee7023f006" class="">
</p><p id="5f1ebb1b-4770-450e-8a21-c8150f1ea8c0" class="">
</p><h2 id="fa9b5627-5681-4949-aeb2-ae1aef3ec95a" class="">内存分布</h2><h3 id="c2ad29b7-cc8f-47f9-8236-5f684fdcb613" class="">C++的内存分区？</h3><p id="43b9dc5a-f65e-4dcb-a3f2-59c16f191e20" class=""><strong>栈</strong>：在执行函数时，函数内局部变量、函数参数的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p id="e509658b-d5de-4634-a10b-69a422006f65" class=""><strong>堆</strong>：就是那些由 <code>new</code> 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code> 就要对应一个 <code>delete</code> 。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p id="5abc99f2-9662-4efc-9390-ad9ecdcea527" class=""><strong>自由存储区</strong>：就是那些由 <code>malloc</code> 等分配的内存块，他和堆是十分相似的，不过它是用 <code>free</code> 来结束自己的生命的。</p><p id="baf719b8-b276-4cac-8c7b-e47d66e5b891" class=""><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p><p id="04d3bf48-648b-4472-aafc-a510c218ec9b" class=""><strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p><p id="c9546c71-1467-43fb-b0bd-3b41b5a38d5c" class=""><strong>代码区：</strong>存放函数体的二进制代码</p><figure id="71c742d5-049c-4ede-8d11-3a6b08b4b791"><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">ShinChan&#x27;s Blog</div><div class="bookmark-description">内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放...</div></div><div class="bookmark-href"><img src="https://chenqx.github.io/img/favicon_new.ico" class="icon bookmark-icon"/>https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</div></div><img src="https://chenqx.github.io/img/logo_new.png" class="bookmark-image"/></a></figure><div id="eabba40c-0f36-44d9-937b-e854a1b90f3e" class="column-list"><div id="2cd5d2ed-6d85-46b1-bb99-dc61ff8f95f7" style="width:50%" class="column"><figure id="1fb4bec1-a973-44e6-be87-ddc0df7f94f8" class="image"><a href="neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled.png"><img style="width:240px" src="neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled.png"/></a></figure><p id="b90ec77b-7e6a-4492-b792-a3348533db01" class="">C++</p></div><div id="390acf43-c2e9-4504-a9a6-0cefd1ddf473" style="width:50%" class="column"><figure id="b36001ea-4096-4208-8e3f-22fdbbcffcf4" class="image"><a href="neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled%201.png"><img style="width:240px" src="neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled%201.png"/></a></figure><p id="0500b1b6-8a58-4389-a682-8af30f37d092" class="">一个进程的内存空间（操作系统）</p></div></div><p id="e1721554-8e7b-4266-bf46-eac517a9be74" class="">
</p><p id="22c2b0fe-bff6-4980-bf44-02ccdd6add92" class="">
</p><h3 id="32db3fce-dad7-4b32-8723-3b44f881c36c" class="">堆和栈的区别？</h3><ul id="583d6891-5acc-4fbd-8b3e-caae75c631c4" class="bulleted-list"><li>申请方式不同<ul id="a68d6a29-ccce-4b3c-8f36-84b1316d40d3" class="bulleted-list"><li>栈由系统（编译器）自动分配。</li></ul><ul id="b773f644-4ae7-4b26-a08e-cf3cda1d69c5" class="bulleted-list"><li>堆是自己申请和释放的。</li></ul></li></ul><ul id="e5b153fc-b9c0-4528-9e15-1cc8f891e6c2" class="bulleted-list"><li>申请大小限制不同<ul id="a61ec7ce-82d9-4314-9462-53dd9a3d17de" class="bulleted-list"><li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li></ul><ul id="3a90e620-fdef-4b8f-8224-9765c95ea61d" class="bulleted-list"><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li></ul></li></ul><ul id="3501e074-e1cd-48a8-be1c-46e49a156127" class="bulleted-list"><li>申请效率不同。<ul id="c17cbe89-e922-4545-84c8-67932639f726" class="bulleted-list"><li>栈由系统分配，速度快，不会有碎片。</li></ul><ul id="4c07b785-48bc-4535-a5e0-7a759470394d" class="bulleted-list"><li>堆由程序员分配，速度慢，且会有碎片。
</li></ul></li></ul><p id="1be6f3b2-a03f-43d5-a8c7-adff88fa61a1" class="">栈空间默认是4M, 堆区一般是 1G - 4G</p><p id="f8c10082-404e-4a5a-8176-c132f63180b9" class="">
</p><p id="6d34c4ee-e024-4c82-8b12-88a5129f5ed5" class="">
</p><p id="a5f6754f-7b06-4180-9040-bc2b603118a2" class="">
</p><p id="41e8caba-decf-4f87-b7d9-6d23cbc6646e" class="">
</p><h3 id="9e3f2752-d625-48d7-ac0a-1a0258f0fb09" class="">main函数执行之前和之后执行的代码可能是什么？</h3><p id="2869348e-9a3c-477f-ba9b-1e0573401853" class=""><strong>main执行之前</strong></p><ul id="ad6ddfcc-6ba1-4ae2-921b-6c49deeac142" class="bulleted-list"><li>设置栈指针</li></ul><ul id="eda825c5-37e4-4889-bba8-a19c53a4e7de" class="bulleted-list"><li>为全局变量分配内存并初始化  <code>.data</code> </li></ul><ul id="c56b1909-ee3d-4692-b4b8-66457a7ccb41" class="bulleted-list"><li>为局部静态变量分配内存（第一次用到时才初始化） <code>.bss</code></li></ul><ul id="d4202acd-f34a-407e-8bca-d75e59cbbb9b" class="bulleted-list"><li>将main函数的参数argc、argv等传递给main函数，然后才真正运行main函数</li></ul><ul id="3253e26f-8c8e-403d-85c7-9a9cecd138db" class="bulleted-list"><li>__attribute__((constructor))</li></ul><p id="50adafae-173f-4381-b4b8-e34e46b1d461" class=""><strong>main执行之后</strong></p><ul id="16fcec19-245b-48a0-ae14-fdd74e233472" class="bulleted-list"><li>全局对象的析构函数</li></ul><ul id="5f6714f9-3bd5-45e7-8d27-43660c76996f" class="bulleted-list"><li>用atexit注册的函数</li></ul><ul id="e245cab6-4e3e-4b5a-b4b3-b66ae01931fa" class="bulleted-list"><li>__attribute__((destructor))</li></ul><p id="45d7465b-5cbb-4da6-912c-2ffdda2b3b2b" class="">
</p><p id="3910329b-499d-4a5c-b7b3-39674cd8ed34" class="">
</p><h3 id="59d57b08-0458-4623-9b41-b0710291c6b2" class="">结构体内存对齐问题？</h3><p id="76706911-8506-47ed-a3a4-dd2f7c60ff27" class=""><strong>对齐规则：</strong></p><ul id="69e90a9b-f33e-4a88-9e89-9beab47921e3" class="bulleted-list"><li>第一个数据成员放在offset为0的地方，以后每个数据成员的offset对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</li></ul><ul id="42f7ab29-d960-4a26-92b3-0a2e0cdac295" class="bulleted-list"><li>在数据成员完成各自对齐之后，类(结构或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</li></ul><p id="0d1101a0-c752-4917-ae05-0216e4ccf086" class="">
</p><p id="33d1db06-150c-4632-b1b8-3904a934ee33" class="">c++11以后引入两个关键字 alignas与 alignof。其中 <code>alignof</code> 可以计算出类型的对齐方式， <code>alignas</code> 可以指定结构体的对齐方式。但是，若 alignas 小于自然对齐的最小单位，则被忽略。此时应该使用 <code>#pragma pack(push,1)</code> 或者 使用 <code>__attribute__((packed))</code> 。</p><pre id="43fcc7f8-9245-47dc-859f-82a250ee44fc" class="code"><code>struct alignas(4) myname{
		//...
};</code></pre><p id="4638ca64-6907-4bd9-bf48-861bd0d8c7ca" class="">
</p><p id="c0cc427b-b4cd-4c4d-9b34-20974f6e2f58" class=""><strong>为什么要内存对齐？</strong></p><p id="a9870ae9-4f33-4541-8e58-a80e282909c1" class="">有一篇公众号文章写得不错</p><ol id="9216107a-6363-4cf9-9ee1-5924cd1111cb" class="numbered-list" start="1"><li>硬件平台限制，处理器读写数据，并不是以字节为单位，而是以块(2,4,8,16字节)为单位进行的。为了保证处理器正确存取数据，需要进行内存对齐。</li></ol><ol id="829bedb0-e764-4824-8fe2-e8ca75482f66" class="numbered-list" start="2"><li>提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次把数据读出来。</li></ol><p id="b4c82b63-1d2d-42fa-8d3a-93a25c6c7904" class="">
</p><h3 id="436e748d-381c-4830-a94d-0d01e33e8733" class="">类的数据成员和成员函数内存分布情况？</h3><p id="b06bd967-5721-49b6-978f-5d1b0cafd0b2" class="">结构体与之类似。</p><p id="fbb0329d-b585-4521-a656-2a5cbc75dd27" class="">一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。</p><p id="7fef7c75-97a8-4dc7-99d3-f9a422fff8a3" class="">普通成员变量：随对象的创建而分配内存。对象在栈就在栈，对象在堆就在堆。</p><p id="c78be911-33a7-4e0a-b56d-7cac255e121c" class="">成员函数：对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为<strong>所有的函数都是存放在代码区的</strong>，不管是全局函数，还是成员函数，还是静态成员函数。</p><p id="d7e5a219-d800-4fb0-9c09-1b68249711ef" class="">static成员变量：不需要创建对象即可访问其静态成员变量，因此在对象创建前就已经分配了内存。static成员变量和普通static变量一样，都在内存分区的<strong>全局数据区</strong>分配内存，到程序结束后释放。</p><p id="0dfa32f5-1326-46ab-a0e4-b32e198837f2" class="">
</p><p id="2a145b70-9d3b-4afd-85c0-7a257d772052" class="">
</p><h2 id="85a85c0b-cdbe-49d7-8b95-2cf917747c95" class="">new、delete</h2><h3 id="afcf4a76-c4df-449a-a63e-e19e644c6044" class="">new和malloc的区别？</h3><ul id="c69ffc40-774f-48f5-bfa9-9775598901c4" class="bulleted-list"><li>new是C++运算符，支持重载；malloc是C/C++语言标准库函数，支持覆盖</li></ul><ul id="22ada5a4-cb9d-419f-8ee0-10fe30e5b31b" class="bulleted-list"><li>new自动计算要分配的空间大小，malloc需要手工计算 new是类型安全的，malloc不是。</li></ul><ul id="69b731af-235a-4fcb-a324-d2bb7a775254" class="bulleted-list"><li>new和delete除了分配回收功能外，还会调用<strong>构造函数和析构函数</strong>；malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险。 </li></ul><ul id="6cd3839d-1e6c-43f6-b186-4e1d79ca493f" class="bulleted-list"><li>new和delete返回的是具体类型指针；malloc和free返回的是void类型指针(必须进行<strong>类型转换</strong>)。</li></ul><p id="d9e41a1d-2727-44d6-a852-31fc621fa74b" class="">
</p><h3 id="fd85fd38-f844-4a42-afbf-28ea8d2d4ed4" class="">new和delete的实现原理？delete如何知道释放内存的大小的？</h3><p id="0f586ac8-3449-4561-b1fb-0278d5185fc8" class="">一、 new的原理</p><ul id="e59b7acc-8ada-4527-9960-40867888d966" class="bulleted-list"><li>new简单类型直接调用operator new分配内存；</li></ul><ul id="a2a1665d-2a32-4d15-b96d-01b5b7b87786" class="bulleted-list"><li>而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</li></ul><ul id="1aad724b-f6ce-49e2-a663-4fb64973e387" class="bulleted-list"><li>对于简单类型，new[]计算好大小后调用operator new；</li></ul><ul id="b3202acd-c05f-4425-a086-e0d2593e7e74" class="bulleted-list"><li>对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</li></ul><p id="7fb42e29-5eb3-494e-800b-622847d8d5d9" class="">二、delete的原理</p><ul id="594ed50d-9b50-4c6b-a043-954ac65c5115" class="bulleted-list"><li>delete简单数据类型默认只是调用free函数；</li></ul><ul id="6f456017-7d9d-4c02-95b6-8f4072e4fa83" class="bulleted-list"><li>复杂数据类型先调用析构函数再调用operator delete；</li></ul><ul id="1189b864-6c84-4cad-9616-7ca3fff3c240" class="bulleted-list"><li><strong>针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</strong></li></ul><p id="86fee684-0c7a-4128-838d-dc5e7e11595d" class="">三、delete 怎么知道释放内存的大小？<div class="indented"><p id="c7aebfd0-0dbb-4edc-9082-49484b01982f" class="">需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p></div></p><p id="0aba9cb4-9dcf-4637-9658-90bc16caf1e7" class="">重点是：new[]之后，如果delete，简单类型没问题，复杂类型会崩溃而不是内存泄漏，因为前四个字节记录了数组的大小，而delete[]默认释放四个字节之后的内存，但是这四个字节没有被系统记录。</p><p id="8ae7531d-5dad-470a-aba4-4f9b53f82c75" class="">
</p><h3 id="85a3b9c4-424f-4151-b9d4-5db3d7c0368f" class="">malloc和free的实现原理？</h3><p id="1fe1a56d-1fcc-492d-86bc-f270455c86da" class="">
</p><p id="651be11c-f8a8-4436-8e7f-ffd3ecbdbdc2" class="">
</p><h3 id="6ec5b175-3658-4283-947e-8043a357c822" class="">malloc、realloc、calloc的区别？</h3><p id="814703bc-76d6-4405-a438-71f860e8a611" class="">
</p><p id="2c766d29-dfb2-4860-a868-770effc2d1b8" class="">
</p><p id="9dfaeb62-b785-4645-a996-8d3dab354f49" class="">
</p><h3 id="89f0df77-515a-4ccd-a6b8-216388d570ca" class="">内存泄漏是什么？如何检测和避免？</h3><p id="3a2cb16f-4972-4839-b36c-566b7526667e" class=""><strong>内存泄漏</strong></p><p id="d517cf4a-1e74-47e4-81a5-2afc4bb2bd8b" class="">应用程序般使用malloc、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。</p><p id="8fa01d1d-6646-4993-8aa2-1f2a67507357" class="">如何检测</p><ul id="0488b0dc-2902-4022-96cc-a3ddcc35a3d7" class="bulleted-list"><li>Linux下可以使用<strong>Valgrind工具</strong></li></ul><ul id="5853aae0-8ee6-42be-be7f-36ccc8ebee68" class="bulleted-list"><li>Windows下可以使用<strong>CRT库</strong></li></ul><p id="a6f0ea9b-828b-4a18-8d78-2c78c09a4ff2" class="">如何避免</p><ul id="996f55ac-7962-4d70-a046-e3f4efd23f63" class="bulleted-list"><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li></ul><ul id="116ddfe3-ab10-46a4-8b87-81a40e0616fd" class="bulleted-list"><li>一定要将基类的析构函数声明为<strong>虚函数</strong></li></ul><ul id="4f405933-616f-4b5d-b7b8-c046b09b426c" class="bulleted-list"><li>对象数组的释放一定要用<strong>delete []</strong></li></ul><ul id="49476ef6-7b7c-4172-a753-77a9959faeed" class="bulleted-list"><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul><p id="f9257380-54cd-4c6b-90d2-6f99b896d251" class="">
</p><h3 id="df12a3fc-3179-43d0-a8d7-3b53b0929b9c" class="">内存泄漏有哪些发生场景？</h3><figure id="bb37e0d0-553c-49d5-afbf-a6896713ef33" class="image"><a href="neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled%202.png"><img style="width:672px" src="neicunguanli%20aeaaf076b6b840629c01292053646fa8/Untitled%202.png"/></a></figure><p id="7fec5ac6-6e53-42f3-942b-4e7ad2c8c5d5" class="">
</p><p id="f14169ed-a9bd-4fb9-984d-32177f55dc15" class="">
</p><h3 id="cb4fd850-1446-422c-abb8-09854116242a" class="">Valgrind检查内存泄漏？</h3><p id="b6935b6a-a3a7-4a05-947c-8c910bb94555" class="">
</p><p id="9dcdf178-ccef-487e-bbd1-a4d404127086" class="">
</p><p id="d0816635-730c-4c74-91ac-5af241d6b5f5" class="">
</p><p id="2b78eb89-e8c1-44ba-bf00-44c987948aba" class="">
</p><p id="85e25120-3f93-4ad3-aa0f-c60bce4f1213" class="">
</p><p id="fe25909f-b576-4bbc-9f81-1d2827fc6a56" class="">
</p><p id="5b17f56f-30d8-4db0-bca9-c13282b52e16" class="">
</p><p id="fa2a1e1c-cb3c-4c2b-a9fc-28306b84d179" class="">
</p><p id="719a0d5b-1625-4f88-8b5e-7cbff3c23def" class="">
</p><p id="8bb16cf5-3588-4435-aa4e-8fc6fc393276" class="">
</p><p id="751245f1-72d2-4970-9810-dd843402dcd0" class="">
</p><p id="6686fda8-67f3-4e8a-9295-09b17e3a8db8" class="">
</p><p id="e10cd67d-041d-476d-97d4-15b6e9b01670" class="">
</p></div></article></body></html>