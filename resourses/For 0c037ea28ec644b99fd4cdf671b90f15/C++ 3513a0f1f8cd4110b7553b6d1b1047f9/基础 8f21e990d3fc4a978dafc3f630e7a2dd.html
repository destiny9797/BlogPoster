<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>基础</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="8f21e990-d3fc-4a97-8daf-c3f630e7a2dd" class="page sans"><header><h1 class="page-title">基础</h1></header><div class="page-body"><hr id="e5b34c78-856b-42d7-85d6-98e0aa8acab5"/><p id="c0868d4a-4506-4f14-ae33-904ac4d9db7e" class="">
</p><p id="9237b84d-71b2-44c5-8431-15ecdeea48b8" class="">基础用法相关</p><p id="4396a335-c75f-412d-884b-a908f87e8bc3" class="">
</p><p id="0d9577c2-291f-4f5b-a6ea-5cf11a656f24" class="">
</p><nav id="1debd1c5-7707-4a13-b718-0989a152bdda" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5c49e478-f6f9-4df1-abef-49af0f4f8607">左值和右值</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f4de3c41-cbfc-43d3-9729-d2a41cdae095">左值引用和右值引用？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#05ffb7a1-8b6a-4101-9f51-67cf6572eeb6">转移语义</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1310fbf4-9243-4f00-a0f1-4261f08e8dc1">基本概念和用法</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#321656a7-8978-40f0-b861-f3a37820cf55">结构体和联合体（共同体）的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5334866a-bcde-4c33-842d-201cedd1cb5a">什么是野指针、悬空指针？产生原因？如何解决？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5380fbae-0d6d-4626-a531-f35cb8a07654">const和static的作用？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ff8988ac-c4f0-401e-9650-68a5c470a312">顶层const和底层const？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#67262b7c-d9a2-4e4e-b20f-eee1c06247e7">auto、decltype和decltype(auto)的用法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1d3edc52-7264-421b-88ae-5d007ec9b8fb">volatile、mutable和explicit关键字的用法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b660a168-ead2-4f64-b34c-ee43f771a1dd">大小端存储？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#270702e2-da75-4a1b-8d7c-1ac10cf52fa5">有哪些常见的异常？异常处理的方法？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#678a5cb3-b066-4982-9b21-cab6ea33bd88">形参和实参？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#878801a1-0bc0-4cbe-a1c8-b03945cf8469">有哪几种强制转换？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b35ec7f3-3ebf-4295-a98f-550bb8207b55">什么是隐式转换？转换准则？如何消除？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#89b9f3c6-6b0a-4d2a-8c5c-2f46c8556ebb">strcpy、sprintf、memcpy这三个函数的不同之处？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e447c78d-7fdb-4de9-9d78-769cc4ac8826">实现strcpy函数？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#80420e60-adf6-4e44-bc41-630b9c975dd4">区别s</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f3619e74-4ba6-47ff-9b71-885eb745b0f8">static全局变量和非static全局变量的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d4006ea4-5e05-4314-af11-daffaf38720d">变量声明和定义的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6464399b-df86-4186-bdc1-e49fdbcf7af3">strlen和sizeof的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#62591b4d-cd96-4731-ba7a-833b82f823b4">在 <code>int a[10]</code> 中a和&amp;a有什么区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#047dbea8-9cd9-4bb7-b186-d7d237b12527">数组名和指针的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0dd9e405-0b00-4d57-954a-bcfb3dba9576">struct和class的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d9a51459-f406-435e-acc1-cc012356704c">define宏定义和const的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#40b356de-1c74-4806-8d7e-3914789f0990">const和static的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bad8a8a9-b18f-465f-b226-069442cb469c">浅拷贝和深拷贝的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8897cdf0-203d-458a-bbc0-00f97d079918">strcpy和memcpy的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9324afd9-5fdd-4d35-8d58-f4fdde4fb653">模板</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#20e6610f-ec41-480a-93ca-ecffc8e3f8fd">类模板和模板类的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b222cff3-40ea-4e97-b0ea-27bb9f5eba02">模板函数和模板类的特例化？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#defecc28-e8e5-4c40-8f13-197cddcca437">模板的底层怎么实现的？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#05509be4-8774-4c10-98a4-32aa83c10b54">类模板和函数模板的区别是什么？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#46bfe0d5-d6c0-4367-92cc-17c1c9987796">为什么模板类一般都是放在一个.h文件中？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#529b6e5b-8338-4446-b75b-723dc00d3c05">模板的优缺点？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#aa873247-50f2-426b-854a-758b3015900c">手写比较大小的模板函数。</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7fcd3360-d830-4458-800c-a452c9f2da72">与C</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d5f1947e-92e7-4bf4-8d8f-c6b63dee3385">NULL和nullptr的区别？</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c45ecc85-225d-45ca-8c15-b960fff3d126">extern &quot;C&quot;？</a></div></nav><p id="e847028b-853e-437c-8f11-f0b3ee87c628" class="">
</p><p id="a8a0f214-e6dc-4830-82dc-4860b162ea4e" class="">
</p><h2 id="5c49e478-f6f9-4df1-abef-49af0f4f8607" class="">左值和右值</h2><h3 id="f4de3c41-cbfc-43d3-9729-d2a41cdae095" class="">左值引用和右值引用？</h3><ol id="31d4cd75-050e-41c8-b899-3db0278faba7" class="numbered-list" start="1"><li>左值和右值<p id="161a24bc-168e-44e1-b9d2-8f8c063cdf77" class="">左值：表示的是<strong>可以获取地址</strong>的表达式，它能出现在赋值语句的左边，对该表达式进行赋值（除非有const修饰）。</p><p id="f686f429-ae7f-4000-819c-43a7413be46f" class="">右值：表示<strong>无法获取地址</strong>的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p></li></ol><ol id="6065b8b0-382d-4ed5-ac84-6150a29fe1d5" class="numbered-list" start="2"><li>左值引用和右值引用<p id="7f1b6114-b55d-4f98-b01a-eabcf9348904" class="">左值引用：C++中传统的引用</p><p id="933937cb-0e11-4a7a-a4fc-13deced6d951" class="">右值引用：C++中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置。<strong>右值虽然无法获取地址，但是右值引用可以，该地址表示临时对象的存储位置。</strong></p></li></ol><p id="8eea87e6-bd89-4216-8c8b-766e61c20dcc" class="">
</p><p id="8411112a-c7ba-4687-ab47-41e81655a57d" class="">右值引用的特点：</p><ul id="4bacbcbf-e512-48ac-9a58-4921e5feb3ed" class="bulleted-list"><li>特点1:通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一 样长，只要该变量还活着，该右值临时量将会一直存活下去 </li></ul><ul id="46801be8-bc11-4c85-bd23-271d5610076e" class="bulleted-list"><li>特点2:右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值 </li></ul><ul id="b00ea944-508b-46cb-b4c8-113bb6304788" class="bulleted-list"><li>特点3:T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li></ul><p id="e12751da-91b4-4a36-b077-e59bc959241a" class="">
</p><p id="186ea450-78fa-483a-a7db-e510a928157f" class=""><strong>常量左值引用是个“万能” 的引用类型</strong>。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化</p><p id="2865d26b-fd52-41a7-bde7-34921ef43ad6" class="">右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p><p id="162bc578-8349-4a7a-a185-3b9093ad30d6" class="">
</p><p id="0ad5fa20-21c3-48ea-badf-6c559a8759d1" class="">
</p><h3 id="05ffb7a1-8b6a-4101-9f51-67cf6572eeb6" class="">转移语义</h3><p id="d06daeb3-d008-472d-9dc9-d8f8c455ad4e" class="">转移语义可以<strong>将资源 ( 堆、系统对象等 ) 的所有权从一个对象(通常是匿名的临时对象)转移到另一个对象</strong>，从而减少对象构建及销毁操作，提高程序效率。右值引用被引入的目的之一就是实现转移语义。</p><p id="ad2b6a15-67c7-4d7d-a0ba-850b8c549734" class="">转移通常用于转移构造函数和转移赋值函数中。</p><p id="aba5c066-61f2-4665-828d-432a69a5c51a" class="">但是传入的参数要求只能是右值，当我们调用时，可能想要把一个没用了的（即将到达生命尽头）左值传进去，就可以用 <code>std::move</code> 函数（定义在&lt;utility&gt;中）来获得绑定到左值上的右值引用，这和显示地将左值转换为对应的右值引用类型（ <code>static_casst&lt;T&amp;&amp;&gt;(lvalue)</code> ）是一样的。</p><p id="04f6546e-a815-4d78-ae89-91e3a5f35e36" class="">
</p><p id="0eaaa340-3df2-4378-ba37-ab8221ae1826" class="">
</p><p id="2833cfad-c396-48ed-a7d8-08e0d05ca6f3" class="">
</p><p id="56c4708f-237b-4207-983b-7619c122e7c8" class="">
</p><p id="3f291d48-237a-44da-bba4-1ead8979ef1b" class="">
</p><p id="34f0c34a-0bc5-44e6-a7d7-759bc6fea089" class="">
</p><p id="cfa0b837-ecfc-4a6c-b8c7-d45046609521" class="">
</p><p id="82579f54-1aca-45ce-9141-9b1c8aac30e3" class="">
</p><p id="cd26311c-5f57-47fd-a6d0-125f49d1f5b2" class="">
</p><p id="f76297c0-6468-4174-ae8f-2a42240753b5" class="">
</p><p id="2542b365-2588-4407-ac1b-9112ebd03b4f" class="">
</p><p id="765851ee-a562-4bad-a259-6a30c309c21b" class="">
</p><p id="24166c11-23eb-454a-9ea6-7ce274285502" class="">
</p><h2 id="1310fbf4-9243-4f00-a0f1-4261f08e8dc1" class="">基本概念和用法</h2><h3 id="321656a7-8978-40f0-b861-f3a37820cf55" class="">结构体和联合体（共同体）的区别？</h3><p id="954ece2e-fba7-491c-b11e-bbefcd869a65" class="">结构体struct：每个成员都有自己独立的地址，它们是同时存在的。 <code>sizeof(struct)</code> 是内存对齐后所有成员长度的加和。</p><p id="47f10033-8faa-40d8-8d68-99a6c0d730ca" class="">共同体union：不同变量共同占用一段内存，它们不能同时存在，当共同体中存入新的数据后，原有的成员就失去了作用，新的数据被写到union的地址中。 <code>sizeof(union)</code> 是最长的数据成员的长度。</p><p id="ace16ce3-b854-4c78-9b1c-0cc4823ff645" class="">
</p><h3 id="5334866a-bcde-4c33-842d-201cedd1cb5a" class="">什么是野指针、悬空指针？产生原因？如何解决？</h3><ul id="af5c510c-258d-437d-a263-c668fee6f6ef" class="bulleted-list"><li><strong>野指针：</strong>没有被初始化的指针<p id="aaf890d6-d2d7-4fcb-8bc8-fd8c96e58692" class=""><strong>产生原因：</strong>指针变量未及时初始化</p><p id="4a2c9f7a-a643-4d5b-b820-4df88e75b9d4" class=""><strong>解决：</strong>对于指针初始化时都是赋值为 nullptr ，这样在使用时编译器就会直接报错，产生非法内存访问。</p></li></ul><ul id="78c5f876-4a22-4064-b9df-6d95f64d4147" class="bulleted-list"><li><strong>悬空指针：</strong>指针最初指向的内存已经被释放。<p id="3898befe-590d-4a80-b09e-56f4f554ff74" class=""><strong>产生原因：</strong>指针free或delete之后没有及时将指向该内存区域的指针都置空</p><p id="8c035290-4ffe-42df-8967-32fe784c9239" class=""><strong>解决：</strong>C++引入了智能指针，<strong>C++智能指针的本质就是为了避免悬空指针的产生。</strong></p></li></ul><p id="c6d5f160-c7a3-4467-b204-c7d8ab33d597" class="">
</p><h3 id="5380fbae-0d6d-4626-a531-f35cb8a07654" class="">const和static的作用？</h3><p id="0e35bbeb-6dba-44ff-9f01-8a1f871df29f" class=""><strong>static</strong></p><ul id="7c2d13cd-31ee-46de-842f-5490250b0380" class="bulleted-list"><li>不考虑类<ul id="ca47b03d-5b6a-4dbb-80f8-fd78b1c6f970" class="bulleted-list"><li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后 只能在该文件所在的编译模块中使用</li></ul><ul id="e8982045-83db-4bd8-931b-eec3f75f2d81" class="bulleted-list"><li>默认初始化为0</li></ul><ul id="16df5db9-d4b6-49ef-a067-1fcf573087a1" class="bulleted-list"><li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li></ul></li></ul><ul id="a95dba72-6a75-4ba0-8b4f-3b50d0da9ed8" class="bulleted-list"><li>考虑类<ul id="5e798d6a-2113-4042-a4cf-c32d02eb41fd" class="bulleted-list"><li>static成员变量：<span style="border-bottom:0.05em solid">只与类关联，不与类的对象关联</span>。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。 </li></ul><ul id="34bbcd80-c354-4108-861b-7cfba8716b40" class="bulleted-list"><li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问</li></ul></li></ul><p id="e077aabf-b18d-4a41-a5ec-e0afea850ab5" class=""><strong>const</strong></p><ul id="49a83983-9f9e-4b1d-a1aa-d1aaa1e680c5" class="bulleted-list"><li>不考虑类<ul id="321e809b-c679-49a9-b09e-b4a4cfbd73e9" class="bulleted-list"><li>const常量在定义时必须初始化，之后无法更改 </li></ul><ul id="8048cd67-568a-4e12-a2e9-f78a9fe2cec9" class="bulleted-list"><li>const形参可以接收const和非const类型的实参</li></ul></li></ul><ul id="50d1c0c1-35bd-410c-a90e-52ea0b668740" class="bulleted-list"><li>考虑类<ul id="30296f02-7e81-49b4-ae65-43670d4df6af" class="bulleted-list"><li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且 必须有构造函数;不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化 </li></ul><ul id="9eb09b10-c99d-47c5-ae34-90c953ec464b" class="bulleted-list"><li>const成员函数：不可以改变非mutable(用该关键字声明的变量可以在const成员函数中被修改)数据的值；const对象不可以调用非const成员函数；非const对象都可以调用</li></ul></li></ul><p id="78c0009b-a3a4-49b2-918b-1972380343f3" class="">
</p><h3 id="ff8988ac-c4f0-401e-9650-68a5c470a312" class="">顶层const和底层const？</h3><p id="99a07738-c3dd-4cfe-9359-a243efbae7f5" class="">顶层const：const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是<strong>指针</strong>，就是 * 号的右边</p><p id="fed61b4d-50b7-434c-9d1e-3d4913758c80" class="">底层const：const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指<strong>变量</strong>，就是 * 号的左边</p><pre id="55504c08-79de-4ca9-b980-60a7dfba4ec8" class="code"><code>int num_c = 3;  
const int *p_c = &amp;num_c;  //p_c为底层const的指针  
//int *p_d = p_c;  //错误，不能将底层const指针赋值给非底层const指针  
const int *p_d = p_c; //正确，可以将底层const指针复制给底层const指针

int num_e = 4;  
const int *p_e = &amp;num_e;  
//*p_e = 5;  //错误，不能改变底层const指针指向的内容  
int *p_f = const_cast&lt;int *&gt;(p_e);  //正确，const_cast可以改变运算对象的底层const。但是使用时一定要知道num_e不是const的类型。  
*p_f = 5;  //正确，非顶层const指针可以改变指向的内容  
cout &lt;&lt; num_e;  //输出5</code></pre><p id="0280bf6e-f79b-4bb1-8a7e-5e528a1508d2" class="">
</p><h3 id="67262b7c-d9a2-4e4e-b20f-eee1c06247e7" class="">auto、decltype和decltype(auto)的用法？</h3><p id="9fef9de4-b3e7-4e59-9748-5f522d77ce29" class=""><strong>auto</strong></p><p id="cdaebe0e-2f44-4316-96ba-17eb2cb5c261" class="">auto <strong>让编译器通过初始值来进行类型推演，</strong>从而获得定义变量的类型，所以说 auto 定义的变量必须 有初始值。</p><pre id="b468d3a9-2ff7-4651-87a3-96de3f87c029" class="code"><code>//普通;类型
int a = 1, b = 3;
auto c = a + b;// c为int型
//const类型
const int i = 5;
auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int
auto k = &amp;i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*
const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt
//引用和指针类型
int x = 2;
int&amp; y = x;
auto z = y; //z是int型不是int&amp; 型 auto&amp; p1 = y; //p1是int&amp;型
auto p2 = &amp;x; //p2是指针类型int*</code></pre><p id="a89e3b9e-d7ba-4227-978f-be57c0648bd4" class=""><strong>decltype</strong></p><p id="e25f64a5-0f15-4c4b-9008-cdba9f3a2167" class="">decltype的作用是<strong>选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</strong></p><p id="d8974f21-11b0-4c1c-afce-27f3770c503d" class="">使用场景：</p><ul id="8e0bd9b0-5c70-4528-8a29-0c6ea0d1425e" class="bulleted-list"><li>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了。</li></ul><ul id="21140618-a672-4f87-9341-14702e302ab7" class="bulleted-list"><li>还有些时候，我们希望保留顶层const和引用的类型，而auto会忽略</li></ul><pre id="bc59b845-7e69-4bea-8cc1-7152ba005bd8" class="code"><code>int func() {return 0};

//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会
实际调用函数func()
int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int

//不论是顶层const还是底层const, decltype都会保留
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const 
int e = 4;
const int* f = &amp;e; // f是底层const 
decltype(f) g = f; // g也是底层const

//引用与指针类型
//1. 如果表达式是引用类型, 那么decltype的类型也是引用 
const int i = 3, &amp;j = i;
decltype(j) k = 5; // k的类型是 const int&amp;

//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式: 
int i = 3, &amp;r = i;
decltype(r + 0) t = 5; // 此时是int类型

//3. 对指针的解引用操作返回的是引用类型
int i = 3, j = 6, *p = &amp;i;
decltype(*p) c = j; // c是int&amp;类型, c和j绑定在一起

//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&amp;类型, j和i绑定在了一起</code></pre><p id="56afa183-b417-4ee0-925f-84245d5c7dbd" class="">
</p><h3 id="1d3edc52-7264-421b-88ae-5d007ec9b8fb" class="">volatile、mutable和explicit关键字的用法？</h3><ol id="2f3d0048-1189-4a87-9b3a-1494994cc5f1" class="numbered-list" start="1"><li><strong>volatile</strong><p id="2043bc4b-25cf-495c-9d77-09022acc03e0" class="">volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p id="4cf9e287-7584-48c5-9e84-a30dc03804e2" class="">当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p><p id="cbe9e7c7-1dd5-409b-822f-41e67c8046f2" class=""><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p><p id="15582956-e83a-41e1-b421-0e9bde70d66f" class="block-color-blue_background"><strong>多线程下的volatile：</strong>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该 用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入 寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误 执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p></li></ol><ol id="69cc6d7b-16ae-453c-813d-deefbc339894" class="numbered-list" start="2"><li><strong>mutable</strong><p id="5443e571-8129-458e-b568-2ea552950416" class="">mutable的中文意思是“可变的，易变的”，跟constant(既C++中的const)是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p></li></ol><ol id="b046be94-bc2a-4ab6-8480-09cd10464b7b" class="numbered-list" start="3"><li><strong>explicit</strong><p id="7031c033-db74-461a-9c50-a6fde2d58700" class="">explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，<strong>不能发生相应的隐式类型转换</strong>，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点:</p><ul id="cc2cde20-41ac-4571-b1a5-d86b0ca4f2c6" class="bulleted-list"><li>explicit 关键字只能用于类内部的构造函数声明上</li></ul><ul id="1c2fff8c-45a4-4019-bb4b-1384dc23c2d5" class="bulleted-list"><li>explicit 关键字作用于单个参数的构造函数</li></ul><ul id="1d88297e-0de3-49b7-aca4-5f4f4afaf26c" class="bulleted-list"><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul></li></ol><p id="1c8918d0-9f92-4f48-948a-ce94f5b074a4" class="">
</p><p id="2d5f7cfc-7523-4148-ad03-5aeef9e73f34" class="">
</p><h3 id="b660a168-ead2-4f64-b34c-ee43f771a1dd" class="">大小端存储？</h3><p id="6b9a9c8b-1f09-45dc-a2ca-13cfa5d866d3" class="">对于一个32bit的数字0x12345678</p><p id="537336cd-4621-4fcc-8767-98f7847ed72c" class=""><strong>大端存储：</strong>字数据的高字节存储在低地址中</p><figure id="ddf8c9ff-3dda-41ab-84c4-d28f36f55ce3" class="image"><a href="%E5%9F%BA%E7%A1%80%208f21e990d3fc4a978dafc3f630e7a2dd/Untitled.png"><img style="width:1224px" src="%E5%9F%BA%E7%A1%80%208f21e990d3fc4a978dafc3f630e7a2dd/Untitled.png"/></a></figure><p id="a98461e2-0b48-45b5-9a67-3858f7f158f5" class=""><strong>小端存储：</strong>字数据的低字节存储在低地址中</p><figure id="ee3fe36a-a12f-4345-8f94-a57a8e5ff671" class="image"><a href="%E5%9F%BA%E7%A1%80%208f21e990d3fc4a978dafc3f630e7a2dd/Untitled%201.png"><img style="width:1224px" src="%E5%9F%BA%E7%A1%80%208f21e990d3fc4a978dafc3f630e7a2dd/Untitled%201.png"/></a></figure><p id="eea077c5-6d94-4aa7-b30e-b681df989e53" class="">
</p><p id="0e7bfddb-8f8b-4f29-9f35-1fb1cead337a" class=""><strong>如何用代码判断大小端存储呢？</strong></p><ul id="eac4a265-86ca-4dec-a106-a284b0857afa" class="bulleted-list"><li><strong>使用强制类型转换</strong><pre id="646dad1d-bafb-4249-a151-17c29e8d9403" class="code"><code>int n = 0x12345678;
cout &lt;&lt; (int)((char)n) &lt;&lt; endl;
//如果输出是0x12则是大端，0x78则是小端</code></pre></li></ul><ul id="5ddc2b0e-46a8-4167-aef7-7cc028897413" class="bulleted-list"><li><strong>使用union联合体</strong><pre id="1e51f91b-6067-4d72-baf3-b92c3e05c6db" class="code"><code>union endian{
    int a;
    char ch;
};

endian e;
e.a = 0x12345678;
cout &lt;&lt; (int)e.ch &lt;&lt; endl;
//如果输出是0x12则是大端，0x78则是小端</code></pre></li></ul><p id="22f6f63e-d77a-46df-ba0f-d33628a15dd1" class="">
</p><p id="5c5f9378-623b-4d01-8fe5-df12fd284a11" class="">
</p><h3 id="270702e2-da75-4a1b-8d7c-1ac10cf52fa5" class="">有哪些常见的异常？异常处理的方法？</h3><p id="bc0d059b-d402-4d6c-9e76-b87a313e7fe0" class=""><strong>常见的异常</strong>有：</p><ul id="3bf8d946-9c49-4651-8c43-5a62baf0e3e2" class="bulleted-list"><li>数组下标越界</li></ul><ul id="156e97f3-d625-43cb-a201-f56483fa7b28" class="bulleted-list"><li>除法计算时除数</li></ul><ul id="1330035b-7d72-44cd-bcca-b1a4bbf0c905" class="bulleted-list"><li>动态分配空间时空间不足</li></ul><ul id="0899189d-0c47-4eed-9d3a-f09fb53b350a" class="bulleted-list"><li>……</li></ul><p id="b6002269-faa1-4d9d-9e99-8841b3702d90" class=""><strong>异常处理机制：</strong></p><ul id="e4bec10e-850c-4003-ada6-e2927c8784d4" class="bulleted-list"><li>try、throw、catch<pre id="1712faf9-c18c-4db5-9442-542248bcbcfe" class="code"><code>int main()
{
    double m = 1, n = 0;
    try {
        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;
        if (n == 0)
						throw - 1; //抛出int型异常 
				else if (m == 0)
						throw - 1.0; //拋出 double 型异常 
				else
            cout &lt;&lt; m / n &lt;&lt; endl;
        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;
    }
    catch (double d) {
        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;
    }
    catch (...) {
        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;
    }
    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;
    return 0;
}
//运行结果
//before dividing. 
//catch (...) 
//finished</code></pre></li></ul><ul id="5de4a350-fa6c-42ad-a0bf-03d3aebdd3a7" class="bulleted-list"><li>函数的异常声明列表<p id="576b4972-7461-4351-b786-2d6fccf9ba08" class="">程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表。如果throw中为空，表明不 会抛出任何异常，如果没有throw则可能抛出任何异常</p><pre id="4394b43f-a5d2-49d5-a7b1-93fe79312a2f" class="code"><code>int fun() throw(int,double,A,B,C){...};</code></pre></li></ul><ul id="d4061751-3fe4-42fd-a0cb-2ec33e6b1e94" class="bulleted-list"><li>标准异常类 exception</li></ul><figure id="f9139950-3eca-4ccc-b3cf-e57161f12c3c" class="image"><a href="%E5%9F%BA%E7%A1%80%208f21e990d3fc4a978dafc3f630e7a2dd/Untitled%202.png"><img style="width:336px" src="%E5%9F%BA%E7%A1%80%208f21e990d3fc4a978dafc3f630e7a2dd/Untitled%202.png"/></a></figure><p id="c9a4838f-9599-40bf-8448-eb504528caf9" class="">
</p><p id="94fa180a-3d4d-4f0c-a427-9045fae0a627" class="">
</p><p id="4b3397c7-ccd9-4a50-8e50-82163e20e200" class="">
</p><p id="68db56c7-74c9-484c-bcaf-7578c93d979d" class="">
</p><p id="bc3fd2f7-4628-489a-bd6d-2f404ecb4a19" class="">
</p><h3 id="678a5cb3-b066-4982-9b21-cab6ea33bd88" class="">形参和实参？</h3><ul id="a158b891-1b77-40bc-aa79-c44af7dc2463" class="bulleted-list"><li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，<strong>形参只有在函数内部有效</strong>。 函数调用结束返回主调函数后则不能再使用该形参变量。</li></ul><ul id="e4e1e904-de4b-4af0-aef4-b49628a7ce7a" class="bulleted-list"><li>实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</li></ul><ul id="6def9cbf-4ab2-49a2-aa8a-120d70f2faf2" class="bulleted-list"><li><strong>当不是引用类型时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</strong></li></ul><p id="6a8a2af8-0254-4f3a-8a18-070fae90bcb6" class="">
</p><h3 id="878801a1-0bc0-4cbe-a1c8-b03945cf8469" class="">有哪几种强制转换？</h3><ul id="3649aa71-9151-4c9d-bc5d-18592a47f2aa" class="bulleted-list"><li>reinterpret_cast<p id="00f3b76a-1bfd-4fce-bd00-1798aad10147" class="">reinterpret_cast&lt;type_id&gt; (expression)</p></li></ul><ul id="0be8436f-9dfd-4db6-b8ca-df4f4c70a401" class="bulleted-list"><li>const_cast<p id="e1f380bb-b910-45f2-9783-d851950ca397" class="">const_cast&lt;type_id&gt; (expression)</p><p id="5dc7dd4a-0ef6-449c-b5c3-1613ed216160" class="">用来讲const或volatile属性的类型转换为非const或volatile</p></li></ul><ul id="02d48c78-73f6-44a3-ae2e-e77f0be9a71c" class="bulleted-list"><li>static_cast<p id="4b50816c-59c1-4d0f-9daf-ba4775e3a0b5" class="">static_cast &lt; type-id &gt; (expression)</p><p id="95eecb65-52e1-40dc-b71e-67d5e1122a31" class="">把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。</p></li></ul><ul id="d1024d76-bcbc-4d77-aafe-0d99732d22e2" class="bulleted-list"><li>dynamic_cast<p id="c5ba70a8-4b2d-4853-8b7a-447ba1d0f291" class="">dynamic_cast&lt; type_id &gt; (expression)</p><p id="8697cdd8-f542-46b6-b175-f2d860cdebe3" class="">dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转 换是安全的(也就说，如果基类指针或者引用确实指向一个派生类对象)这个运算符会传回适当转型过 的指针。如果 如果下行转换不安全，这个运算符会传回空指针(也就是说，基类指针或者引用没有指向 一个派生类对象)</p></li></ul><p id="ed6dbeee-c25f-4801-80a1-b01b73dd5bcc" class="">注：在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</p><p id="f1e65bcf-dd75-4fe8-b690-95d4f717c5e0" class="">
</p><h3 id="b35ec7f3-3ebf-4295-a98f-550bb8207b55" class="">什么是隐式转换？转换准则？如何消除？</h3><p id="99a35fa1-5aba-4dc6-8bcd-34da354f9b40" class=""><strong>隐式转换</strong></p><p id="66143b3e-0d53-4504-9fb5-798948a971e1" class="">指不需要用户干预，编译器私下进行的类型转换行为。</p><p id="80014c5a-d1fb-40df-83eb-6ee3b506c290" class=""><strong>隐式转换准则</strong></p><ul id="7a7d9421-b907-4879-ae91-804a76c6a5c9" class="bulleted-list"><li>基本数据类型：从小→大（保证精度不丢失）。如char→int, int→long</li></ul><ul id="a767f294-ac5c-4cd4-9c61-07ffeecb3235" class="bulleted-list"><li>自定义对象：子类对象可以隐式地转换为父类对象。</li></ul><p id="9a315987-aaee-4e13-aaa1-0aadb6e157ea" class=""><strong>如何消除隐式转换？</strong></p><p id="0d395630-d08a-4fe9-a318-b1a8fd37ce4b" class="">当构造函数<span style="border-bottom:0.05em solid">只接受一个参数时</span>，实际上定义了转换为此类类型的隐式转换机制。</p><p id="caf04692-1db4-457a-9caf-bac9bf24d49a" class="">在构造函数声明时<strong>加上explicit关键字</strong>，可以禁止隐式转换。</p><p id="19a94c26-407c-44f0-893e-a3dca0dcbd16" class="">
</p><h3 id="89b9f3c6-6b0a-4d2a-8c5c-2f46c8556ebb" class="">strcpy、sprintf、memcpy这三个函数的不同之处？</h3><ol id="f3dbc925-f87f-49fa-be18-7c7f2db900d7" class="numbered-list" start="1"><li><strong>操作对象</strong><ul id="4426b20b-03ce-4d18-a8f7-631b5df47084" class="bulleted-list"><li>strcpy的两个操作对象均为字符串</li></ul><ul id="7e7d6c5f-afbc-4f26-9ac5-f5756ead375d" class="bulleted-list"><li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li></ul><ul id="64ed3b17-af6b-4ef6-a4be-f890120901af" class="bulleted-list"><li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型</li></ul></li></ol><ol id="8912caa2-4385-459b-85dd-ccb2cb548f61" class="numbered-list" start="2"><li><strong>实现功能</strong><ul id="41b93b35-bfe5-485f-8a46-aaf1669eb3a6" class="bulleted-list"><li>strcpy主要实现<strong>字符串变量间的拷贝</strong></li></ul><ul id="d331f259-884e-4900-9e3a-a7ac3fa09c4e" class="bulleted-list"><li>sprintf主要实现<strong>其他数据类型格式到字符串的转化</strong></li></ul><ul id="450ef532-ea65-460a-be9d-22e4d19f18e7" class="bulleted-list"><li>memcpy主要是<strong>内存块间的拷贝</strong></li></ul></li></ol><ol id="2ba6c57f-0408-4983-b0c7-558e81240a6a" class="numbered-list" start="3"><li><strong>执行效率</strong><p id="6299e2eb-7ccd-44cb-b39c-c0d8882d7eb5" class="">memcpy最高，strcpy次之，sprintf的效率最低。</p></li></ol><p id="90037ae4-18c1-45e0-8841-d2a985c35a77" class="">
</p><p id="9bd4d182-275c-48a2-91ef-ae310e231f77" class="">
</p><h3 id="e447c78d-7fdb-4de9-9d78-769cc4ac8826" class="">实现strcpy函数？</h3><pre id="addd9f6c-fce3-4954-a6b0-e5c9205ea793" class="code"><code>
char* myStrcpy(char* s1, const char* s2){
    assert(s1!=nullptr &amp;&amp; s2!=nullptr); //要判断
    
    char* dst = s1;
    while ((*s1++ = *s2++) != &#x27;\0&#x27;){} // 必须在循环判断里赋值，否则最后一个&#x27;\0&#x27;会遗漏
    
    return dst; //返回，用于链式存储
}</code></pre><p id="646e68ef-51e9-4812-b985-072b35feef64" class="">
</p><p id="cbd9dcd0-ba66-43dc-9f83-9f54ce992a99" class="">
</p><p id="ac8c580f-7556-40cc-919a-9891917afb72" class="">
</p><p id="a8ac10e3-b487-4979-b94d-7ac176b42db5" class="">
</p><p id="789fcbed-2337-4059-a131-cf75e994df22" class="">
</p><h2 id="80420e60-adf6-4e44-bc41-630b9c975dd4" class="">区别s</h2><h3 id="f3619e74-4ba6-47ff-9b71-885eb745b0f8" class="">static全局变量和非static全局变量的区别？</h3><p id="e7c71467-c539-4e5e-90bd-d2fc23750820" class="">用static声明的外部变量，只能供本文件内的函数调用，不能被其它文件的函数所调用。</p><p id="55bbe2f0-eab6-4e39-bfaf-8b58dee1d0d6" class="">
</p><p id="7f3a9e9c-487b-4629-8542-13ffe94ade21" class="">
</p><h3 id="d4006ea4-5e05-4314-af11-daffaf38720d" class="">变量声明和定义的区别？</h3><ul id="607220aa-b6b7-42de-9792-1e9c1a587eb6" class="bulleted-list"><li>声明仅仅是把变量的声明的位置及类型提供给编译器，<strong>并不分配内存空间</strong>；定义要在<strong>定义的地方为其分配存储空间</strong>。</li></ul><ul id="8c608fe3-688b-4fde-b825-126fe4257bfd" class="bulleted-list"><li>相同变量可以在<strong>多处声明</strong>(外部变量extern)，但只能在<strong>一处定义</strong>。</li></ul><figure id="04d45780-0840-4483-bf58-af4e3ea7c318"><a href="http://www.360doc.com/content/11/1105/21/4083881_162098853.shtml" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">变量定义与声明的区别</div><div class="bookmark-description">(1) 对于局部变量用 static 声明，则是为该变量分配的空间在整个程序的执行期内都始终存在 Declarations and Definitions As we&#x27;ll see in (p. ), C++ programs typically are composed of many files. In order for multiple files to access the same variable, C++ distinguishes between declarations and definitions. 变量的定义（ definitions ）会为这个变量分配存储空间，并且可能会为其指定一个初始化的值。在程序里，一个变量必须有一个，也只能有一处定义（ definitions ）。 A declaration makes known the type and name of the variable to the program.</div></div><div class="bookmark-href"><img src="http://www.360doc.com/favicon.ico" class="icon bookmark-icon"/>http://www.360doc.com/content/11/1105/21/4083881_162098853.shtml</div></div><img src="http://pubimage.360doc.com/index7/dingtu.gif" class="bookmark-image"/></a></figure><p id="0287c871-7be1-42aa-b14b-9c23e745a976" class="">
</p><h3 id="6464399b-df86-4186-bdc1-e49fdbcf7af3" class="">strlen和sizeof的区别？</h3><ul id="8beaf97a-fd80-41aa-a9f6-14c05164773f" class="bulleted-list"><li><strong>sizeof是运算符，不是函数，结果在编译时得到</strong>，而非运行中获得；strlen是字符处理的库函数</li></ul><ul id="3015baa3-f667-4d13-bbd8-0342f4583421" class="bulleted-list"><li>sizeof的参数可以是任何数据类型；strlen的参数只能是字符指针且结尾是&#x27;\0&#x27;的字符串</li></ul><ul id="93406684-ce38-4557-a826-d87aae887e75" class="bulleted-list"><li>因为sizeof值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小。</li></ul><p id="baf2b83d-6da0-42c5-8238-6322284c876d" class="">
</p><h3 id="62591b4d-cd96-4731-ba7a-833b82f823b4" class="">在 <code>int a[10]</code> 中a和&amp;a有什么区别？</h3><pre id="009101b3-ff1b-4312-b94e-f756b7a9f7bc" class="code"><code>int a[10];
int (*p)[10] = &amp;a;</code></pre><ul id="73b4082d-3d91-4bcb-a45a-056d8e80d82c" class="bulleted-list"><li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是
0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li></ul><ul id="a27e879b-4a09-4d1d-85e5-ad1bd4c4361a" class="bulleted-list"><li>&amp;a是数组的指针，其类型为int (*)[10](就是前面提到的数组指针)，其加1时，系统会认为是数组首地址加上整个数组的偏移(10个int型变量)，值为数组a尾元素后一个元素的地址。</li></ul><ul id="cb143d70-e926-4cc7-83b5-ec1030cc1dd0" class="bulleted-list"><li>若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来 读取。</li></ul><p id="167bc377-5f30-46b5-80c2-9cd82b36ef77" class="">
</p><h3 id="047dbea8-9cd9-4bb7-b186-d7d237b12527" class="">数组名和指针的区别？</h3><p id="8f887ca3-d0f9-4a45-910f-f35b3cfc3596" class=""><strong>区别：</strong></p><ul id="4795560d-3c58-46fb-9473-036896c7c2b0" class="bulleted-list"><li>数组名不是真正意义上的指针，可以理解为常指针，所以<strong>数组名没有自增、自减等操作</strong>。</li></ul><ul id="3a687006-7939-4a6a-826f-5dab9db2bcd6" class="bulleted-list"><li>sizeof(数组名)得到的是数组的大小；sizeof(指针)得到的是指针的大小（4或8）。</li></ul><p id="b367835f-a51c-4c6e-a86f-641bf393773f" class=""><strong>联系：</strong></p><ul id="771b6e25-d9d8-423e-a9fd-151be5ceba2c" class="bulleted-list"><li>二者均可通过增减偏移量来访问数组中的元素。</li></ul><ul id="7dcbf493-5d47-4ab9-afa5-e269dc912c60" class="bulleted-list"><li>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</li></ul><p id="05915cca-5971-46ae-b144-416a6e106856" class="">
</p><h3 id="0dd9e405-0b00-4d57-954a-bcfb3dba9576" class="">struct和class的区别？</h3><p id="70da2858-c1af-4a00-a1e7-86951fc17ebd" class="">相同点：</p><ul id="d74885a6-603b-4898-9601-e63637db4507" class="bulleted-list"><li>两者都拥有成员函数、公有和私有部分 </li></ul><ul id="0f374ded-f600-4e69-be7f-bbefc9a1cfe4" class="bulleted-list"><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p id="709e0b18-8703-48ff-a72b-fa30e59cc313" class="">不同点：</p><ul id="a0f00827-dca8-4f38-b173-1662938b3419" class="bulleted-list"><li>两者中如果不对成员指定公私有，<strong>struct默认是公有的，class则默认是私有的</strong> </li></ul><ul id="58aa4621-6670-46f7-9708-46187cd1235b" class="bulleted-list"><li><strong>class默认是private继承，而struct模式是public继承</strong></li></ul><p id="7781fd5e-9b38-42d9-af71-4fc667fd7c29" class="">
</p><p id="4b405409-67b9-4b82-9f3e-7db18610fa9b" class="">
</p><h3 id="d9a51459-f406-435e-acc1-cc012356704c" class="">define宏定义和const的区别？</h3><p id="153a1952-7577-4b49-a144-62767fc7802d" class="">作用阶段：</p><ul id="a2c2b94d-9a2e-44f1-84a3-a4a48ccbd049" class="bulleted-list"><li>define是在编译的<strong>预处理</strong>阶段起作用，而const是在编译、运行的时候起作用</li></ul><p id="004b7801-12d2-420c-9a8b-2d2792d4f7bb" class="">安全性：</p><ul id="4a498624-5717-4f70-bf4f-6bb66e3d3e7a" class="bulleted-list"><li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li></ul><ul id="d2d44fad-fa9e-4a5e-b4cc-3805fdbd1a6b" class="bulleted-list"><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p id="eab24048-0fd0-4a31-8fad-1a0280281c64" class="">内存占用：</p><ul id="52965ea6-2c96-4709-8fc8-f4efa4efe218" class="bulleted-list"><li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配 内存空间。</li></ul><ul id="920c98ed-b6e4-4b31-8826-a906b06152ea" class="bulleted-list"><li>define只是将宏名称进行替换，在内存中会产生多分相同的备份（代码区？）。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li></ul><p id="1c1bd105-3715-4629-97fa-4b4073e5f184" class="">
</p><h3 id="40b356de-1c74-4806-8d7e-3914789f0990" class="">const和static的区别？</h3><p id="7acd0428-0cfe-4c55-a710-2516edf625c7" class="">
</p><p id="7ed6b1dd-232a-4bd9-a1a7-08ea261778ee" class="">
</p><p id="9fcd9bda-5015-4f50-b9d9-63c7c341afb1" class="">
</p><h3 id="bad8a8a9-b18f-465f-b226-069442cb469c" class="">浅拷贝和深拷贝的区别？</h3><p id="9eb96e36-a92d-4c97-b605-0d15527a5043" class=""><strong>浅拷贝</strong></p><p id="3a34adde-d165-4999-b4eb-c26a363bd8ba" class="">浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p id="1f936de8-0246-4de1-878c-c0b011ef6b99" class=""><strong>深拷贝</strong></p><p id="4398fe08-2093-474a-8e6c-5a575441fb4b" class="">深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p><p id="fec8b78b-9f4b-4529-8ccc-4cbdb350321a" class="">
</p><p id="107c7457-fbde-46ae-aa09-b867a98db6b5" class="">
</p><h3 id="8897cdf0-203d-458a-bbc0-00f97d079918" class="">strcpy和memcpy的区别？</h3><ul id="08bf5357-a1bb-4666-b3e4-8faa5c26f6e8" class="bulleted-list"><li>strcpy只能复制字符串，而memcpy可以复制任意内容（如字符数组、整型、结构体、类等）。</li></ul><ul id="34886178-7572-460e-ac67-57e55c9301ef" class="bulleted-list"><li>strcpy不需指定长度，它遇到&#x27;\0&#x27;才结束，容易溢出；memcpy根据第三个参数决定复制的长度。</li></ul><p id="d0004d07-38b6-429b-a9a1-334c26cf6f9a" class="">
</p><p id="c6eae386-bb48-4ac4-93f4-07ae0ae0411b" class="">
</p><p id="c1063a3e-73d6-4d3a-9e13-4144ef012267" class="">
</p><p id="d41128b6-c817-45ad-96a1-085a8e240ec2" class="">
</p><h2 id="9324afd9-5fdd-4d35-8d58-f4fdde4fb653" class="">模板</h2><h3 id="20e6610f-ec41-480a-93ca-ecffc8e3f8fd" class="">类模板和模板类的区别？</h3><p id="46ac679f-7486-400b-abf1-f1b3ceadada7" class="">类模板：说明该类是一个模板，专门用于产生类的模子。</p><p id="9156909e-996e-447f-95fc-6292cf721c66" class="">模板类：是类，是由一个模板生成而来的类，例如Vector&lt;int&gt;, Vector&lt;char&gt;都是模板类。</p><p id="c1fe2ede-7258-4e12-84fd-738f05dd31aa" class="">
</p><h3 id="b222cff3-40ea-4e97-b0ea-27bb9f5eba02" class="">模板函数和模板类的特例化？</h3><p id="32e57ecb-3721-43a9-98ed-ea4afdd40ac5" class=""><strong>引入原因：</strong></p><p id="58bd7f32-d954-449a-b4a6-4d878bb73110" class="">编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但<span style="border-bottom:0.05em solid">对于某种特定类型，如果要实现其特有的功能</span>，单一模板就无法做到，这时就需要模板特例化</p><p id="0de2135c-9f7a-4a81-b84e-6988827c1fc8" class=""><strong>使用方法：</strong></p><p id="a4886172-5ad2-4e7f-820d-3c5ae1390c60" class="">使用关键字template后跟一个空尖括号对&lt;&gt;，表明将为原模板的所有模板参数提供实参</p><p id="66e99ad4-b57b-4e86-89fb-eef4d357801c" class=""><strong>匹配方式：</strong></p><p id="a578ad15-b2e0-4caa-bb3a-cc24edbaf69b" class="">最佳匹配原则</p><p id="da8145ea-102a-402e-9b8f-3c77843e458e" class="">
</p><h3 id="defecc28-e8e5-4c40-8f13-197cddcca437" class="">模板的底层怎么实现的？</h3><p id="43fdcab5-7e8b-4202-a199-b9376cda7d20" class="">编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译（将类型参数直接内嵌替换到类定义出，编译出具体的类型，再使用这个类型）。</p><p id="5162ac3b-e5c2-4711-9aa4-bebaedb6259c" class="">
</p><h3 id="05509be4-8774-4c10-98a4-32aa83c10b54" class="">类模板和函数模板的区别是什么？</h3><p id="f057efdf-b829-42ec-be37-94397e4bcd34" class="">函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即<strong>函数模板允许隐式调用和显式调用而类模板只能显示调用</strong>。在使用时类模板必须加&lt;&gt;，而函数模板不必</p><p id="289359cc-8d88-4d3b-bad2-4b3b0c51b248" class="">
</p><h3 id="46bfe0d5-d6c0-4367-92cc-17c1c9987796" class="">为什么模板类一般都是放在一个.h文件中？</h3><ol id="cf3a7852-f45f-47d6-b3bf-afc0fea87714" class="numbered-list" start="1"><li>模板定义很特殊。<strong>由template&lt;...&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间</strong>，它一直处于等待状态直到被一个模板实例告知，在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。<p id="dcd62458-565f-4c7d-8412-8f6a6f637027" class="">所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p></li></ol><ol id="0859f71f-66b5-41bf-8817-ab55f2a7db1f" class="numbered-list" start="2"><li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找(当遇到未决符号时它会寄希望于连接器)。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。<p id="06b27c7d-6bfa-42ca-97d0-c920d18f153f" class="">所以，<strong>当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</strong></p><p id="f4c5e056-ee35-4bc6-92e8-41e6fffd6844" class="">然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p></li></ol><p id="b55a8d50-012a-49a7-a855-a34427f84602" class="">
</p><h3 id="529b6e5b-8338-4446-b75b-723dc00d3c05" class="">模板的优缺点？</h3><p id="72076c53-9554-4df3-baed-e3c15b477a32" class=""><strong>优点:</strong></p><ol id="b37edd2c-d794-4f87-92cd-6fdd2e5f513b" class="numbered-list" start="1"><li>灵活性, 可重用性和可扩展性;</li></ol><ol id="b4fecfdb-b11e-420d-95f6-0f598452d09b" class="numbered-list" start="2"><li>可以大大减少开发时间，模板可以把用同一个算法去适用于不同类型数据，在编译时确定具体的数据类型;</li></ol><ol id="42b715a7-0e63-4dc5-8579-f7fa5832953e" class="numbered-list" start="3"><li>模版模拟多态要比C++类继承实现多态效率要高, 无虚函数, 无继承;</li></ol><p id="ac6dbf03-e86c-4dd5-a3ee-938d4572b27b" class=""><strong>缺点：</strong></p><ol id="a0b5f2f3-8f9e-4fdf-9d9d-e500d01aba72" class="numbered-list" start="1"><li>易读性比较不好，调试比较困难;</li></ol><ol id="bc3b402f-749f-48ac-ad49-9453bd5f18ca" class="numbered-list" start="2"><li>模板的数据类型只能在编译时才能被确定;</li></ol><ol id="92aa3ac6-f1bb-4dab-8abc-3fcd70c7d1c4" class="numbered-list" start="3"><li>所有用基于模板算法的实现必须包含在整个设计的.h头文件中, 当工程比较大的时候, 编译时间较长;</li></ol><p id="7ba4b359-a3b4-483e-a345-4732bfad1c1f" class="">
</p><h3 id="aa873247-50f2-426b-854a-758b3015900c" class="">手写比较大小的模板函数。</h3><pre id="6b1d4701-18a1-4b55-b1ba-b0c21c0431ed" class="code"><code>template&lt;class T1&gt;
bool islarger(T1 a, T1 b){
		return a &gt; b;
}

template&lt;class T1&gt;
T1 largerone(T1 a, T1 b){
		return a&gt;b ? a : b;
}</code></pre><p id="69ff7036-c364-4d83-ae4a-fc1c2113c3c7" class="">
</p><p id="939fc764-4bda-4c79-9f5e-6eb206affd64" class="">
</p><p id="c62fefbf-de5f-4e1a-bef1-6bc1bd01053f" class="">
</p><p id="9c373595-ccad-4d3b-9f17-fa8a002c94ca" class="">
</p><p id="a48d6743-2c85-44cb-98bb-1c7e9de8e502" class="">
</p><h2 id="7fcd3360-d830-4458-800c-a452c9f2da72" class="">与C</h2><h3 id="d5f1947e-92e7-4bf4-8d8f-c6b63dee3385" class="">NULL和nullptr的区别？</h3><p id="b667e022-dd6b-46c6-bde4-867267fbc987" class="">在C语言中，NULL被定义为(void*)0，而在C++语言中，NULL则被定义为整数0。</p><p id="c013bee7-1e61-4a6e-a3e4-85afbb566520" class=""><strong>nullptr的引入：</strong></p><p id="2a3c5ffb-ebdb-4f88-a208-73f19b977d7f" class="">为了解决什么问题：</p><pre id="94ce8de5-a5fe-44c4-a838-0d5cbb7498a6" class="code"><code>//NULL定义为0带来的另一个问题是无法与整数的0区分
void fun(char* p) {
    cout &lt;&lt; &quot;char*&quot; &lt;&lt; endl;
}
void fun(int p) {
    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;
}
int main() {
fun(NULL);
return 0; }
//输出结果:int</code></pre><p id="6a44bc20-aabf-48c6-884d-00e3543496a9" class="">nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p><p id="acef9f60-e76d-4dd3-aeb4-d8067dccfb28" class="">
</p><h3 id="c45ecc85-225d-45ca-8c15-b960fff3d126" class="">extern &quot;C&quot;？</h3><ol id="e40b50ec-380d-460b-8013-af91dc1f36d8" class="numbered-list" start="1"><li><strong>出现原因</strong><p id="df81417a-37f2-47e0-b1ce-9d6618cdf457" class="">在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern &quot;C&quot;就是其中的一个策略。</p></li></ol><ol id="a61577ba-29d7-45a0-90af-b42c8b031cd2" class="numbered-list" start="2"><li><strong>作用</strong><p id="e2a12edb-ed23-41a1-98b0-28d5739eda5d" class="">这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern &quot;C&quot;就是其中的一个策略。</p></li></ol><ol id="01501a2e-3916-4362-819b-b5b3f2fd6ba5" class="numbered-list" start="3"><li><strong>使用方法</strong><p id="bd5eee39-0d0e-4706-9e46-63a5145f5ab2" class="">在C语言代码前面加上 <code>extern &quot;C&quot;</code> ，代码用{}括起来。</p><p id="1b33cfc4-a989-45d6-ba8a-2fe8007a07cb" class="">在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持 extern &quot;C&quot;声明，在.c文件中包含了extern &quot;C&quot;时会出现编译语法错误。所以使用extern &quot;C&quot;全部都放在于cpp程序相关文件或其头文件中。</p><pre id="3a8c4318-f7c6-4911-9674-fe29972a9389" class="code"><code>//-------------------C++调用C函数---------------------
//xx.h
extern int add(...)

//xx.c
int add(){}

//xx.cpp
extern &quot;C&quot;{
		#include &quot;xx.h&quot;
}

//---------------------C调用C++函数--------------------
//xx.h
extern &quot;C&quot;{
		int add();
}

//xx.cpp
int add(){
}

//xx.c
extern int add();

//-------------------总之extern &quot;C&quot;都是在C++的文件中-----------------</code></pre></li></ol></div></article></body></html>